/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.7",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs2 = require("fs");
    var path2 = require("path");
    var os = require("os");
    var crypto2 = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse3(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs2.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
      }
      if (fs2.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path2.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path3 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs2.readFileSync(path3, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path3} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse3,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TextProcessingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var dotenv = __toESM(require_main());

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError = class extends Error {
  constructor(response, request2) {
    const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request2
    })}`;
    super(message);
    __publicField(this, "response");
    __publicField(this, "request");
    Object.setPrototypeOf(this, ClientError.prototype);
    this.response = response;
    this.request = request2;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b, _c;
    return (_c = (_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) != null ? _c : `GraphQL Error (Code: ${String(response.status)})`;
  }
};

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase();
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
var zip = (a, b) => a.map((k, i) => [k, b[i]]);
var HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== void 0) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
};
var HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v, k) => {
    o[k] = v;
  });
  return o;
};
var tryCatch = (fn) => {
  try {
    const result = fn();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
};
var errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
};
var isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
};
var casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
};
var isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path: path2, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  const document = parser.parseDocument();
  Object.defineProperty(document, "tokenCount", {
    enumerable: false,
    value: parser.tokenCount
  });
  return document;
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path2 = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path2.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path2, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path2.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path2.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`;
var CONTENT_TYPE_HEADER = `Content-Type`;
var CONTENT_TYPE_JSON = `application/json`;
var CONTENT_TYPE_GQL = `application/graphql-response+json`;

// node_modules/graphql-request/build/legacy/lib/graphql.js
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
};
var parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e) {
    return e;
  }
};
var parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors = void 0;
  let data = void 0;
  let extensions = void 0;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors,
    extensions
  };
};
var isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult);
var isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors);
var isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === Kind.OPERATION_DEFINITION;
};

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var extractOperationName = (document) => {
  var _a;
  let operationName = void 0;
  const defs = document.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = (_a = defs[0].name) == null ? void 0 : _a.value;
  }
  return operationName;
};
var extractIsMutation = (document) => {
  let isMutation = false;
  const defs = document.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === OperationTypeNode.MUTATION;
  }
  return isMutation;
};
var analyzeDocument = (document, excludeOperationName) => {
  const expression = typeof document === `string` ? document : print(document);
  let isMutation = false;
  let operationName = void 0;
  if (excludeOperationName) {
    return { expression, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document === `string` ? parse(document) : document);
  if (docNode instanceof Error) {
    return { expression, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression, operationName, isMutation };
};

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  var _a, _b, _c, _d;
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase((_a = input.method) != null ? _a : `post`) : input.request.hasMutations ? `POST` : uppercase((_b = input.method) != null ? _b : `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: (_c = input.fetchOptions.errorPolicy) != null ? _c : `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, (_d = input.fetchOptions.jsonSerializer) != null ? _d : defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
};
var executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : void 0
  };
};
var parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
};
var createFetcher = (method) => async (params) => {
  var _a, _b;
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = void 0;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = (_a = params.fetchOptions.jsonSerializer) != null ? _a : defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : void 0,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = (_b = params.fetch) != null ? _b : fetch;
  return await $fetch(url, initResolved);
};
var buildBody = (params) => {
  var _a;
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, (_a = params.request.variables) != null ? _a : []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
};
var buildQueryParams = (params) => {
  var _a, _b, _c;
  const $jsonSerializer = (_a = params.fetchOptions.jsonSerializer) != null ? _a : defaultJsonSerializer;
  const searchParams = new URLSearchParams();
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = (_c = (_b = params.request.variables) == null ? void 0 : _b.map((v) => $jsonSerializer.stringify(v))) != null ? _c : [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    __publicField(this, "rawRequest", async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const document = analyzeDocument(rawRequestOptions.query, excludeOperationName);
      const response = await runRequest({
        url,
        request: {
          _tag: `Single`,
          document,
          variables: rawRequestOptions.variables
        },
        headers: {
          ...HeadersInitToPlainObject(callOrIdentity(headers)),
          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
        },
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      });
      if (responseMiddleware) {
        await responseMiddleware(response, {
          operationName: document.operationName,
          variables,
          url: this.url
        });
      }
      if (response instanceof Error) {
        throw response;
      }
      return response;
    });
    this.url = url;
    this.requestConfig = requestConfig;
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    var _a;
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document }) => analyzeDocument(document, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression }) => expression);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: void 0,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: (_a = this.requestConfig.fetch) != null ? _a : globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: void 0,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};

// node_modules/graphql-request/build/legacy/functions/request.js
async function request(urlOrOptions, document, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRequestExtendedArgs = (urlOrOptions, document, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return typeof urlOrOptions === `string` ? {
    url: urlOrOptions,
    document,
    variables,
    requestHeaders,
    signal: void 0
  } : urlOrOptions;
};

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// main.ts
var DEFAULT_SETTINGS = {
  repo: "moontherefor/obsidian_sync_test",
  branch: "main"
};
var TextProcessingPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TextProcessingPluginSettingTab(this.app, this));
    this.addCommand({
      id: "convert-article-headings",
      name: "\u6CD5\u898F\u6574\u7406",
      callback: () => this.convertArticleHeadings()
    });
    this.addCommand({
      id: "clean-table",
      name: "\u689D\u6587\u5C0D\u7167\u8868\u6574\u7406",
      callback: () => this.cleanTable()
    });
    this.addCommand({
      id: "split-document",
      name: "\u6559\u6AA2\u8003\u984C\u62C6\u5206",
      callback: () => this.splitDocument()
    });
    this.addCommand({
      id: "pull-vault-from-github",
      name: "\u5F9E GitHub \u62C9\u53D6 Vault",
      callback: () => this.pullVaultFromGitHub()
    });
    this.addCommand({
      id: "push-vault-to-github",
      name: "\u63A8\u9001 Vault \u5230 GitHub",
      callback: () => this.pushVaultToGitHub()
    });
    this.addCommand({
      id: "sync-vault-with-github",
      name: "\u540C\u6B65 Vault \u8207 GitHub",
      callback: () => this.syncVaultWithGitHub()
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        menu.addItem((item) => {
          item.setTitle("\u6CD5\u898F\u6574\u7406").setIcon("heading").onClick(() => {
            this.convertArticleHeadings();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u689D\u6587\u5C0D\u7167\u8868\u6574\u7406").setIcon("heading").onClick(() => {
            this.cleanTable();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u6559\u6AA2\u8003\u984C\u62C6\u5206").setIcon("scissors").onClick(() => {
            this.splitDocument();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u540C\u6B65 Vault \u8207 GitHub").setIcon("sync").onClick(() => {
            this.syncVaultWithGitHub();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u63A8\u9001 Vault \u5230 GitHub").setIcon("cloud-upload").onClick(() => {
            this.pushVaultToGitHub();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u5F9E GitHub \u62C9\u53D6 Vault").setIcon("cloud-download").onClick(() => {
            this.pullVaultFromGitHub();
          });
        });
      })
    );
    this.ensureEnvFileIsIgnored();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   *  .env  .gitignore 
   */
  ensureEnvFileIsIgnored() {
    const vaultPath = this.app.vault.adapter.basePath;
    const gitignorePath = path.join(vaultPath, ".gitignore");
    const envFileEntry = ".env\n*.ini\n";
    if (fs.existsSync(gitignorePath)) {
      const gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
      if (!gitignoreContent.includes(".env")) {
        fs.appendFileSync(gitignorePath, ".env\n");
      }
      if (!gitignoreContent.includes("*.ini")) {
        fs.appendFileSync(gitignorePath, "*.ini\n");
      }
    } else {
      fs.writeFileSync(gitignorePath, envFileEntry);
    }
  }
  /**
   *  Vault  GitHub
   */
  async pushVaultToGitHub() {
    this.ensureEnvFileIsIgnored();
    const token = this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const files = this.app.vault.getFiles().filter((file) => !file.path.endsWith(".ini"));
    const totalFiles = files.length;
    let successCount = 0;
    let failureCount = 0;
    const batchSize = 10;
    const progressNotice = new import_obsidian.Notice(`\u63A8\u9001\u9032\u5EA6: 0/${totalFiles}`, 0);
    for (let i = 0; i < totalFiles; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      for (const file of batch) {
        const filePath = file.path;
        const content = await this.app.vault.read(file);
        const message = `Update ${filePath}`;
        const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}`;
        const headers = {
          "Authorization": `token ${token}`,
          "Content-Type": "application/json"
        };
        try {
          const response = await fetch(url, { headers });
          const data = await response.json();
          const sha = data.sha;
          const localSha = crypto.createHash("sha1").update(Buffer.from(content)).digest("hex");
          if (sha !== localSha) {
            const body = {
              message,
              content: Buffer.from(content).toString("base64"),
              //  Buffer  base64 
              branch,
              sha
            };
            const pushResponse = await fetch(url, {
              method: "PUT",
              headers,
              body: JSON.stringify(body)
            });
            if (pushResponse.ok) {
              successCount++;
            } else {
              const errorData = await pushResponse.json();
              console.error(`Error pushing file ${filePath} to GitHub: ${errorData.message}`);
              failureCount++;
            }
          } else {
            successCount++;
          }
        } catch (error) {
          console.error(`Error pushing file ${filePath} to GitHub:`, error);
          failureCount++;
        }
        progressNotice.setMessage(`\u63A8\u9001\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
      }
    }
    progressNotice.hide();
    new import_obsidian.Notice(`\u63A8\u9001\u5B8C\u6210: \u6210\u529F ${successCount} \u500B\u6587\u4EF6, \u5931\u6557 ${failureCount} \u500B\u6587\u4EF6`);
  }
  /**
   *  GitHub  Vault
   */
  async pullVaultFromGitHub() {
    const token = this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const endpoint = "https://api.github.com/graphql";
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
    const query = gql`
            query($repo: String!, $branch: String!) {
                repository(name: $repo, owner: "moontherefor") {
                    object(expression: $branch) {
                        ... on Commit {
                            tree {
                                entries {
                                    name
                                    type
                                    oid
                                    object {
                                        ... on Blob {
                                            text
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        `;
    const variables = {
      repo,
      branch
    };
    try {
      const response = await request(endpoint, query, variables, headers);
      const files = response.repository.object.tree.entries.filter((item) => item.type === "blob" && !item.name.endsWith(".ini"));
      const totalFiles = files.length;
      let successCount = 0;
      let failureCount = 0;
      const progressNotice = new import_obsidian.Notice(`\u62C9\u53D6\u9032\u5EA6: 0/${totalFiles}`, 0);
      const pullPromises = files.map(async (file) => {
        const filePath = file.name;
        const content = file.object.text;
        try {
          if (await this.app.vault.adapter.exists(filePath)) {
            const localContent = await this.app.vault.adapter.read(filePath);
            const localSha = crypto.createHash("sha1").update(Buffer.from(localContent)).digest("hex");
            if (localSha === file.oid) {
              successCount++;
              progressNotice.setMessage(`\u62C9\u53D6\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
              return;
            }
          }
          const dirPath = path.dirname(filePath);
          await this.app.vault.adapter.mkdir(dirPath);
          await this.app.vault.adapter.write(filePath, content);
          successCount++;
        } catch (error) {
          console.error(`Error pulling file ${filePath} from GitHub:`, error);
          failureCount++;
        }
        progressNotice.setMessage(`\u62C9\u53D6\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
      });
      await Promise.all(pullPromises);
      progressNotice.hide();
      new import_obsidian.Notice(`\u62C9\u53D6\u5B8C\u6210: \u6210\u529F ${successCount} \u500B\u6587\u4EF6, \u5931\u6557 ${failureCount} \u500B\u6587\u4EF6`);
    } catch (error) {
      console.error(`Error pulling Vault from GitHub:`, error);
      new import_obsidian.Notice(`\u5F9E GitHub \u62C9\u53D6 Vault \u6642\u767C\u751F\u932F\u8AA4`);
    }
  }
  /**
   *  Vault  GitHub
   */
  async syncVaultWithGitHub() {
    await this.pullVaultFromGitHub();
    await this.pushVaultToGitHub();
    new import_obsidian.Notice("Vault \u8207 GitHub \u540C\u6B65\u5B8C\u6210");
  }
  getTokenFromEnv() {
    const vaultPath = this.app.vault.adapter.basePath;
    const envPath = path.join(vaultPath, ".env");
    if (fs.existsSync(envPath)) {
      const envConfig = dotenv.parse(fs.readFileSync(envPath));
      return envConfig.GITHUB_TOKEN || null;
    }
    return null;
  }
  /**
   * 
   */
  processSelectedText(processor) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      const processedText = processor(selectedText);
      editor.replaceSelection(processedText);
    }
  }
  /**
   * 
   */
  convertArticleHeadings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const content = editor.getValue();
      const updatedContent = content.replace(/^\s*[]+\s*/gm, (match) => `# ${match}`).replace(/^\s*[]+\s*/gm, (match) => `## ${match}`).replace(/^\s*[]+\s*/gm, (match) => `### ${match}`).replace(/^\s*[]+\s*/gm, (match) => `#### ${match}`).replace(/^\s*[]+\s*/gm, (match) => `##### ${match}`).replace(/^\s*\d+\s*/gm, (match) => `###### ${match}`).replace(/^/gm, (match) => `# ${match}`);
      editor.setValue(updatedContent);
    }
  }
  /**
   * 
   */
  async splitDocument() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      try {
        this.cleanDocument();
        const editor = activeView.editor;
        const content = editor.getValue();
        const folderPathPre = this.app.vault.getAbstractFileByPath(activeView.file.path).path;
        const folderPath = folderPathPre.replace(/.md$/, "");
        const currentFileName = activeView.file.basename;
        const folderName = folderPath.split("/").pop();
        await this.app.vault.createFolder(folderPath);
        const sections = content.split(/(?=^\d+\.)/gm);
        let updatedContent = content;
        const fileNames = /* @__PURE__ */ new Set();
        const prefix = `---
tags:
  - \u8003\u984C
  - \u984C\u76EE
  - \u672A\u5B8C
Sourse:
Relate: 
aliases:
---
`;
        for (let i = 0; i < sections.length; i++) {
          const section = sections[i];
          const sectionTitle = (_a = section.match(/^\d+\./)) == null ? void 0 : _a[0];
          if (sectionTitle) {
            let cleanTitle = sectionTitle.replace(/\.$/, "").trim();
            let newFileName = `${folderPath}/${folderName}-\u7B2C1\u5927\u984C\u7B2C${cleanTitle}\u984C.md`;
            let counter = 2;
            while (fileNames.has(newFileName)) {
              newFileName = `${folderPath}/${folderName}-\u7B2C${counter}\u5927\u984C\u7B2C${cleanTitle}\u984C.md`;
              counter++;
            }
            fileNames.add(newFileName);
            await this.app.vault.create(newFileName, prefix + section);
            updatedContent = updatedContent.replace(section, `## ![[${folderName}-\u7B2C${counter - 1}\u5927\u984C\u7B2C${cleanTitle}\u984C]]
`);
          }
        }
        editor.setValue(updatedContent);
      } catch (error) {
        console.error("Error splitting document:", error);
        if (error instanceof TypeError) {
          new import_obsidian.Notice("\u62C6\u5206\u6587\u4EF6\u6642\u767C\u751F\u985E\u578B\u932F\u8AA4\uFF0C\u8ACB\u6AA2\u67E5\u63A7\u5236\u53F0\u4EE5\u7372\u53D6\u8A73\u7D30\u8CC7\u8A0A\u3002");
        } else if (error instanceof ReferenceError) {
          new import_obsidian.Notice("\u62C6\u5206\u6587\u4EF6\u6642\u767C\u751F\u5F15\u7528\u932F\u8AA4\uFF0C\u8ACB\u6AA2\u67E5\u63A7\u5236\u53F0\u4EE5\u7372\u53D6\u8A73\u7D30\u8CC7\u8A0A\u3002");
        }
      }
    }
  }
  /**
   * 
   * - 1
   * - "n.""n."""
   */
  cleanDocument() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      let content = editor.getValue();
      content = content.replace(/^\d+\s*$/gm, "");
      content = content.replace(/(\d+\.[^]*)/gm, (match, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/([^]*)/gm, (_, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/([^]*)/gm, (_, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/\([^)]*\)/gm, (match) => match.replace(/\n/g, ""));
      editor.setValue(content);
    }
  }
  // 
  cleanTable() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      let content = editor.getValue();
      let yamlHeader = "";
      const yamlMatch = content.match(/^---\n[\s\S]*?\n---\n/);
      if (yamlMatch) {
        yamlHeader = yamlMatch[0];
        content = content.slice(yamlHeader.length);
      }
      content = content.replace(/\*\*/g, "==").replace(/\(/g, "\uFF08").replace(/\)/g, "\uFF09").replace(/<br>/g, " ").replace(/[ \t]+/g, " ");
      content = content.split("\n").filter((line) => !/^[\|\-\s]*$/.test(line)).join("\n");
      content = content.replace(/\| +/g, "|");
      const lines = content.split("\n");
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].startsWith("|") && !/\|[]+\s*.*$/.test(lines[i])) {
          const previousCells = lines[i - 1].split("|");
          const currentCells = lines[i].split("|");
          for (let j = 0; j < currentCells.length; j++) {
            if (currentCells[j].trim() !== "") {
              previousCells[j] = (previousCells[j] || "") + currentCells[j];
            }
          }
          lines[i - 1] = previousCells.join("|");
          lines.splice(i, 1);
          i--;
        }
      }
      content = lines.join("\n");
      content = content.replace(/(?<![a-zA-Z0-9_.,])[ \t]+|[ \t]+(?![a-zA-Z0-9_.,])|^[ \t]+|[ \t]+$/gm, "");
      content = content.split("\n").map((line) => {
        if (line.startsWith("|")) {
          const parts = line.split("|");
          if (parts.length > 3) {
            const firstPart = parts.slice(0, 3).join("|");
            let secondPart = parts.slice(3).join("|").replace(/\|\s*$/, "");
            secondPart = secondPart.replace(/(\d+)\./g, "\n		$1. ");
            secondPart = secondPart.replace(/([]+)/g, (match, p1) => `
${this.convertChineseNumberToArabic(p1)}. `);
            secondPart = secondPart.replace(/([]+)/g, (match, p1) => `
	${this.convertChineseNumberToArabic(p1)}. `);
            return `
|\u4FEE\u6B63\u5F8C|\u4FEE\u6B63\u524D|
|---|---|
${firstPart}|
\u8AAA\u660E\uFF1A${secondPart}`;
          }
        }
        return line;
      }).join("\n");
      content = content.replace(/,(?=[a-zA-Z])/g, ", ").replace(/([a-z])([A-Z])/g, "$1 $2");
      content = content.replace(
        /\|\|\|\n\|---\|---\|\n\|(==)*(==)*([]+)(==)*(==)*/g,
        (_, equalsBeforeArticle, equalsBeforeNumber, chineseNumber, equalsAfterNumber, equalsAfterArticle) => {
          return `###### \u7B2C${chineseNumber}\u689D
|\u4FEE\u6B63\u5F8C|\u4FEE\u6B63\u524D|
|---|---|
|${equalsBeforeArticle || ""}\u7B2C${equalsBeforeNumber || ""}${chineseNumber}${equalsAfterNumber || ""}\u689D${equalsAfterArticle || ""}`;
        }
      );
      content = yamlHeader + content;
      editor.setValue(content);
    }
  }
  /**
   * 
   */
  convertChineseNumberToArabic(chineseNumber) {
    const chineseDigits = "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D";
    const chineseUnits = "\u5341\u767E\u5343\u5343\u842C\u5104\u5146";
    let result = 0;
    let unit = 1;
    let temp = 0;
    for (let i = chineseNumber.length - 1; i >= 0; i--) {
      const char = chineseNumber[i];
      const digit = chineseDigits.indexOf(char);
      if (digit !== -1) {
        temp += digit * unit;
      } else {
        const unitIndex = chineseUnits.indexOf(char);
        if (unitIndex !== -1) {
          unit = Math.pow(10, unitIndex + 1);
          result += temp * unit;
          temp = 0;
        }
      }
    }
    result += temp;
    return result;
  }
};
var TextProcessingPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Text Processing Plugin Settings" });
    let tokenInput;
    let repoInput;
    let branchInput;
    new import_obsidian.Setting(containerEl).setName("GitHub Personal Access Token").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u3002\u4F60\u53EF\u4EE5\u5728 GitHub \u7684\u8A2D\u5B9A\u4E2D\u751F\u6210\u4E00\u500B\u65B0\u7684\u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u3002").addText((text) => {
      tokenInput = text.inputEl;
      text.setPlaceholder("Enter your token");
    });
    new import_obsidian.Setting(containerEl).setName("GitHub Repository").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u5132\u5B58\u5EAB\u540D\u7A31\uFF08\u4F8B\u5982\uFF1Ausername/repo\uFF09\u3002").addText((text) => {
      repoInput = text.inputEl;
      text.setPlaceholder("Enter your repository");
      text.setValue(this.plugin.settings.repo);
    });
    new import_obsidian.Setting(containerEl).setName("GitHub Branch").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u5206\u652F\u540D\u7A31\u3002").addText((text) => {
      branchInput = text.inputEl;
      text.setPlaceholder("Enter your branch");
      text.setValue(this.plugin.settings.branch);
    });
    new import_obsidian.Setting(containerEl).addButton((button) => {
      button.setButtonText("\u5132\u5B58\u8A2D\u5B9A").setCta().onClick(async () => {
        this.plugin.settings.repo = repoInput.value;
        this.plugin.settings.branch = branchInput.value;
        await this.plugin.saveSettings();
        this.saveTokenToEnv(tokenInput.value);
        new import_obsidian.Notice("\u8A2D\u5B9A\u5DF2\u5132\u5B58");
      });
    });
  }
  saveTokenToEnv(token) {
    const vaultPath = this.plugin.app.vault.adapter.basePath;
    const envPath = path.join(vaultPath, ".env");
    const envContent = `GITHUB_TOKEN=${token}
`;
    fs.writeFileSync(envPath, envContent);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RvdGVudi9wYWNrYWdlLmpzb24iLCAibm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9jbGFzc2VzL0NsaWVudEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xpYi9wcmVsdWRlLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9mdW5jdGlvbnMvYmF0Y2hSZXF1ZXN0cy50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvZnVuY3Rpb25zL3Jhd1JlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9kZXZBc3NlcnQubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaXNPYmplY3RMaWtlLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2ludmFyaWFudC5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvbG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50TG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL0dyYXBoUUxFcnJvci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvZXJyb3Ivc3ludGF4RXJyb3IubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvZGlyZWN0aXZlTG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2tpbmRzLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9jaGFyYWN0ZXJDbGFzc2VzLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9ibG9ja1N0cmluZy5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvdG9rZW5LaW5kLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9sZXhlci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pbnNwZWN0Lm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3RhbmNlT2YubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3NvdXJjZS5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcGFyc2VyLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9wcmludFN0cmluZy5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvdmlzaXRvci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGliL2h0dHAudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGVnYWN5L2xpYi9ncmFwaHFsLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9oZWxwZXJzL2FuYWx5emVEb2N1bWVudC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvaGVscGVycy9kZWZhdWx0SnNvblNlcmlhbGl6ZXIudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGVnYWN5L2hlbHBlcnMvcnVuUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvY2xhc3Nlcy9HcmFwaFFMQ2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9mdW5jdGlvbnMvcmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvZnVuY3Rpb25zL2dxbC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsie1xuICBcIm5hbWVcIjogXCJkb3RlbnZcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMTYuNC43XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJMb2FkcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52IGZpbGVcIixcbiAgXCJtYWluXCI6IFwibGliL21haW4uanNcIixcbiAgXCJ0eXBlc1wiOiBcImxpYi9tYWluLmQudHNcIixcbiAgXCJleHBvcnRzXCI6IHtcbiAgICBcIi5cIjoge1xuICAgICAgXCJ0eXBlc1wiOiBcIi4vbGliL21haW4uZC50c1wiLFxuICAgICAgXCJyZXF1aXJlXCI6IFwiLi9saWIvbWFpbi5qc1wiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiLi9saWIvbWFpbi5qc1wiXG4gICAgfSxcbiAgICBcIi4vY29uZmlnXCI6IFwiLi9jb25maWcuanNcIixcbiAgICBcIi4vY29uZmlnLmpzXCI6IFwiLi9jb25maWcuanNcIixcbiAgICBcIi4vbGliL2Vudi1vcHRpb25zXCI6IFwiLi9saWIvZW52LW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2Vudi1vcHRpb25zLmpzXCI6IFwiLi9saWIvZW52LW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2NsaS1vcHRpb25zXCI6IFwiLi9saWIvY2xpLW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2NsaS1vcHRpb25zLmpzXCI6IFwiLi9saWIvY2xpLW9wdGlvbnMuanNcIixcbiAgICBcIi4vcGFja2FnZS5qc29uXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZHRzLWNoZWNrXCI6IFwidHNjIC0tcHJvamVjdCB0ZXN0cy90eXBlcy90c2NvbmZpZy5qc29uXCIsXG4gICAgXCJsaW50XCI6IFwic3RhbmRhcmRcIixcbiAgICBcInByZXRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biBkdHMtY2hlY2tcIixcbiAgICBcInRlc3RcIjogXCJ0YXAgcnVuIC0tYWxsb3ctZW1wdHktY292ZXJhZ2UgLS1kaXNhYmxlLWNvdmVyYWdlIC0tdGltZW91dD02MDAwMFwiLFxuICAgIFwidGVzdDpjb3ZlcmFnZVwiOiBcInRhcCBydW4gLS1zaG93LWZ1bGwtY292ZXJhZ2UgLS10aW1lb3V0PTYwMDAwIC0tY292ZXJhZ2UtcmVwb3J0PWxjb3ZcIixcbiAgICBcInByZXJlbGVhc2VcIjogXCJucG0gdGVzdFwiLFxuICAgIFwicmVsZWFzZVwiOiBcInN0YW5kYXJkLXZlcnNpb25cIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9tb3Rkb3RsYS9kb3RlbnYuZ2l0XCJcbiAgfSxcbiAgXCJmdW5kaW5nXCI6IFwiaHR0cHM6Ly9kb3RlbnZ4LmNvbVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImRvdGVudlwiLFxuICAgIFwiZW52XCIsXG4gICAgXCIuZW52XCIsXG4gICAgXCJlbnZpcm9ubWVudFwiLFxuICAgIFwidmFyaWFibGVzXCIsXG4gICAgXCJjb25maWdcIixcbiAgICBcInNldHRpbmdzXCJcbiAgXSxcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcImxpY2Vuc2VcIjogXCJCU0QtMi1DbGF1c2VcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMTguMTEuM1wiLFxuICAgIFwiZGVjYWNoZVwiOiBcIl40LjYuMlwiLFxuICAgIFwic2lub25cIjogXCJeMTQuMC4xXCIsXG4gICAgXCJzdGFuZGFyZFwiOiBcIl4xNy4wLjBcIixcbiAgICBcInN0YW5kYXJkLXZlcnNpb25cIjogXCJeOS41LjBcIixcbiAgICBcInRhcFwiOiBcIl4xOS4yLjBcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeNC44LjRcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MTJcIlxuICB9LFxuICBcImJyb3dzZXJcIjoge1xuICAgIFwiZnNcIjogZmFsc2VcbiAgfVxufVxuIiwgImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuXG5jb25zdCB2ZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvblxuXG5jb25zdCBMSU5FID0gLyg/Ol58XilcXHMqKD86ZXhwb3J0XFxzKyk/KFtcXHcuLV0rKSg/Olxccyo9XFxzKj98Olxccys/KShcXHMqJyg/OlxcXFwnfFteJ10pKid8XFxzKlwiKD86XFxcXFwifFteXCJdKSpcInxcXHMqYCg/OlxcXFxgfFteYF0pKmB8W14jXFxyXFxuXSspP1xccyooPzojLiopPyg/OiR8JCkvbWdcblxuLy8gUGFyc2Ugc3JjIGludG8gYW4gT2JqZWN0XG5mdW5jdGlvbiBwYXJzZSAoc3JjKSB7XG4gIGNvbnN0IG9iaiA9IHt9XG5cbiAgLy8gQ29udmVydCBidWZmZXIgdG8gc3RyaW5nXG4gIGxldCBsaW5lcyA9IHNyYy50b1N0cmluZygpXG5cbiAgLy8gQ29udmVydCBsaW5lIGJyZWFrcyB0byBzYW1lIGZvcm1hdFxuICBsaW5lcyA9IGxpbmVzLnJlcGxhY2UoL1xcclxcbj8vbWcsICdcXG4nKVxuXG4gIGxldCBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gTElORS5leGVjKGxpbmVzKSkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdXG5cbiAgICAvLyBEZWZhdWx0IHVuZGVmaW5lZCBvciBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgIGxldCB2YWx1ZSA9IChtYXRjaFsyXSB8fCAnJylcblxuICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIC8vIENoZWNrIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBjb25zdCBtYXliZVF1b3RlID0gdmFsdWVbMF1cblxuICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgJyQyJylcblxuICAgIC8vIEV4cGFuZCBuZXdsaW5lcyBpZiBkb3VibGUgcXVvdGVkXG4gICAgaWYgKG1heWJlUXVvdGUgPT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxyL2csICdcXHInKVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBvYmplY3RcbiAgICBvYmpba2V5XSA9IHZhbHVlXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIF9wYXJzZVZhdWx0IChvcHRpb25zKSB7XG4gIGNvbnN0IHZhdWx0UGF0aCA9IF92YXVsdFBhdGgob3B0aW9ucylcblxuICAvLyBQYXJzZSAuZW52LnZhdWx0XG4gIGNvbnN0IHJlc3VsdCA9IERvdGVudk1vZHVsZS5jb25maWdEb3RlbnYoeyBwYXRoOiB2YXVsdFBhdGggfSlcbiAgaWYgKCFyZXN1bHQucGFyc2VkKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBNSVNTSU5HX0RBVEE6IENhbm5vdCBwYXJzZSAke3ZhdWx0UGF0aH0gZm9yIGFuIHVua25vd24gcmVhc29uYClcbiAgICBlcnIuY29kZSA9ICdNSVNTSU5HX0RBVEEnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBoYW5kbGUgc2NlbmFyaW8gZm9yIGNvbW1hIHNlcGFyYXRlZCBrZXlzIC0gZm9yIHVzZSB3aXRoIGtleSByb3RhdGlvblxuICAvLyBleGFtcGxlOiBET1RFTlZfS0VZPVwiZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZCxkb3RlbnY6Ly86a2V5Xzc4OTBAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kXCJcbiAgY29uc3Qga2V5cyA9IF9kb3RlbnZLZXkob3B0aW9ucykuc3BsaXQoJywnKVxuICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXG4gIGxldCBkZWNyeXB0ZWRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZnVsbCBrZXlcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0udHJpbSgpXG5cbiAgICAgIC8vIEdldCBpbnN0cnVjdGlvbnMgZm9yIGRlY3J5cHRcbiAgICAgIGNvbnN0IGF0dHJzID0gX2luc3RydWN0aW9ucyhyZXN1bHQsIGtleSlcblxuICAgICAgLy8gRGVjcnlwdFxuICAgICAgZGVjcnlwdGVkID0gRG90ZW52TW9kdWxlLmRlY3J5cHQoYXR0cnMuY2lwaGVydGV4dCwgYXR0cnMua2V5KVxuXG4gICAgICBicmVha1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBsYXN0IGtleVxuICAgICAgaWYgKGkgKyAxID49IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgLy8gdHJ5IG5leHQga2V5XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgZGVjcnlwdGVkIC5lbnYgc3RyaW5nXG4gIHJldHVybiBEb3RlbnZNb2R1bGUucGFyc2UoZGVjcnlwdGVkKVxufVxuXG5mdW5jdGlvbiBfbG9nIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW0lORk9dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfd2FybiAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtXQVJOXSAke21lc3NhZ2V9YClcbn1cblxuZnVuY3Rpb24gX2RlYnVnIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW0RFQlVHXSAke21lc3NhZ2V9YClcbn1cblxuZnVuY3Rpb24gX2RvdGVudktleSAob3B0aW9ucykge1xuICAvLyBwcmlvcml0aXplIGRldmVsb3BlciBkaXJlY3RseSBzZXR0aW5nIG9wdGlvbnMuRE9URU5WX0tFWVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLkRPVEVOVl9LRVkgJiYgb3B0aW9ucy5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ET1RFTlZfS0VZXG4gIH1cblxuICAvLyBzZWNvbmRhcnkgaW5mcmEgYWxyZWFkeSBjb250YWlucyBhIERPVEVOVl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgaWYgKHByb2Nlc3MuZW52LkRPVEVOVl9LRVkgJiYgcHJvY2Vzcy5lbnYuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIHRvIGVtcHR5IHN0cmluZ1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gX2luc3RydWN0aW9ucyAocmVzdWx0LCBkb3RlbnZLZXkpIHtcbiAgLy8gUGFyc2UgRE9URU5WX0tFWS4gRm9ybWF0IGlzIGEgVVJJXG4gIGxldCB1cmlcbiAgdHJ5IHtcbiAgICB1cmkgPSBuZXcgVVJMKGRvdGVudktleSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1VSTCcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBXcm9uZyBmb3JtYXQuIE11c3QgYmUgaW4gdmFsaWQgdXJpIGZvcm1hdCBsaWtlIGRvdGVudjovLzprZXlfMTIzNEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PWRldmVsb3BtZW50JylcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICAvLyBHZXQgZGVjcnlwdCBrZXlcbiAgY29uc3Qga2V5ID0gdXJpLnBhc3N3b3JkXG4gIGlmICgha2V5KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3Npbmcga2V5IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBlbnZpcm9ubWVudFxuICBjb25zdCBlbnZpcm9ubWVudCA9IHVyaS5zZWFyY2hQYXJhbXMuZ2V0KCdlbnZpcm9ubWVudCcpXG4gIGlmICghZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBlbnZpcm9ubWVudCBwYXJ0JylcbiAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBHZXQgY2lwaGVydGV4dCBwYXlsb2FkXG4gIGNvbnN0IGVudmlyb25tZW50S2V5ID0gYERPVEVOVl9WQVVMVF8ke2Vudmlyb25tZW50LnRvVXBwZXJDYXNlKCl9YFxuICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVzdWx0LnBhcnNlZFtlbnZpcm9ubWVudEtleV0gLy8gRE9URU5WX1ZBVUxUX1BST0RVQ1RJT05cbiAgaWYgKCFjaXBoZXJ0ZXh0KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UOiBDYW5ub3QgbG9jYXRlIGVudmlyb25tZW50ICR7ZW52aXJvbm1lbnRLZXl9IGluIHlvdXIgLmVudi52YXVsdCBmaWxlLmApXG4gICAgZXJyLmNvZGUgPSAnTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVCdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIHJldHVybiB7IGNpcGhlcnRleHQsIGtleSB9XG59XG5cbmZ1bmN0aW9uIF92YXVsdFBhdGggKG9wdGlvbnMpIHtcbiAgbGV0IHBvc3NpYmxlVmF1bHRQYXRoID0gbnVsbFxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aCkpIHtcbiAgICAgIGZvciAoY29uc3QgZmlsZXBhdGggb2Ygb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xuICAgICAgICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gZmlsZXBhdGguZW5kc1dpdGgoJy52YXVsdCcpID8gZmlsZXBhdGggOiBgJHtmaWxlcGF0aH0udmF1bHRgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBvcHRpb25zLnBhdGguZW5kc1dpdGgoJy52YXVsdCcpID8gb3B0aW9ucy5wYXRoIDogYCR7b3B0aW9ucy5wYXRofS52YXVsdGBcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zc2libGVWYXVsdFBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYudmF1bHQnKVxuICB9XG5cbiAgaWYgKGZzLmV4aXN0c1N5bmMocG9zc2libGVWYXVsdFBhdGgpKSB7XG4gICAgcmV0dXJuIHBvc3NpYmxlVmF1bHRQYXRoXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZUhvbWUgKGVudlBhdGgpIHtcbiAgcmV0dXJuIGVudlBhdGhbMF0gPT09ICd+JyA/IHBhdGguam9pbihvcy5ob21lZGlyKCksIGVudlBhdGguc2xpY2UoMSkpIDogZW52UGF0aFxufVxuXG5mdW5jdGlvbiBfY29uZmlnVmF1bHQgKG9wdGlvbnMpIHtcbiAgX2xvZygnTG9hZGluZyBlbnYgZnJvbSBlbmNyeXB0ZWQgLmVudi52YXVsdCcpXG5cbiAgY29uc3QgcGFyc2VkID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0KG9wdGlvbnMpXG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHsgcGFyc2VkIH1cbn1cblxuZnVuY3Rpb24gY29uZmlnRG90ZW52IChvcHRpb25zKSB7XG4gIGNvbnN0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxuICBsZXQgZW5jb2RpbmcgPSAndXRmOCdcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nXG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBfZGVidWcoJ05vIGVuY29kaW5nIGlzIHNwZWNpZmllZC4gVVRGLTggaXMgdXNlZCBieSBkZWZhdWx0JylcbiAgICB9XG4gIH1cblxuICBsZXQgb3B0aW9uUGF0aHMgPSBbZG90ZW52UGF0aF0gLy8gZGVmYXVsdCwgbG9vayBmb3IgLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aCldXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvblBhdGhzID0gW10gLy8gcmVzZXQgZGVmYXVsdFxuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgb3B0aW9uUGF0aHMucHVzaChfcmVzb2x2ZUhvbWUoZmlsZXBhdGgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSBwYXJzZWQgZGF0YSBpbiBhIHRlbXBvcmFyeSBvYmplY3QgKGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gaXQpLiAgT25jZSB3ZSBoYXZlIHRoZSBmaW5hbFxuICAvLyBwYXJzZWQgZGF0YSwgd2Ugd2lsbCBjb21iaW5lIGl0IHdpdGggcHJvY2Vzcy5lbnYgKG9yIG9wdGlvbnMucHJvY2Vzc0VudiBpZiBwcm92aWRlZCkuXG4gIGxldCBsYXN0RXJyb3JcbiAgY29uc3QgcGFyc2VkQWxsID0ge31cbiAgZm9yIChjb25zdCBwYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNwZWNpZnlpbmcgYW4gZW5jb2RpbmcgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYnVmZmVyXG4gICAgICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGgsIHsgZW5jb2RpbmcgfSkpXG5cbiAgICAgIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwYXJzZWRBbGwsIHBhcnNlZCwgb3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke3BhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgICBsYXN0RXJyb3IgPSBlXG4gICAgfVxuICB9XG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWRBbGwsIG9wdGlvbnMpXG5cbiAgaWYgKGxhc3RFcnJvcikge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsLCBlcnJvcjogbGFzdEVycm9yIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGVzIHByb2Nlc3MuZW52IGZyb20gLmVudiBmaWxlXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgLy8gZmFsbGJhY2sgdG8gb3JpZ2luYWwgZG90ZW52IGlmIERPVEVOVl9LRVkgaXMgbm90IHNldFxuICBpZiAoX2RvdGVudktleShvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIGRvdGVudktleSBleGlzdHMgYnV0IC5lbnYudmF1bHQgZmlsZSBkb2VzIG5vdCBleGlzdFxuICBpZiAoIXZhdWx0UGF0aCkge1xuICAgIF93YXJuKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3ZhdWx0UGF0aH0uIERpZCB5b3UgZm9yZ2V0IHRvIGJ1aWxkIGl0P2ApXG5cbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oa2V5U3RyLnNsaWNlKC02NCksICdoZXgnKVxuICBsZXQgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCwgJ2Jhc2U2NCcpXG5cbiAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDEyKVxuICBjb25zdCBhdXRoVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtMTYpXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDEyLCAtMTYpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxuICAgIGFlc2djbS5zZXRBdXRoVGFnKGF1dGhUYWcpXG4gICAgcmV0dXJuIGAke2Flc2djbS51cGRhdGUoY2lwaGVydGV4dCl9JHthZXNnY20uZmluYWwoKX1gXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNSYW5nZSA9IGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvclxuICAgIGNvbnN0IGludmFsaWRLZXlMZW5ndGggPSBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBrZXkgbGVuZ3RoJ1xuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xuXG4gICAgaWYgKGlzUmFuZ2UgfHwgaW52YWxpZEtleUxlbmd0aCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKScpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignREVDUllQVElPTl9GQUlMRUQ6IFBsZWFzZSBjaGVjayB5b3VyIERPVEVOVl9LRVknKVxuICAgICAgZXJyLmNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGUgcHJvY2Vzcy5lbnYgd2l0aCBwYXJzZWQgdmFsdWVzXG5mdW5jdGlvbiBwb3B1bGF0ZSAocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcbiAgY29uc3Qgb3ZlcnJpZGUgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSlcblxuICBpZiAodHlwZW9mIHBhcnNlZCAhPT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ09CSkVDVF9SRVFVSVJFRDogUGxlYXNlIGNoZWNrIHRoZSBwcm9jZXNzRW52IGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBwb3B1bGF0ZScpXG4gICAgZXJyLmNvZGUgPSAnT0JKRUNUX1JFUVVJUkVEJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gU2V0IHByb2Nlc3MuZW52XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZCkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3NFbnYsIGtleSkpIHtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBEb3RlbnZNb2R1bGUgPSB7XG4gIGNvbmZpZ0RvdGVudixcbiAgX2NvbmZpZ1ZhdWx0LFxuICBfcGFyc2VWYXVsdCxcbiAgY29uZmlnLFxuICBkZWNyeXB0LFxuICBwYXJzZSxcbiAgcG9wdWxhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uZmlnRG90ZW52ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudlxubW9kdWxlLmV4cG9ydHMuX2NvbmZpZ1ZhdWx0ID0gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdFxubW9kdWxlLmV4cG9ydHMuX3BhcnNlVmF1bHQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHRcbm1vZHVsZS5leHBvcnRzLmNvbmZpZyA9IERvdGVudk1vZHVsZS5jb25maWdcbm1vZHVsZS5leHBvcnRzLmRlY3J5cHQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBEb3RlbnZNb2R1bGUucGFyc2Vcbm1vZHVsZS5leHBvcnRzLnBvcHVsYXRlID0gRG90ZW52TW9kdWxlLnBvcHVsYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gRG90ZW52TW9kdWxlXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTWVudSwgVEZpbGUsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgKiBhcyBkb3RlbnYgZnJvbSAnZG90ZW52JztcclxuaW1wb3J0IHsgcmVxdWVzdCwgZ3FsIH0gZnJvbSAnZ3JhcGhxbC1yZXF1ZXN0JztcclxuXHJcbmludGVyZmFjZSBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzIHtcclxuICAgIHJlcG86IHN0cmluZztcclxuICAgIGJyYW5jaDogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzID0ge1xyXG4gICAgcmVwbzogJ21vb250aGVyZWZvci9vYnNpZGlhbl9zeW5jX3Rlc3QnLFxyXG4gICAgYnJhbmNoOiAnbWFpbidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRQcm9jZXNzaW5nUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICAgIHNldHRpbmdzOiBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzO1xyXG5cclxuICAgIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFRleHRQcm9jZXNzaW5nUGx1Z2luU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgICAgICAvLyBcdThBM0JcdTUxOEFcdTU0N0RcdTRFRTRcdUZGMDhDb21tYW5kIFBhbGV0dGUgXHU4MjA3XHU1RkVCXHU2Mzc3XHU5Mzc1XHU5MEZEXHU1M0VGXHU0RjdGXHU3NTI4XHVGRjA5XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgICAgICAgaWQ6ICdjb252ZXJ0LWFydGljbGUtaGVhZGluZ3MnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2Q0Q1XHU4OThGXHU2NTc0XHU3NDA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY29udmVydEFydGljbGVIZWFkaW5ncygpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnY2xlYW4tdGFibGUnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2ODlEXHU2NTg3XHU1QzBEXHU3MTY3XHU4ODY4XHU2NTc0XHU3NDA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY2xlYW5UYWJsZSgpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnc3BsaXQtZG9jdW1lbnQnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2NTU5XHU2QUEyXHU4MDAzXHU5ODRDXHU2MkM2XHU1MjA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuc3BsaXREb2N1bWVudCgpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAncHVsbC12YXVsdC1mcm9tLWdpdGh1YicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdcdTVGOUUgR2l0SHViIFx1NjJDOVx1NTNENiBWYXVsdCcsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnB1bGxWYXVsdEZyb21HaXRIdWIoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3B1c2gtdmF1bHQtdG8tZ2l0aHViJyxcclxuICAgICAgICAgICAgbmFtZTogJ1x1NjNBOFx1OTAwMSBWYXVsdCBcdTUyMzAgR2l0SHViJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHVzaFZhdWx0VG9HaXRIdWIoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3N5bmMtdmF1bHQtd2l0aC1naXRodWInLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU1NDBDXHU2QjY1IFZhdWx0IFx1ODIwNyBHaXRIdWInLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5zeW5jVmF1bHRXaXRoR2l0SHViKClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gXHU1NzI4XHU3REU4XHU4RjJGXHU1NjY4XHU3Njg0XHU1M0YzXHU5Mzc1XHU5MDc4XHU1NUFFXHU0RTJEXHU2NUIwXHU1ODlFXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2VkaXRvci1tZW51JywgKG1lbnU6IE1lbnUsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFx1NTJBMFx1NTE2NVx1MzAwQ1x1OEY0OVx1NjNEQlx1Njg5RFx1NkIzRVx1NzBCQVx1NkExOVx1OTg0Q1x1MzAwRFx1OTA3OFx1OTgwNVxyXG4gICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ1x1NkNENVx1ODk4Rlx1NjU3NFx1NzQwNicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdoZWFkaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0QXJ0aWNsZUhlYWRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBcdTUyQTBcdTUxNjVcdTMwMENcdTY1NzRcdTc0MDZcdTY4OURcdTY1ODdcdTVDMERcdTcxNjdcdTg4NjhcdTMwMERcdTkwNzhcdTk4MDVcclxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdcdTY4OURcdTY1ODdcdTVDMERcdTcxNjdcdTg4NjhcdTY1NzRcdTc0MDYnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignaGVhZGluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5UYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gXHU1MkEwXHU1MTY1XHUzMDBDXHU2MkM2XHU1MjA2XHU2NTg3XHU0RUY2XHUzMDBEXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnXHU2NTU5XHU2QUEyXHU4MDAzXHU5ODRDXHU2MkM2XHU1MjA2JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ3NjaXNzb3JzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdERvY3VtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBcdTUyQTBcdTUxNjVcdTMwMENcdTU0MENcdTZCNjUgVmF1bHQgXHU4MjA3IEdpdEh1Ylx1MzAwRFx1OTA3OFx1OTgwNVxyXG4gICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ1x1NTQwQ1x1NkI2NSBWYXVsdCBcdTgyMDcgR2l0SHViJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ3N5bmMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNWYXVsdFdpdGhHaXRIdWIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFx1NTJBMFx1NTE2NVx1MzAwQ1x1NjNBOFx1OTAwMSBWYXVsdCBcdTUyMzAgR2l0SHViXHUzMDBEXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnXHU2M0E4XHU5MDAxIFZhdWx0IFx1NTIzMCBHaXRIdWInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignY2xvdWQtdXBsb2FkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoVmF1bHRUb0dpdEh1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gXHU1MkEwXHU1MTY1XHUzMDBDXHU1RjlFIEdpdEh1YiBcdTYyQzlcdTUzRDYgVmF1bHRcdTMwMERcdTkwNzhcdTk4MDVcclxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdcdTVGOUUgR2l0SHViIFx1NjJDOVx1NTNENiBWYXVsdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdjbG91ZC1kb3dubG9hZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVsbFZhdWx0RnJvbUdpdEh1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFx1NzhCQVx1NEZERCAuZW52IFx1NjU4N1x1NEVGNlx1ODhBQiAuZ2l0aWdub3JlIFx1NUZGRFx1NzU2NVxyXG4gICAgICAgIHRoaXMuZW5zdXJlRW52RmlsZUlzSWdub3JlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NzhCQVx1NEZERCAuZW52IFx1NjU4N1x1NEVGNlx1ODhBQiAuZ2l0aWdub3JlIFx1NUZGRFx1NzU2NVxyXG4gICAgICovXHJcbiAgICBlbnN1cmVFbnZGaWxlSXNJZ25vcmVkKCkge1xyXG4gICAgICAgIGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYmFzZVBhdGg7XHJcbiAgICAgICAgY29uc3QgZ2l0aWdub3JlUGF0aCA9IHBhdGguam9pbih2YXVsdFBhdGgsICcuZ2l0aWdub3JlJyk7XHJcbiAgICAgICAgY29uc3QgZW52RmlsZUVudHJ5ID0gJy5lbnZcXG4qLmluaVxcbic7XHJcblxyXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGdpdGlnbm9yZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdpdGlnbm9yZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZ2l0aWdub3JlUGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgaWYgKCFnaXRpZ25vcmVDb250ZW50LmluY2x1ZGVzKCcuZW52JykpIHtcclxuICAgICAgICAgICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKGdpdGlnbm9yZVBhdGgsICcuZW52XFxuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFnaXRpZ25vcmVDb250ZW50LmluY2x1ZGVzKCcqLmluaScpKSB7XHJcbiAgICAgICAgICAgICAgICBmcy5hcHBlbmRGaWxlU3luYyhnaXRpZ25vcmVQYXRoLCAnKi5pbmlcXG4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZ2l0aWdub3JlUGF0aCwgZW52RmlsZUVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTYzQThcdTkwMDFcdTY1NzRcdTUwMEIgVmF1bHQgXHU1MjMwIEdpdEh1YlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwdXNoVmF1bHRUb0dpdEh1YigpIHtcclxuICAgICAgICAvLyBcdTc4QkFcdThBOEQgLmVudiBcdTY1ODdcdTRFRjZcdTg4QUIgZ2l0IGlnbm9yZVxyXG4gICAgICAgIHRoaXMuZW5zdXJlRW52RmlsZUlzSWdub3JlZCgpO1xyXG5cclxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VG9rZW5Gcm9tRW52KCk7IC8vIFx1NUY5RSAuZW52IFx1NjU4N1x1NEVGNlx1NEUyRFx1OEI4MFx1NTNENlx1NEVFNFx1NzI0Q1xyXG4gICAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZSgnR2l0SHViIFx1NTAwQlx1NEVCQVx1OEEyQVx1NTU0Rlx1NEVFNFx1NzI0Q1x1NjcyQVx1OEEyRFx1N0Y2RScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXBvID0gdGhpcy5zZXR0aW5ncy5yZXBvO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IHRoaXMuc2V0dGluZ3MuYnJhbmNoO1xyXG5cclxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gIWZpbGUucGF0aC5lbmRzV2l0aCgnLmluaScpKTtcclxuICAgICAgICBjb25zdCB0b3RhbEZpbGVzID0gZmlsZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBmYWlsdXJlQ291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9ncmVzc05vdGljZSA9IG5ldyBOb3RpY2UoYFx1NjNBOFx1OTAwMVx1OTAzMlx1NUVBNjogMC8ke3RvdGFsRmlsZXN9YCwgMCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxGaWxlczsgaSArPSBiYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmaWxlcy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVXBkYXRlICR7ZmlsZVBhdGh9YDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy8ke3JlcG99L2NvbnRlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGZpbGVQYXRoKX1gO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGB0b2tlbiAke3Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFx1NzM3Mlx1NTNENlx1NjU4N1x1NEVGNlx1NzY4NCBTSEEgXHU1MDNDXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVycyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYSA9IGRhdGEuc2hhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcdThBMDhcdTdCOTdcdTY3MkNcdTU3MzBcdTY1ODdcdTRFRjZcdTc2ODQgU0hBIFx1NTAzQ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmZyb20oY29udGVudCkpLmRpZ2VzdCgnaGV4Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFx1NTk4Mlx1Njc5QyBTSEEgXHU1MDNDXHU0RTBEXHU1NDBDXHVGRjBDXHU1MjQ3XHU2M0E4XHU5MDAxXHU2NTg3XHU0RUY2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYSAhPT0gbG9jYWxTaGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBCdWZmZXIuZnJvbShjb250ZW50KS50b1N0cmluZygnYmFzZTY0JyksIC8vIFx1NEY3Rlx1NzUyOCBCdWZmZXIgXHU5MDMyXHU4ODRDIGJhc2U2NCBcdTdERThcdTc4QkNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVzaFJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB1c2hSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCBwdXNoUmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHVzaGluZyBmaWxlICR7ZmlsZVBhdGh9IHRvIEdpdEh1YjogJHtlcnJvckRhdGEubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7IC8vIFx1NTk4Mlx1Njc5Q1x1NjU4N1x1NEVGNlx1NkM5Mlx1NjcwOVx1OEI4QVx1NjZGNFx1RkYwQ1x1NEU1Rlx1OEEwOFx1NzBCQVx1NjIxMFx1NTI5RlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHVzaGluZyBmaWxlICR7ZmlsZVBhdGh9IHRvIEdpdEh1YjpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb3RpY2Uuc2V0TWVzc2FnZShgXHU2M0E4XHU5MDAxXHU5MDMyXHU1RUE2OiAke3N1Y2Nlc3NDb3VudCArIGZhaWx1cmVDb3VudH0vJHt0b3RhbEZpbGVzfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9ncmVzc05vdGljZS5oaWRlKCk7XHJcbiAgICAgICAgbmV3IE5vdGljZShgXHU2M0E4XHU5MDAxXHU1QjhDXHU2MjEwOiBcdTYyMTBcdTUyOUYgJHtzdWNjZXNzQ291bnR9IFx1NTAwQlx1NjU4N1x1NEVGNiwgXHU1OTMxXHU2NTU3ICR7ZmFpbHVyZUNvdW50fSBcdTUwMEJcdTY1ODdcdTRFRjZgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NUY5RSBHaXRIdWIgXHU2MkM5XHU1M0Q2XHU2NTc0XHU1MDBCIFZhdWx0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHB1bGxWYXVsdEZyb21HaXRIdWIoKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuRnJvbUVudigpOyAvLyBcdTVGOUUgLmVudiBcdTY1ODdcdTRFRjZcdTRFMkRcdThCODBcdTUzRDZcdTRFRTRcdTcyNENcclxuICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0dpdEh1YiBcdTUwMEJcdTRFQkFcdThBMkFcdTU1NEZcdTRFRTRcdTcyNENcdTY3MkFcdThBMkRcdTdGNkUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVwbyA9IHRoaXMuc2V0dGluZ3MucmVwbztcclxuICAgICAgICBjb25zdCBicmFuY2ggPSB0aGlzLnNldHRpbmdzLmJyYW5jaDtcclxuXHJcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9ncmFwaHFsJztcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBncWxgXHJcbiAgICAgICAgICAgIHF1ZXJ5KCRyZXBvOiBTdHJpbmchLCAkYnJhbmNoOiBTdHJpbmchKSB7XHJcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5KG5hbWU6ICRyZXBvLCBvd25lcjogXCJtb29udGhlcmVmb3JcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdChleHByZXNzaW9uOiAkYnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLiBvbiBDb21taXQge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiBvbiBCbG9iIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgO1xyXG5cclxuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XHJcbiAgICAgICAgICAgIHJlcG8sXHJcbiAgICAgICAgICAgIGJyYW5jaFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChlbmRwb2ludCwgcXVlcnksIHZhcmlhYmxlcywgaGVhZGVycyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gcmVzcG9uc2UucmVwb3NpdG9yeS5vYmplY3QudHJlZS5lbnRyaWVzLmZpbHRlcigoaXRlbTogYW55KSA9PiBpdGVtLnR5cGUgPT09ICdibG9iJyAmJiAhaXRlbS5uYW1lLmVuZHNXaXRoKCcuaW5pJykpO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbEZpbGVzID0gZmlsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcclxuICAgICAgICAgICAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzc05vdGljZSA9IG5ldyBOb3RpY2UoYFx1NjJDOVx1NTNENlx1OTAzMlx1NUVBNjogMC8ke3RvdGFsRmlsZXN9YCwgMCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwdWxsUHJvbWlzZXMgPSBmaWxlcy5tYXAoYXN5bmMgKGZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGUub2JqZWN0LnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsQ29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChmaWxlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmZyb20obG9jYWxDb250ZW50KSkuZGlnZXN0KCdoZXgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU2hhID09PSBmaWxlLm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc05vdGljZS5zZXRNZXNzYWdlKGBcdTYyQzlcdTUzRDZcdTkwMzJcdTVFQTY6ICR7c3VjY2Vzc0NvdW50ICsgZmFpbHVyZUNvdW50fS8ke3RvdGFsRmlsZXN9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoZGlyUGF0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUoZmlsZVBhdGgsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwdWxsaW5nIGZpbGUgJHtmaWxlUGF0aH0gZnJvbSBHaXRIdWI6YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb3RpY2Uuc2V0TWVzc2FnZShgXHU2MkM5XHU1M0Q2XHU5MDMyXHU1RUE2OiAke3N1Y2Nlc3NDb3VudCArIGZhaWx1cmVDb3VudH0vJHt0b3RhbEZpbGVzfWApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHB1bGxQcm9taXNlcyk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmVzc05vdGljZS5oaWRlKCk7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFx1NjJDOVx1NTNENlx1NUI4Q1x1NjIxMDogXHU2MjEwXHU1MjlGICR7c3VjY2Vzc0NvdW50fSBcdTUwMEJcdTY1ODdcdTRFRjYsIFx1NTkzMVx1NjU1NyAke2ZhaWx1cmVDb3VudH0gXHU1MDBCXHU2NTg3XHU0RUY2YCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHVsbGluZyBWYXVsdCBmcm9tIEdpdEh1YjpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFx1NUY5RSBHaXRIdWIgXHU2MkM5XHU1M0Q2IFZhdWx0IFx1NjY0Mlx1NzY3Q1x1NzUxRlx1OTMyRlx1OEFBNGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NTQwQ1x1NkI2NSBWYXVsdCBcdTgyMDcgR2l0SHViXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHN5bmNWYXVsdFdpdGhHaXRIdWIoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wdWxsVmF1bHRGcm9tR2l0SHViKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wdXNoVmF1bHRUb0dpdEh1YigpO1xyXG4gICAgICAgIG5ldyBOb3RpY2UoJ1ZhdWx0IFx1ODIwNyBHaXRIdWIgXHU1NDBDXHU2QjY1XHU1QjhDXHU2MjEwJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VG9rZW5Gcm9tRW52KCk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYmFzZVBhdGg7XHJcbiAgICAgICAgY29uc3QgZW52UGF0aCA9IHBhdGguam9pbih2YXVsdFBhdGgsICcuZW52Jyk7XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZW52UGF0aCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW52Q29uZmlnID0gZG90ZW52LnBhcnNlKGZzLnJlYWRGaWxlU3luYyhlbnZQYXRoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnZDb25maWcuR0lUSFVCX1RPS0VOIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHU1M0Q2XHU1Rjk3XHU3NTc2XHU1MjREXHU5MDc4XHU1M0Q2XHU2NTg3XHU1QjU3XHVGRjBDXHU0RTI2XHU1MjI5XHU3NTI4XHU1MEIzXHU1MTY1XHU3Njg0XHU4NjU1XHU3NDA2XHU1MUZEXHU1RjBGXHU4NjU1XHU3NDA2XHU1RjhDXHU2NkZGXHU2M0RCXHU1MzlGXHU2NTg3XHU1QjU3XHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NTZWxlY3RlZFRleHQocHJvY2Vzc29yOiAodGV4dDogc3RyaW5nKSA9PiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgICAgICBpZiAoYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRUZXh0ID0gcHJvY2Vzc29yKHNlbGVjdGVkVGV4dCk7XHJcbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHByb2Nlc3NlZFRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NUMwN1x1NjU4N1x1NEVGNlx1NEUyRFx1NzY4NFx1Njg5RFx1NkIzRVx1OEY0OVx1NjNEQlx1NjIxMFx1NkExOVx1OTg0Q1xyXG4gICAgICovXHJcbiAgICBjb252ZXJ0QXJ0aWNsZUhlYWRpbmdzKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xyXG4gICAgICAgIGlmIChhY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50ID0gY29udGVudFxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cdTdCMkNcXHMqW1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RFx1NTM0MVx1NzY3RVx1NTM0M1x1ODQyQ10rXFxzKlx1N0RFOC9nbSwgbWF0Y2ggPT4gYCMgJHttYXRjaH1gKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cdTdCMkNcXHMqW1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RFx1NTM0MVx1NzY3RVx1NTM0M1x1ODQyQ10rXFxzKlx1N0FFMC9nbSwgbWF0Y2ggPT4gYCMjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKltcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNdK1xccypcdTdCQzAvZ20sIG1hdGNoID0+IGAjIyMgJHttYXRjaH1gKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cdTdCMkNcXHMqW1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RFx1NTM0MVx1NzY3RVx1NTM0M1x1ODQyQ10rXFxzKlx1NkIzRS9nbSwgbWF0Y2ggPT4gYCMjIyMgJHttYXRjaH1gKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cdTdCMkNcXHMqW1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RFx1NTM0MVx1NzY3RVx1NTM0M1x1ODQyQ10rXFxzKlx1NzZFRS9nbSwgbWF0Y2ggPT4gYCMjIyMjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKlxcZCtcXHMqXHU2ODlEL2dtLCBtYXRjaCA9PiBgIyMjIyMjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU4Q0M3XHU2NTk5XHU0Rjg2XHU2RTkwXHVGRjFBXHU1MTY4XHU1NzBCXHU2Q0Q1XHU4OThGXHU4Q0M3XHU2NTk5XHU1RUFCL2dtLCBtYXRjaCA9PiBgIyAke21hdGNofWApO1xyXG4gICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUodXBkYXRlZENvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NjJDNlx1NTIwNlx1NjU4N1x1NEVGNlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzcGxpdERvY3VtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xyXG4gICAgICAgIGlmIChhY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBcdTUxNDhcdTU3RjdcdTg4NENcdTRFMDBcdTZCMjEgY2xlYW5Eb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbkRvY3VtZW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb2xkZXJQYXRoUHJlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGFjdGl2ZVZpZXcuZmlsZS5wYXRoKS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IGZvbGRlclBhdGhQcmUucmVwbGFjZSgvLm1kJC8sICcnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlTmFtZSA9IGFjdGl2ZVZpZXcuZmlsZS5iYXNlbmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlck5hbWUgPSBmb2xkZXJQYXRoLnNwbGl0KCcvJykucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gXHU2NUIwXHU1ODlFXHU4Q0M3XHU2NTk5XHU1OTNFXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBjb250ZW50LnNwbGl0KC8oPz1eXFxkK1xcLikvZ20pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gY29udGVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYC0tLVxcbnRhZ3M6XFxuICAtIFx1ODAwM1x1OTg0Q1xcbiAgLSBcdTk4NENcdTc2RUVcXG4gIC0gXHU2NzJBXHU1QjhDXFxuU291cnNlOlxcblJlbGF0ZTogXFxuYWxpYXNlczpcXG4tLS1cXG5gO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uID0gc2VjdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblRpdGxlID0gc2VjdGlvbi5tYXRjaCgvXlxcZCtcXC4vKT8uWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VjdGlvblRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGVhblRpdGxlID0gc2VjdGlvblRpdGxlLnJlcGxhY2UoL1xcLiQvLCAnJykudHJpbSgpOyAvLyBcdTUzQkJcdTk2NjRcdTdENTBcdTVDM0VcdTc2ODQgLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RmlsZU5hbWUgPSBgJHtmb2xkZXJQYXRofS8ke2ZvbGRlck5hbWV9LVx1N0IyQzFcdTU5MjdcdTk4NENcdTdCMkMke2NsZWFuVGl0bGV9XHU5ODRDLm1kYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ZXIgPSAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGZpbGVOYW1lcy5oYXMobmV3RmlsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlTmFtZSA9IGAke2ZvbGRlclBhdGh9LyR7Zm9sZGVyTmFtZX0tXHU3QjJDJHtjb3VudGVyfVx1NTkyN1x1OTg0Q1x1N0IyQyR7Y2xlYW5UaXRsZX1cdTk4NEMubWRgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZXMuYWRkKG5ld0ZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKG5ld0ZpbGVOYW1lLCBwcmVmaXggKyBzZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSB1cGRhdGVkQ29udGVudC5yZXBsYWNlKHNlY3Rpb24sIGAjIyAhW1ske2ZvbGRlck5hbWV9LVx1N0IyQyR7Y291bnRlciAtIDF9XHU1OTI3XHU5ODRDXHU3QjJDJHtjbGVhblRpdGxlfVx1OTg0Q11dXFxuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZSh1cGRhdGVkQ29udGVudCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzcGxpdHRpbmcgZG9jdW1lbnQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnXHU2MkM2XHU1MjA2XHU2NTg3XHU0RUY2XHU2NjQyXHU3NjdDXHU3NTFGXHU5ODVFXHU1NzhCXHU5MzJGXHU4QUE0XHVGRjBDXHU4QUNCXHU2QUEyXHU2N0U1XHU2M0E3XHU1MjM2XHU1M0YwXHU0RUU1XHU3MzcyXHU1M0Q2XHU4QTczXHU3RDMwXHU4Q0M3XHU4QTBBXHUzMDAyJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdcdTYyQzZcdTUyMDZcdTY1ODdcdTRFRjZcdTY2NDJcdTc2N0NcdTc1MUZcdTVGMTVcdTc1MjhcdTkzMkZcdThBQTRcdUZGMENcdThBQ0JcdTZBQTJcdTY3RTVcdTYzQTdcdTUyMzZcdTUzRjBcdTRFRTVcdTczNzJcdTUzRDZcdThBNzNcdTdEMzBcdThDQzdcdThBMEFcdTMwMDInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NjU3NFx1NzQwNlx1NjU4N1x1NEVGNlxyXG4gICAgICogLSBcdTU5ODJcdTY3OUNcdTRFMDBcdTg4NENcdTRFMkRcdTUzRUFcdTY3MDkxXHU1MDBCXHU2NTc4XHU1QjU3XHU4MDBDXHU2QzkyXHU2NzA5XHU1MTc2XHU0RUQ2XHU2NTg3XHU1QjU3XHVGRjBDXHU1MjJBXHU5NjY0XHU5MDE5XHU0RTAwXHU4ODRDXHJcbiAgICAgKiAtIFx1NTk4Mlx1Njc5Q1x1NEUwMFx1ODg0Q1x1NEVFNVwibi5cIlx1OTU4Qlx1NTlDQlx1RkYwQ1x1NTNCQlx1OTY2NFwibi5cIlx1NTIzMFx1NEUwQlx1NEUwMFx1NTAwQlwiXHVGRjFGXCJcdTk1OTNcdTc2ODRcdTYyNDBcdTY3MDlcdTYzREJcdTg4NENcclxuICAgICAqL1xyXG4gICAgY2xlYW5Eb2N1bWVudCgpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgICAgICBpZiAoYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcclxuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFx1NTIyQVx1OTY2NFx1NTNFQVx1NjcwOVx1NEUwMFx1NTAwQlx1NjU3OFx1NUI1N1x1NzY4NFx1ODg0Q1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9eXFxkK1xccyokL2dtLCAnJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBcdTUzQkJcdTk2NjRcdTRFRTVcIm4uXCJcdTk1OEJcdTU5Q0JcdTUyMzBcdTRFMEJcdTRFMDBcdTUwMEJcIlx1RkYxRlwiXHU5NTkzXHU3Njg0XHU2MjQwXHU2NzA5XHU2M0RCXHU4ODRDXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyhcXGQrXFwuW15cdUZGMUZdKlx1RkYxRikvZ20sIChtYXRjaCwgcDEpID0+IHAxLnJlcGxhY2UoL1xcbi9nLCAnJykpO1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oXHUzMDBDW15cdTMwMERdKlx1MzAwRCkvZ20sIChfLCBwMSkgPT4gcDEucmVwbGFjZSgvXFxuL2csICcnKSk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyhcdUZGMDhbXlx1RkYwOV0qXHVGRjA5KS9nbSwgKF8sIHAxKSA9PiBwMS5yZXBsYWNlKC9cXG4vZywgJycpKTtcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFwoW14pXSpcXCkvZ20sIG1hdGNoID0+IG1hdGNoLnJlcGxhY2UoL1xcbi9nLCAnJykpO1xyXG5cclxuICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBcdTY1NzRcdTc0MDZcdTY4OURcdTY1ODdcdTVDMERcdTcxNjdcdTg4NjhcclxuICAgIGNsZWFuVGFibGUoKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZVZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBcdTZBQTJcdTY3RTVcdTZBOTRcdTY4NDhcdTY3MDBcdTUyNERcdTk3NjJcdTY2MkZcdTU0MjZcdTY3MDlcdTRFRTUgLS0tIFx1Njg0Nlx1OEQ3N1x1NEY4Nlx1NzY4NCBZQU1MIFx1NTM0MFx1NTdERlxyXG4gICAgICAgICAgICBsZXQgeWFtbEhlYWRlciA9ICcnO1xyXG4gICAgICAgICAgICBjb25zdCB5YW1sTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9eLS0tXFxuW1xcc1xcU10qP1xcbi0tLVxcbi8pO1xyXG4gICAgICAgICAgICBpZiAoeWFtbE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICB5YW1sSGVhZGVyID0geWFtbE1hdGNoWzBdO1xyXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoeWFtbEhlYWRlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAxLiBcdTY2RkZcdTYzREJcdTVCNTdcdTdCMjZcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFwqXFwqL2csICc9PScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCAnXHVGRjA4JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpL2csICdcdUZGMDknKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88YnI+L2csICcgJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcdTAwQTBcXHRdKy9nLCAnICcpO1xyXG5cclxuICAgICAgICAgICAgLy8gMi4gXHU5MDREXHU2Qjc3XHU2QkNGXHU0RTAwXHU4ODRDXHVGRjBDXHU1M0JCXHU5NjY0XHU1M0VBXHU1NDJCXHU2NzA5fFx1MzAwMS1cdTYyMTZcdTdBN0FcdTc2N0RcdTc2ODRcdTg4NENcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+ICEvXltcXHxcXC1cXHNdKiQvLnRlc3QobGluZSkpLmpvaW4oJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgLy8gMy4gXHU3OUZCXHU5NjY0IHwgXHU1RjhDXHU3Njg0XHU1OTFBXHU1MDBCXHU3QTdBXHU3NjdEXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcfCArL2csICd8Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyA0LiBcdTkwNERcdTZCNzdcdTZCQ0ZcdTRFMDBcdTg4NENcdUZGMENcdTc1NzZcdTRFMDBcdTg4NENcdTRFRTV8XHU5NThCXHU1OUNCXHU4MDBDfFx1NUY4Q1x1OTc2Mlx1NEUwRFx1NjYyRlx1N0IyQ1x1NEUyRFx1NjU4N1x1NjU3OFx1NUI1N1x1Njg5RFx1NjY0Mlx1RkYwQ1x1NUMwN1x1OTAxOVx1NEUwMFx1ODg0Q1x1NzY4NFx1NTE2N1x1NUJCOVx1NEY3NVx1NTE2NVx1NEUwQVx1NEUwMFx1ODg0Q1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uc3RhcnRzV2l0aCgnfCcpICYmICEvXFx8XHU3QjJDW1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RFx1NTM0MVx1NzY3RVx1NTM0M1x1ODQyQ1x1NTEwNFx1NTE0Nl0rXFxzKlx1Njg5RC4qJC8udGVzdChsaW5lc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NlbGxzID0gbGluZXNbaSAtIDFdLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGxzID0gbGluZXNbaV0uc3BsaXQoJ3wnKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbnRDZWxscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENlbGxzW2pdLnRyaW0oKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2VsbHNbal0gPSAocHJldmlvdXNDZWxsc1tqXSB8fCAnJykgKyBjdXJyZW50Q2VsbHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaSAtIDFdID0gcHJldmlvdXNDZWxscy5qb2luKCd8Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGVudCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgLy8gNS4gXHU1M0JCXHU5NjY0XHU1OTFBXHU5OTE4XHU3QTdBXHU2ODNDXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyg/PCFbYS16QS1aMC05Xy4sXSlbIFx1MDBBMFxcdF0rfFsgXHUwMEEwXFx0XSsoPyFbYS16QS1aMC05Xy4sXSl8XlsgXFx0XSt8WyBcXHRdKyQvZ20sICcnKVxyXG5cclxuICAgICAgICAgICAgLy8gNi4gXHU3MEJBXHU0RUU1fFx1OTU4Qlx1OTgyRFx1NzY4NFx1NkJDRlx1NEUwMFx1ODg0Q1x1NTJBMFx1NEUwQVx1NTI0RFx1NTg5Q1x1RkYwQ1x1NEUyNlx1NTcyOFx1N0IyQ1x1NEUwOVx1NTAwQnxcdTVGOENcdTY1QjlcdTYzREJcdTg4NENcdTVGOENcdTUyQTBcdTRFMEFcIlx1OEFBQVx1NjYwRVx1RkYxQVxcblwiXHVGRjBDXHU1M0JCXHU5NjY0XHU4ODRDXHU1QzNFXHU3Njg0fFx1NTNDQVx1NTE3Nlx1NUY4Q1x1NzY4NFx1N0E3QVx1NzY3RFxyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnfCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHMuc2xpY2UoMCwgMykuam9pbignfCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kUGFydCA9IHBhcnRzLnNsaWNlKDMpLmpvaW4oJ3wnKS5yZXBsYWNlKC9cXHxcXHMqJC8sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFBhcnQgPSBzZWNvbmRQYXJ0LnJlcGxhY2UoLyhcXGQrKVxcLi9nLCBcIlxcblx0XHQkMS4gXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHU1QzA3XCJcdTRFMkRcdTY1ODdcdTY1NzhcdTVCNTdcdTMwMDFcIlx1NjZGRlx1NjNEQlx1NjIxMFx1NUMwRFx1NjFDOVx1NzY4NFwibi4gXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydCA9IHNlY29uZFBhcnQucmVwbGFjZSgvKFtcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNcdTUxMDRcdTUxNDZdKylcdTMwMDEvZywgKG1hdGNoLCBwMSkgPT4gYFxcbiR7dGhpcy5jb252ZXJ0Q2hpbmVzZU51bWJlclRvQXJhYmljKHAxKX0uIGApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHU1QzA3XCJcdUZGMDhcdTRFMkRcdTY1ODdcdTY1NzhcdTVCNTdcdUZGMDlcIlx1NjZGRlx1NjNEQlx1NjIxMFx1NUMwRFx1NjFDOVx1NzY4NFwiIG4uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydCA9IHNlY29uZFBhcnQucmVwbGFjZSgvXHVGRjA4KFtcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNcdTUxMDRcdTUxNDZdKylcdUZGMDkvZywgKG1hdGNoLCBwMSkgPT4gYFxcblx0JHt0aGlzLmNvbnZlcnRDaGluZXNlTnVtYmVyVG9BcmFiaWMocDEpfS4gYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcbnxcdTRGRUVcdTZCNjNcdTVGOEN8XHU0RkVFXHU2QjYzXHU1MjREfFxcbnwtLS18LS0tfFxcbiR7Zmlyc3RQYXJ0fXxcXG5cdThBQUFcdTY2MEVcdUZGMUEke3NlY29uZFBhcnR9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcblxyXG4gICAgICAgICAgICAvLyA3LiBcdTdBN0FcdTY4M0NcdTRGRUVcdTZCNjNcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvLCg/PVthLXpBLVpdKS9nLCBcIiwgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEgJDJcIik7XHJcblxyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXHxcdTRGRUVcdTZCNjNcdTVGOENcXHxcdTRGRUVcdTZCNjNcdTUyNERcXHxcXG5cXHwtLS1cXHwtLS1cXHxcXG5cXHwoPT0pKlx1N0IyQyg9PSkqKFtcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNcdTUxMDRcdTUxNDZdKykoPT0pKlx1Njg5RCg9PSkqL2csXHJcbiAgICAgICAgICAgIChfLCBlcXVhbHNCZWZvcmVBcnRpY2xlLCBlcXVhbHNCZWZvcmVOdW1iZXIsIGNoaW5lc2VOdW1iZXIsIGVxdWFsc0FmdGVyTnVtYmVyLCBlcXVhbHNBZnRlckFydGljbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgIyMjIyMjIFx1N0IyQyR7Y2hpbmVzZU51bWJlcn1cdTY4OURcXG58XHU0RkVFXHU2QjYzXHU1RjhDfFx1NEZFRVx1NkI2M1x1NTI0RHxcXG58LS0tfC0tLXxcXG58JHtlcXVhbHNCZWZvcmVBcnRpY2xlIHx8ICcnfVx1N0IyQyR7ZXF1YWxzQmVmb3JlTnVtYmVyIHx8ICcnfSR7Y2hpbmVzZU51bWJlcn0ke2VxdWFsc0FmdGVyTnVtYmVyIHx8ICcnfVx1Njg5RCR7ZXF1YWxzQWZ0ZXJBcnRpY2xlIHx8ICcnfWA7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gXHU1QzA3IFlBTUwgXHU1MzQwXHU1N0RGXHU1MkEwXHU1NkRFXHU1M0JCXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSB5YW1sSGVhZGVyICsgY29udGVudDtcclxuXHJcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTVDMDdcdTRFMkRcdTY1ODdcdTY1NzhcdTVCNTdcdThGNDlcdTYzREJcdTcwQkFcdTk2M0ZcdTYyQzlcdTRGMkZcdTY1NzhcdTVCNTdcclxuICAgICAqL1xyXG4gICAgY29udmVydENoaW5lc2VOdW1iZXJUb0FyYWJpYyhjaGluZXNlTnVtYmVyOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IGNoaW5lc2VEaWdpdHMgPSAnXHU5NkY2XHU0RTAwXHU0RThDXHU0RTA5XHU1NkRCXHU0RTk0XHU1MTZEXHU0RTAzXHU1MTZCXHU0RTVEJztcclxuICAgICAgICBjb25zdCBjaGluZXNlVW5pdHMgPSAnXHU1MzQxXHU3NjdFXHU1MzQzXHU1MzQzXHU4NDJDXHU1MTA0XHU1MTQ2JztcclxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgICAgICBsZXQgdW5pdCA9IDE7XHJcbiAgICAgICAgbGV0IHRlbXAgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gY2hpbmVzZU51bWJlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyID0gY2hpbmVzZU51bWJlcltpXTtcclxuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBjaGluZXNlRGlnaXRzLmluZGV4T2YoY2hhcik7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgKz0gZGlnaXQgKiB1bml0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pdEluZGV4ID0gY2hpbmVzZVVuaXRzLmluZGV4T2YoY2hhcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pdEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPSBNYXRoLnBvdygxMCwgdW5pdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRlbXAgKiB1bml0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSB0ZW1wO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFRleHRQcm9jZXNzaW5nUGx1Z2luU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBUZXh0UHJvY2Vzc2luZ1BsdWdpbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBUZXh0UHJvY2Vzc2luZ1BsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1RleHQgUHJvY2Vzc2luZyBQbHVnaW4gU2V0dGluZ3MnIH0pO1xyXG5cclxuICAgICAgICBsZXQgdG9rZW5JbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgcmVwb0lucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBicmFuY2hJbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdHaXRIdWIgUGVyc29uYWwgQWNjZXNzIFRva2VuJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1x1OEFDQlx1OEYzOFx1NTE2NVx1NEY2MFx1NzY4NCBHaXRIdWIgXHU1MDBCXHU0RUJBXHU4QTJBXHU1NTRGXHU0RUU0XHU3MjRDXHUzMDAyXHU0RjYwXHU1M0VGXHU0RUU1XHU1NzI4IEdpdEh1YiBcdTc2ODRcdThBMkRcdTVCOUFcdTRFMkRcdTc1MUZcdTYyMTBcdTRFMDBcdTUwMEJcdTY1QjBcdTc2ODRcdTUwMEJcdTRFQkFcdThBMkFcdTU1NEZcdTRFRTRcdTcyNENcdTMwMDInKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRva2VuSW5wdXQgPSB0ZXh0LmlucHV0RWw7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHRva2VuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0dpdEh1YiBSZXBvc2l0b3J5JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1x1OEFDQlx1OEYzOFx1NTE2NVx1NEY2MFx1NzY4NCBHaXRIdWIgXHU1MTMyXHU1QjU4XHU1RUFCXHU1NDBEXHU3QTMxXHVGRjA4XHU0RjhCXHU1OTgyXHVGRjFBdXNlcm5hbWUvcmVwb1x1RkYwOVx1MzAwMicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVwb0lucHV0ID0gdGV4dC5pbnB1dEVsO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciByZXBvc2l0b3J5Jyk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdHaXRIdWIgQnJhbmNoJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1x1OEFDQlx1OEYzOFx1NTE2NVx1NEY2MFx1NzY4NCBHaXRIdWIgXHU1MjA2XHU2NTJGXHU1NDBEXHU3QTMxXHUzMDAyJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XHJcbiAgICAgICAgICAgICAgICBicmFuY2hJbnB1dCA9IHRleHQuaW5wdXRFbDtcclxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgYnJhbmNoJyk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1x1NTEzMlx1NUI1OFx1OEEyRFx1NUI5QScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvID0gcmVwb0lucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2ggPSBicmFuY2hJbnB1dC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZVRva2VuVG9FbnYodG9rZW5JbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1OEEyRFx1NUI5QVx1NURGMlx1NTEzMlx1NUI1OCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlVG9rZW5Ub0Vudih0b2tlbjogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdmF1bHRQYXRoID0gKHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyIGFzIGFueSkuYmFzZVBhdGg7XHJcbiAgICAgICAgY29uc3QgZW52UGF0aCA9IHBhdGguam9pbih2YXVsdFBhdGgsICcuZW52Jyk7XHJcbiAgICAgICAgY29uc3QgZW52Q29udGVudCA9IGBHSVRIVUJfVE9LRU49JHt0b2tlbn1cXG5gO1xyXG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZW52UGF0aCwgZW52Q29udGVudCk7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB0eXBlIHsgR3JhcGhRTFJlcXVlc3RDb250ZXh0LCBHcmFwaFFMUmVzcG9uc2UgfSBmcm9tICcuLi9oZWxwZXJzL3R5cGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZXNwb25zZTogR3JhcGhRTFJlc3BvbnNlXG4gIHB1YmxpYyByZXF1ZXN0OiBHcmFwaFFMUmVxdWVzdENvbnRleHRcblxuICBjb25zdHJ1Y3RvcihyZXNwb25zZTogR3JhcGhRTFJlc3BvbnNlLCByZXF1ZXN0OiBHcmFwaFFMUmVxdWVzdENvbnRleHQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7Q2xpZW50RXJyb3IuZXh0cmFjdE1lc3NhZ2UocmVzcG9uc2UpfTogJHtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICB9KVxuICAgIH1gXG5cbiAgICBzdXBlcihtZXNzYWdlKVxuXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENsaWVudEVycm9yLnByb3RvdHlwZSlcblxuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZVxuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcblxuICAgIC8vIHRoaXMgaXMgbmVlZGVkIGFzIFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgLmNhcHR1cmVTdGFja1RyYWNlXG4gICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gYGZ1bmN0aW9uYCkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2xpZW50RXJyb3IpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZXh0cmFjdE1lc3NhZ2UocmVzcG9uc2U6IEdyYXBoUUxSZXNwb25zZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmVycm9ycz8uWzBdPy5tZXNzYWdlID8/IGBHcmFwaFFMIEVycm9yIChDb2RlOiAke1N0cmluZyhyZXNwb25zZS5zdGF0dXMpfSlgXG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IHR5cGUgUmVtb3ZlSW5kZXg8VD4gPSB7XG4gIFtLIGluIGtleW9mIFQgYXMgc3RyaW5nIGV4dGVuZHMgSyA/IG5ldmVyIDogbnVtYmVyIGV4dGVuZHMgSyA/IG5ldmVyIDogS106IFRbS11cbn1cblxuZXhwb3J0IGNvbnN0IHVwcGVyY2FzZSA9IDxTIGV4dGVuZHMgc3RyaW5nPihzdHI6IFMpOiBVcHBlcmNhc2U8Uz4gPT4gc3RyLnRvVXBwZXJDYXNlKCkgYXMgVXBwZXJjYXNlPFM+XG5cbmV4cG9ydCBjb25zdCBjYWxsT3JJZGVudGl0eSA9IDxUPih2YWx1ZTogTWF5YmVMYXp5PFQ+KSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IGBmdW5jdGlvbmAgPyAodmFsdWUgYXMgKCkgPT4gVCkoKSA6IHZhbHVlXG59XG5cbmV4cG9ydCB0eXBlIE1heWJlTGF6eTxUPiA9IFQgfCAoKCkgPT4gVClcblxuZXhwb3J0IGNvbnN0IHppcCA9IDxBLCBCPihhOiBBW10sIGI6IEJbXSk6IFtBLCBCIHwgdW5kZWZpbmVkXVtdID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pXG5cbmV4cG9ydCBjb25zdCBIZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QgPSAoaGVhZGVycz86IEhlYWRlcnNJbml0KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PiB7XG4gIGxldCBvSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgb0hlYWRlcnMgPSBIZWFkZXJzSW5zdGFuY2VUb1BsYWluT2JqZWN0KGhlYWRlcnMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKG5hbWUgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvSGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgb0hlYWRlcnMgPSBoZWFkZXJzXG4gIH1cblxuICByZXR1cm4gb0hlYWRlcnNcbn1cblxuZXhwb3J0IGNvbnN0IEhlYWRlcnNJbnN0YW5jZVRvUGxhaW5PYmplY3QgPSAoaGVhZGVyczogUmVzcG9uc2VbJ2hlYWRlcnMnXSk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPT4ge1xuICBjb25zdCBvOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgaGVhZGVycy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgb1trXSA9IHZcbiAgfSlcbiAgcmV0dXJuIG9cbn1cblxuZXhwb3J0IGNvbnN0IHRyeUNhdGNoID0gPCRSZXR1cm4sICRUaHJvdyBleHRlbmRzIEVycm9yID0gRXJyb3I+KFxuICBmbjogKCkgPT4gJFJldHVybixcbik6ICRSZXR1cm4gZXh0ZW5kcyBQcm9taXNlPGFueT4gPyBQcm9taXNlPEF3YWl0ZWQ8JFJldHVybj4gfCAkVGhyb3c+IDogJFJldHVybiB8ICRUaHJvdyA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oKSBhcyBhbnlcbiAgICBpZiAoaXNQcm9taXNlTGlrZVZhbHVlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnJvckZyb21NYXliZUVycm9yKGVycm9yKVxuICAgICAgfSkgYXMgYW55XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3JGcm9tTWF5YmVFcnJvcihlcnJvcikgYXMgYW55XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3IgYW5kIHJldHVybiBpdC4gSWYgaXQgaXMgbm90IGFuIGVycm9yIHRoYW5cbiAqIHdyYXAgaXQgaW4gb25lLCBwYXNzaW5nIHRoZSBnaXZlbiB2YWx1ZSBhcyB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVycm9yRnJvbU1heWJlRXJyb3IgPSAobWF5YmVFcnJvcjogdW5rbm93bik6IEVycm9yID0+IHtcbiAgaWYgKG1heWJlRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIG1heWJlRXJyb3JcbiAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcobWF5YmVFcnJvcikpXG59XG5cbmV4cG9ydCBjb25zdCBpc1Byb21pc2VMaWtlVmFsdWUgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBQcm9taXNlPHVua25vd24+ID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09IGBvYmplY3RgXG4gICAgJiYgdmFsdWUgIT09IG51bGxcbiAgICAmJiBgdGhlbmAgaW4gdmFsdWVcbiAgICAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gYGZ1bmN0aW9uYFxuICAgICYmIGBjYXRjaGAgaW4gdmFsdWVcbiAgICAmJiB0eXBlb2YgdmFsdWUuY2F0Y2ggPT09IGBmdW5jdGlvbmBcbiAgICAmJiBgZmluYWxseWAgaW4gdmFsdWVcbiAgICAmJiB0eXBlb2YgdmFsdWUuZmluYWxseSA9PT0gYGZ1bmN0aW9uYFxuICApXG59XG5cbmV4cG9ydCBjb25zdCBjYXNlc0V4aGF1c3RlZCA9ICh2YWx1ZTogbmV2ZXIpOiBuZXZlciA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNhc2U6ICR7U3RyaW5nKHZhbHVlKX1gKVxufVxuXG5leHBvcnQgY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gYG9iamVjdGAgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbmV4cG9ydCBjb25zdCBlbnRyaWVzID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihvYmo6IFQpID0+IE9iamVjdC5lbnRyaWVzKG9iaikgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW11cblxuZXhwb3J0IGNvbnN0IHZhbHVlcyA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KG9iajogVCk6IFRba2V5b2YgVF1bXSA9PiBPYmplY3QudmFsdWVzKG9iaikgYXMgVFtrZXlvZiBUXVtdXG5cbi8vIGRwcmludC1pZ25vcmVcbmV4cG9ydCB0eXBlIEV4YWN0PCRWYWx1ZSwgJENvbnN0cmFpbnQ+ID1cbiAgKFxuICAgICRWYWx1ZSBleHRlbmRzIHVua25vd24gID8gJENvbnN0cmFpbnQgZXh0ZW5kcyAkVmFsdWUgICA/ICB7fSBleHRlbmRzICRWYWx1ZSAgICA/ICAkQ29uc3RyYWludCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgW0sgaW4ga2V5b2YgJFZhbHVlXTogRXhhY3Q8JFZhbHVlW0tdLCAkQ29uc3RyYWludFtLXT4gfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRDb25zdHJhaW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldmVyXG4gIClcbiAgfCAoJFZhbHVlIGV4dGVuZHMgTmFycm93YWJsZSA/ICRWYWx1ZSA6IG5ldmVyKVxuXG4vLyBkcHJpbnQtaWdub3JlXG4vLyBleHBvcnQgdHlwZSBFeGFjdE9iamVjdE5vbkVtcHR5PCRWYWx1ZSwgJENvbnN0cmFpbnQ+ID1cbi8vICAgKFxuLy8gICAgICRWYWx1ZSBleHRlbmRzIHVua25vd24gID8gJENvbnN0cmFpbnQgZXh0ZW5kcyAkVmFsdWUgICA/ICBrZXlvZiAkVmFsdWUgZXh0ZW5kcyBuZXZlciAgPyAoeyAnVHlwZVNjcmlwdCBFcnJvcjogWW91IG11c3Qgc3VwcGx5IGF0IGxlYXN0IG9uZSBrZXkuJzogdHJ1ZSB9ICYgJENvbnN0cmFpbnQpICA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgW0sgaW4ga2V5b2YgJFZhbHVlXTogRXhhY3Q8JFZhbHVlW0tdLCAkQ29uc3RyYWludFtLXT4gfSA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRDb25zdHJhaW50IDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldmVyXG4vLyAgIClcbi8vICAgfCAoJFZhbHVlIGV4dGVuZHMgTmFycm93YWJsZSA/ICRWYWx1ZSA6IG5ldmVyKVxuXG5leHBvcnQgdHlwZSBOYXJyb3dhYmxlID0gc3RyaW5nIHwgbnVtYmVyIHwgYmlnaW50IHwgYm9vbGVhbiB8IFtdXG5cbmV4cG9ydCB0eXBlIExldHRlciA9IExldHRlckxvd2VyIHwgTGV0dGVyVXBwZXJcblxuZXhwb3J0IHR5cGUgRGlnaXQgPSAnMCcgfCAnMScgfCAnMicgfCAnMycgfCAnNCcgfCAnNScgfCAnNicgfCAnNycgfCAnOCcgfCAnOSdcblxuZXhwb3J0IHR5cGUgTGV0dGVyTG93ZXIgPVxuICB8ICdhJ1xuICB8ICdiJ1xuICB8ICdjJ1xuICB8ICdkJ1xuICB8ICdlJ1xuICB8ICdmJ1xuICB8ICdnJ1xuICB8ICdoJ1xuICB8ICdpJ1xuICB8ICdqJ1xuICB8ICdrJ1xuICB8ICdsJ1xuICB8ICdtJ1xuICB8ICduJ1xuICB8ICdvJ1xuICB8ICdwJ1xuICB8ICdxJ1xuICB8ICdyJ1xuICB8ICdzJ1xuICB8ICd0J1xuICB8ICd1J1xuICB8ICd2J1xuICB8ICd3J1xuICB8ICd4J1xuICB8ICd5J1xuICB8ICd6J1xuZXhwb3J0IHR5cGUgTGV0dGVyVXBwZXIgPVxuICB8ICdBJ1xuICB8ICdCJ1xuICB8ICdDJ1xuICB8ICdEJ1xuICB8ICdFJ1xuICB8ICdGJ1xuICB8ICdHJ1xuICB8ICdIJ1xuICB8ICdJJ1xuICB8ICdKJ1xuICB8ICdLJ1xuICB8ICdMJ1xuICB8ICdNJ1xuICB8ICdOJ1xuICB8ICdPJ1xuICB8ICdQJ1xuICB8ICdRJ1xuICB8ICdSJ1xuICB8ICdTJ1xuICB8ICdUJ1xuICB8ICdVJ1xuICB8ICdWJ1xuICB8ICdXJ1xuICB8ICdYJ1xuICB8ICdZJ1xuICB8ICdaJ1xuXG5leHBvcnQgdHlwZSBTdHJpbmdOb25FbXB0eSA9IGAke0xldHRlcn0ke3N0cmluZ31gXG5cbmV4cG9ydCB0eXBlIE1heWJlTGlzdDxUPiA9IFQgfCBUW11cblxuZXhwb3J0IHR5cGUgTm90RW1wdHlPYmplY3Q8VD4gPSBrZXlvZiBUIGV4dGVuZHMgbmV2ZXIgPyBuZXZlciA6IFRcblxuZXhwb3J0IHR5cGUgVmFsdWVzPFQ+ID0gVFtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBHZXRLZXlPcjxULCBLZXksIE9yPiA9IEtleSBleHRlbmRzIGtleW9mIFQgPyBUW0tleV0gOiBPclxuXG5leHBvcnQgdHlwZSBBczxULCBVPiA9IFUgZXh0ZW5kcyBUID8gVSA6IG5ldmVyXG5cbmV4cG9ydCB0eXBlIFVuaW9uVG9JbnRlcnNlY3Rpb248VT4gPSAoVSBleHRlbmRzIGFueSA/IChrOiBVKSA9PiB2b2lkIDogbmV2ZXIpIGV4dGVuZHMgKChrOiBpbmZlciBJKSA9PiB2b2lkKSA/IEkgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBMYXN0T2Y8VD4gPSBVbmlvblRvSW50ZXJzZWN0aW9uPFQgZXh0ZW5kcyBhbnkgPyAoKSA9PiBUIDogbmV2ZXI+IGV4dGVuZHMgKCkgPT4gaW5mZXIgUiA/IFIgOiBuZXZlclxuXG4vLyBUUzQuMCtcbmV4cG9ydCB0eXBlIFB1c2g8VCBleHRlbmRzIGFueVtdLCBWPiA9IFsuLi5ULCBWXVxuXG4vLyBUUzQuMStcbmV4cG9ydCB0eXBlIFVuaW9uVG9UdXBsZTxULCBMID0gTGFzdE9mPFQ+LCBOID0gW1RdIGV4dGVuZHMgW25ldmVyXSA/IHRydWUgOiBmYWxzZT4gPSB0cnVlIGV4dGVuZHMgTiA/IFtdXG4gIDogUHVzaDxVbmlvblRvVHVwbGU8RXhjbHVkZTxULCBMPj4sIEw+XG5cbmV4cG9ydCB0eXBlIENvdW50S2V5czxUPiA9IGtleW9mIFQgZXh0ZW5kcyBuZXZlciA/IDAgOiBVbmlvblRvVHVwbGU8a2V5b2YgVD5bJ2xlbmd0aCddXG5leHBvcnQgdHlwZSBJc011bHRpcGxlS2V5czxUPiA9IElzTXVsdGlwbGU8Q291bnRLZXlzPFQ+PlxuZXhwb3J0IHR5cGUgSXNNdWx0aXBsZTxUPiA9IFQgZXh0ZW5kcyAwID8gZmFsc2UgOiBUIGV4dGVuZHMgMSA/IGZhbHNlIDogdHJ1ZVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlTnVsbDxUPiA9IEV4Y2x1ZGU8VCwgbnVsbD5cblxuZXhwb3J0IGNvbnN0IG1hcFZhbHVlcyA9IDxcbiAgJE9iaiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICRGbiBleHRlbmRzICh2YWx1ZTogJE9ialtrZXlvZiAkT2JqXSwga2V5OiBrZXlvZiAkT2JqKSA9PiBhbnksXG4+KFxuICBvYmplY3Q6ICRPYmosXG4gIGZuOiAkRm4sXG4pOiBSZWNvcmQ8a2V5b2YgJE9iaiwgUmV0dXJuVHlwZTwkRm4+PiA9PiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob2JqZWN0KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgcmV0dXJuIFtrZXksIGZuKHZhbHVlLCBrZXkpXVxuICAgIH0pLFxuICApIGFzIFJlY29yZDxrZXlvZiAkT2JqLCBSZXR1cm5UeXBlPCRGbj4+XG59XG5cbmV4cG9ydCB0eXBlIFNldFByb3BlcnR5PCRPYmogZXh0ZW5kcyBvYmplY3QsICRQcm9wIGV4dGVuZHMga2V5b2YgJE9iaiwgJFR5cGUgZXh0ZW5kcyAkT2JqWyRQcm9wXT4gPVxuICAmIE9taXQ8JE9iaiwgJFByb3A+XG4gICYgeyBbXyBpbiAkUHJvcF06ICRUeXBlIH1cblxuZXhwb3J0IGNvbnN0IGxvd2VyQ2FzZUZpcnN0TGV0dGVyID0gKHM6IHN0cmluZykgPT4ge1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHMuc2xpY2UoMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHY6IHVua25vd24pOiBhc3NlcnRzIHYgaXMgdW5rbm93bltdIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5LiBHb3Q6ICR7U3RyaW5nKHYpfWApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodjogdW5rbm93bik6IGFzc2VydHMgdiBpcyBvYmplY3Qge1xuICBpZiAodiA9PT0gbnVsbCB8fCB0eXBlb2YgdiAhPT0gYG9iamVjdGApIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgb2JqZWN0LiBHb3Q6ICR7U3RyaW5nKHYpfWApXG59XG5cbmV4cG9ydCB0eXBlIFN0cmluZ0tleW9mPFQ+ID0ga2V5b2YgVCAmIHN0cmluZ1xuXG5leHBvcnQgdHlwZSBNYXliZVByb21pc2U8VD4gPSBUIHwgUHJvbWlzZTxUPlxuXG5leHBvcnQgY29uc3QgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gKHN0cmluZzogc3RyaW5nKSA9PiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSlcblxuZXhwb3J0IHR5cGUgU29tZUFzeW5jRnVuY3Rpb24gPSAoLi4uYXJnczogdW5rbm93bltdKSA9PiBQcm9taXNlPHVua25vd24+XG5cbmV4cG9ydCB0eXBlIFNvbWVNYXliZUFzeW5jRnVuY3Rpb24gPSAoLi4uYXJnczogdW5rbm93bltdKSA9PiBNYXliZVByb21pc2U8dW5rbm93bj5cblxuZXhwb3J0IHR5cGUgRGVmZXJyZWQ8VD4gPSB7XG4gIHByb21pc2U6IFByb21pc2U8VD5cbiAgaXNSZXNvbHZlZDogKCkgPT4gYm9vbGVhblxuICByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZURlZmVycmVkID0gPCRUPihvcHRpb25zPzogeyBzdHJpY3Q/OiBib29sZWFuIH0pOiBEZWZlcnJlZDwkVD4gPT4ge1xuICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlXG4gIGxldCByZXNvbHZlOiAodmFsdWU6ICRUKSA9PiB2b2lkXG4gIGxldCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZFxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTwkVD4oKCRyZXNvbHZlLCAkcmVqZWN0KSA9PiB7XG4gICAgcmVzb2x2ZSA9ICRyZXNvbHZlXG4gICAgcmVqZWN0ID0gJHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICBpc1Jlc29sdmVkOiAoKSA9PiBpc1Jlc29sdmVkLFxuICAgIHJlc29sdmU6ICh2YWx1ZSkgPT4ge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWVcbiAgICAgIGlmIChvcHRpb25zPy5zdHJpY3QgJiYgaXNSZXNvbHZlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIGlzIGFscmVhZHkgcmVzb2x2ZWQuIEF0dGVtcHRlZCB0byByZXNvbHZlIHdpdGg6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgICB9XG4gICAgICByZXNvbHZlKHZhbHVlKVxuICAgIH0sXG4gICAgcmVqZWN0OiAoZXJyb3IpID0+IHJlamVjdChlcnJvciksXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudltgREVCVUdgXSkge1xuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnU3ViID0gKC4uLmFyZ3M6IGFueVtdKSA9PiAoLi4uc3ViQXJnczogYW55W10pID0+IHtcbiAgZGVidWcoLi4uYXJncywgLi4uc3ViQXJncylcbn1cblxuZXhwb3J0IHR5cGUgUGx1c09uZVVwVG9UZW48biBleHRlbmRzIG51bWJlcj4gPSBuIGV4dGVuZHMgMCA/IDFcbiAgOiBuIGV4dGVuZHMgMSA/IDJcbiAgOiBuIGV4dGVuZHMgMiA/IDNcbiAgOiBuIGV4dGVuZHMgMyA/IDRcbiAgOiBuIGV4dGVuZHMgNCA/IDVcbiAgOiBuIGV4dGVuZHMgNSA/IDZcbiAgOiBuIGV4dGVuZHMgNiA/IDdcbiAgOiBuIGV4dGVuZHMgNyA/IDhcbiAgOiBuIGV4dGVuZHMgOCA/IDlcbiAgOiBuIGV4dGVuZHMgOSA/IDEwXG4gIDogbmV2ZXJcblxuZXhwb3J0IHR5cGUgTWludXNPbmVVcFRvVGVuPG4gZXh0ZW5kcyBudW1iZXI+ID0gbiBleHRlbmRzIDEwID8gOVxuICA6IG4gZXh0ZW5kcyA5ID8gOFxuICA6IG4gZXh0ZW5kcyA4ID8gN1xuICA6IG4gZXh0ZW5kcyA3ID8gNlxuICA6IG4gZXh0ZW5kcyA2ID8gNVxuICA6IG4gZXh0ZW5kcyA1ID8gNFxuICA6IG4gZXh0ZW5kcyA0ID8gM1xuICA6IG4gZXh0ZW5kcyAzID8gMlxuICA6IG4gZXh0ZW5kcyAyID8gMVxuICA6IG4gZXh0ZW5kcyAxID8gMFxuICA6IG5ldmVyXG5cbmV4cG9ydCB0eXBlIGZpbmRJbmRleEZvclZhbHVlPHZhbHVlLCBsaXN0IGV4dGVuZHMgcmVhZG9ubHkgW2FueSwgLi4uYW55W11dPiA9IGZpbmRJbmRleEZvclZhbHVlXzx2YWx1ZSwgbGlzdCwgMD5cbnR5cGUgZmluZEluZGV4Rm9yVmFsdWVfPHZhbHVlLCBsaXN0IGV4dGVuZHMgcmVhZG9ubHkgW2FueSwgLi4uYW55W11dLCBpIGV4dGVuZHMgbnVtYmVyPiA9IHZhbHVlIGV4dGVuZHMgbGlzdFtpXSA/IGlcbiAgOiBmaW5kSW5kZXhGb3JWYWx1ZV88dmFsdWUsIGxpc3QsIFBsdXNPbmVVcFRvVGVuPGk+PlxuXG5leHBvcnQgdHlwZSBGaW5kVmFsdWVBZnRlcjx2YWx1ZSwgbGlzdCBleHRlbmRzIHJlYWRvbmx5IFthbnksIC4uLmFueVtdXT4gPVxuICBsaXN0W1BsdXNPbmVVcFRvVGVuPGZpbmRJbmRleEZvclZhbHVlPHZhbHVlLCBsaXN0Pj5dXG5cbmV4cG9ydCB0eXBlIFZhbHVlT3I8dmFsdWUsIG9yVmFsdWU+ID0gdmFsdWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBvclZhbHVlIDogdmFsdWVcblxuZXhwb3J0IHR5cGUgRmluZFZhbHVlQWZ0ZXJPcjx2YWx1ZSwgbGlzdCBleHRlbmRzIHJlYWRvbmx5IFthbnksIC4uLmFueVtdXSwgb3JWYWx1ZT4gPSBWYWx1ZU9yPFxuICBsaXN0W1BsdXNPbmVVcFRvVGVuPGZpbmRJbmRleEZvclZhbHVlPHZhbHVlLCBsaXN0Pj5dLFxuICBvclZhbHVlXG4+XG5cbmV4cG9ydCB0eXBlIEdldExhc3RWYWx1ZTxUIGV4dGVuZHMgcmVhZG9ubHkgW2FueSwgLi4uYW55W11dPiA9IFRbTWludXNPbmVVcFRvVGVuPFRbJ2xlbmd0aCddPl1cblxuZXhwb3J0IHR5cGUgSXNMYXN0VmFsdWU8dmFsdWUsIGxpc3QgZXh0ZW5kcyByZWFkb25seSBbYW55LCAuLi5hbnlbXV0+ID0gdmFsdWUgZXh0ZW5kcyBHZXRMYXN0VmFsdWU8bGlzdD4gPyB0cnVlIDogZmFsc2VcblxuZXhwb3J0IHR5cGUgSW5jbHVkZTxULCBVPiA9IFQgZXh0ZW5kcyBVID8gVCA6IG5ldmVyXG5cbmV4cG9ydCBjb25zdCBwYXJ0aXRpb25FcnJvcnMgPSA8VD4oYXJyYXk6IFRbXSk6IFtFeGNsdWRlPFQsIEVycm9yPltdLCBJbmNsdWRlPFQsIEVycm9yPltdXSA9PiB7XG4gIGNvbnN0IGVycm9yczogSW5jbHVkZTxULCBFcnJvcj5bXSA9IFtdXG4gIGNvbnN0IHZhbHVlczogRXhjbHVkZTxULCBFcnJvcj5bXSA9IFtdXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVycm9ycy5wdXNoKGl0ZW0gYXMgYW55KVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChpdGVtIGFzIGFueSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt2YWx1ZXMsIGVycm9yc11cbn1cbiIsICJpbXBvcnQgeyBHcmFwaFFMQ2xpZW50IH0gZnJvbSAnLi4vY2xhc3Nlcy9HcmFwaFFMQ2xpZW50LmpzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0RG9jdW1lbnQsIFZhcmlhYmxlcyB9IGZyb20gJy4uL2hlbHBlcnMvdHlwZXMuanMnXG5cbmV4cG9ydCB0eXBlIEJhdGNoUmVxdWVzdERvY3VtZW50PFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+ID0ge1xuICBkb2N1bWVudDogUmVxdWVzdERvY3VtZW50XG4gIHZhcmlhYmxlcz86IFZcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaFJlcXVlc3RzT3B0aW9uczxWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPiB7XG4gIGRvY3VtZW50czogQmF0Y2hSZXF1ZXN0RG9jdW1lbnQ8Vj5bXVxuICByZXF1ZXN0SGVhZGVycz86IEhlYWRlcnNJbml0XG4gIHNpZ25hbD86IFJlcXVlc3RJbml0WydzaWduYWwnXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoUmVxdWVzdHNFeHRlbmRlZE9wdGlvbnM8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4gZXh0ZW5kcyBCYXRjaFJlcXVlc3RzT3B0aW9uczxWPiB7XG4gIHVybDogc3RyaW5nXG59XG5cbi8qKlxuICogU2VuZCBhIGJhdGNoIG9mIEdyYXBoUUwgRG9jdW1lbnQgdG8gdGhlIEdyYXBoUUwgc2VydmVyIGZvciBleGVjdXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogLy8gWW91IGNhbiBwYXNzIGEgcmF3IHN0cmluZ1xuICpcbiAqIGF3YWl0IGJhdGNoUmVxdWVzdHMoJ2h0dHBzOi8vZm9vLmJhci9ncmFwaHFsJywgW1xuICoge1xuICogIHF1ZXJ5OiBgXG4gKiAgIHtcbiAqICAgICBxdWVyeSB7XG4gKiAgICAgICB1c2Vyc1xuICogICAgIH1cbiAqICAgfWBcbiAqIH0sXG4gKiB7XG4gKiAgIHF1ZXJ5OiBgXG4gKiAgIHtcbiAqICAgICBxdWVyeSB7XG4gKiAgICAgICB1c2Vyc1xuICogICAgIH1cbiAqICAgfWBcbiAqIH1dKVxuICpcbiAqIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGEgR3JhcGhRTCBEb2N1bWVudE5vZGUgYXMgcXVlcnkuIENvbnZlbmllbnQgaWYgeW91XG4gKiAvLyBhcmUgdXNpbmcgZ3JhcGhxbC10YWcgcGFja2FnZS5cbiAqXG4gKiBpbXBvcnQgZ3FsIGZyb20gJ2dyYXBocWwtdGFnJ1xuICpcbiAqIGF3YWl0IGJhdGNoUmVxdWVzdHMoJ2h0dHBzOi8vZm9vLmJhci9ncmFwaHFsJywgW3sgcXVlcnk6IGdxbGAuLi5gIH1dKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXRjaFJlcXVlc3RzOiBCYXRjaFJlcXVlc3RzID0gYXN5bmMgKC4uLmFyZ3M6IEJhdGNoUmVxdWVzdHNBcmdzKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHBhcnNlQmF0Y2hSZXF1ZXN0c0FyZ3NFeHRlbmRlZChhcmdzKVxuICBjb25zdCBjbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudChwYXJhbXMudXJsKVxuICByZXR1cm4gY2xpZW50LmJhdGNoUmVxdWVzdHMocGFyYW1zKVxufVxuXG50eXBlIEJhdGNoUmVxdWVzdHNBcmdzID1cbiAgfCBbdXJsOiBzdHJpbmcsIGRvY3VtZW50czogQmF0Y2hSZXF1ZXN0RG9jdW1lbnRbXSwgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdF1cbiAgfCBbb3B0aW9uczogQmF0Y2hSZXF1ZXN0c0V4dGVuZGVkT3B0aW9uc11cblxuZXhwb3J0IGNvbnN0IHBhcnNlQmF0Y2hSZXF1ZXN0c0FyZ3NFeHRlbmRlZCA9IChhcmdzOiBCYXRjaFJlcXVlc3RzQXJncyk6IEJhdGNoUmVxdWVzdHNFeHRlbmRlZE9wdGlvbnMgPT4ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYXJnc1swXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IGFyZ3NbMF0sXG4gICAgICBkb2N1bWVudHM6IGFyZ3NbMV0sXG4gICAgICByZXF1ZXN0SGVhZGVyczogYXJnc1syXSxcbiAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgIH1cbiAgfVxufVxuXG4vLyBkcHJpbnQtaWdub3JlXG5pbnRlcmZhY2UgQmF0Y2hSZXF1ZXN0cyB7XG4gIDxUIGV4dGVuZHMgQmF0Y2hSZXN1bHQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KHVybDogc3RyaW5nLCBkb2N1bWVudHM6IEJhdGNoUmVxdWVzdERvY3VtZW50PFY+W10sIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXQpOiBQcm9taXNlPFQ+XG4gIDxUIGV4dGVuZHMgQmF0Y2hSZXN1bHQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KG9wdGlvbnM6IEJhdGNoUmVxdWVzdHNFeHRlbmRlZE9wdGlvbnM8Vj4pOiBQcm9taXNlPFQ+XG59XG5cbmV4cG9ydCB0eXBlIEJhdGNoUmVzdWx0ID0gW1Jlc3VsdCwgLi4uUmVzdWx0W11dXG5cbmludGVyZmFjZSBSZXN1bHQ8RGF0YSBleHRlbmRzIG9iamVjdCA9IG9iamVjdD4ge1xuICBkYXRhOiBEYXRhXG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoUmVxdWVzdEFyZ3MgPSA8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gIGRvY3VtZW50c09yT3B0aW9uczogQmF0Y2hSZXF1ZXN0RG9jdW1lbnQ8Vj5bXSB8IEJhdGNoUmVxdWVzdHNPcHRpb25zPFY+LFxuICByZXF1ZXN0SGVhZGVycz86IEhlYWRlcnNJbml0LFxuKTogQmF0Y2hSZXF1ZXN0c09wdGlvbnM8Vj4gPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmV0dXJuIChkb2N1bWVudHNPck9wdGlvbnMgYXMgQmF0Y2hSZXF1ZXN0c09wdGlvbnM8Vj4pLmRvY3VtZW50c1xuICAgID8gKGRvY3VtZW50c09yT3B0aW9ucyBhcyBCYXRjaFJlcXVlc3RzT3B0aW9uczxWPilcbiAgICA6IHtcbiAgICAgIGRvY3VtZW50czogZG9jdW1lbnRzT3JPcHRpb25zIGFzIEJhdGNoUmVxdWVzdERvY3VtZW50PFY+W10sXG4gICAgICByZXF1ZXN0SGVhZGVyczogcmVxdWVzdEhlYWRlcnMsXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgR3JhcGhRTENsaWVudCB9IGZyb20gJy4uL2NsYXNzZXMvR3JhcGhRTENsaWVudC5qcydcbmltcG9ydCB0eXBlIHtcbiAgR3JhcGhRTENsaWVudFJlc3BvbnNlLFxuICBSYXdSZXF1ZXN0T3B0aW9ucyxcbiAgVmFyaWFibGVzLFxuICBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3MsXG59IGZyb20gJy4uL2hlbHBlcnMvdHlwZXMuanMnXG5cbi8qKlxuICogU2VuZCBhIEdyYXBoUUwgUXVlcnkgdG8gdGhlIEdyYXBoUUwgc2VydmVyIGZvciBleGVjdXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCByYXdSZXF1ZXN0OiBSYXdSZXF1ZXN0ID0gYXN5bmMgPFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXM+KFxuICAuLi5hcmdzOiBSYXdSZXF1ZXN0QXJnczxWPlxuKTogUHJvbWlzZTxHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD4+ID0+IHtcbiAgY29uc3QgW3VybE9yT3B0aW9ucywgcXVlcnksIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzXSA9IGFyZ3NcbiAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBwYXJzZVJhd1JlcXVlc3RFeHRlbmRlZEFyZ3M8Vj4odXJsT3JPcHRpb25zLCBxdWVyeSwgLi4udmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnMpXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KHJlcXVlc3RPcHRpb25zLnVybClcbiAgcmV0dXJuIGNsaWVudC5yYXdSZXF1ZXN0PFQsIFY+KHtcbiAgICAuLi5yZXF1ZXN0T3B0aW9ucyxcbiAgfSlcbn1cblxuLy8gZHByaW50LWlnbm9yZVxuaW50ZXJmYWNlIFJhd1JlcXVlc3Qge1xuICA8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4odXJsOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcsIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj4pOiBQcm9taXNlPEdyYXBoUUxDbGllbnRSZXNwb25zZTxUPj5cbiAgPFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KG9wdGlvbnM6IFJhd1JlcXVlc3RFeHRlbmRlZE9wdGlvbnM8Vj4pOiBQcm9taXNlPEdyYXBoUUxDbGllbnRSZXNwb25zZTxUPj5cbn1cblxuLy8gZHByaW50LWlnbm9yZVxudHlwZSBSYXdSZXF1ZXN0QXJnczxWIGV4dGVuZHMgVmFyaWFibGVzPiA9IFxuICB8IFtvcHRpb25zOiBSYXdSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+LCBxdWVyeT86IHN0cmluZywgLi4udmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnM6IFZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzQXJnczxWPl1cbiAgfCBbdXJsOiBzdHJpbmcsICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk/OiBzdHJpbmcsIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj5dXG5cbmV4cG9ydCBjb25zdCBwYXJzZVJhd1JlcXVlc3RFeHRlbmRlZEFyZ3MgPSA8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gIHVybE9yT3B0aW9uczogc3RyaW5nIHwgUmF3UmVxdWVzdEV4dGVuZGVkT3B0aW9uczxWPixcbiAgcXVlcnk/OiBzdHJpbmcsXG4gIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj5cbik6IFJhd1JlcXVlc3RFeHRlbmRlZE9wdGlvbnM8Vj4gPT4ge1xuICBjb25zdCBbdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVyc10gPSB2YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc1xuICByZXR1cm4gdHlwZW9mIHVybE9yT3B0aW9ucyA9PT0gYHN0cmluZ2BcbiAgICA/ICh7XG4gICAgICB1cmw6IHVybE9yT3B0aW9ucyxcbiAgICAgIHF1ZXJ5OiBxdWVyeSBhcyBzdHJpbmcsXG4gICAgICB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVycyxcbiAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgIH0gYXMgdW5rbm93biBhcyBSYXdSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+KVxuICAgIDogdXJsT3JPcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIFJhd1JlcXVlc3RFeHRlbmRlZE9wdGlvbnM8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4gPSB7XG4gIHVybDogc3RyaW5nXG59ICYgUmF3UmVxdWVzdE9wdGlvbnM8Vj5cblxuZXhwb3J0IGNvbnN0IHBhcnNlUmF3UmVxdWVzdEFyZ3MgPSA8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gIHF1ZXJ5T3JPcHRpb25zOiBzdHJpbmcgfCBSYXdSZXF1ZXN0T3B0aW9uczxWPixcbiAgdmFyaWFibGVzPzogVixcbiAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdCxcbik6IFJhd1JlcXVlc3RPcHRpb25zPFY+ID0+IHtcbiAgcmV0dXJuIChxdWVyeU9yT3B0aW9ucyBhcyBSYXdSZXF1ZXN0T3B0aW9uczxWPikucXVlcnlcbiAgICA/IChxdWVyeU9yT3B0aW9ucyBhcyBSYXdSZXF1ZXN0T3B0aW9uczxWPilcbiAgICA6ICh7XG4gICAgICBxdWVyeTogcXVlcnlPck9wdGlvbnMgYXMgc3RyaW5nLFxuICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVyczogcmVxdWVzdEhlYWRlcnMsXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9IGFzIHVua25vd24gYXMgUmF3UmVxdWVzdE9wdGlvbnM8Vj4pXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGRldkFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgY29uc3QgYm9vbGVhbkNvbmRpdGlvbiA9IEJvb2xlYW4oY29uZGl0aW9uKTtcblxuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbiIsICIvKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3RcbiAqIGBudWxsYCBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBjb25zdCBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pO1xuXG4gIGlmICghYm9vbGVhbkNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UgOiAnVW5leHBlY3RlZCBpbnZhcmlhbnQgdHJpZ2dlcmVkLicsXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJy4uL2pzdXRpbHMvaW52YXJpYW50Lm1qcyc7XG5jb25zdCBMaW5lUmVnRXhwID0gL1xcclxcbnxbXFxuXFxyXS9nO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSBTb3VyY2UuXG4gKi9cblxuLyoqXG4gKiBUYWtlcyBhIFNvdXJjZSBhbmQgYSBVVEYtOCBjaGFyYWN0ZXIgb2Zmc2V0LCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xuICogbGluZSBhbmQgY29sdW1uIGFzIGEgU291cmNlTG9jYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbihzb3VyY2UsIHBvc2l0aW9uKSB7XG4gIGxldCBsYXN0TGluZVN0YXJ0ID0gMDtcbiAgbGV0IGxpbmUgPSAxO1xuXG4gIGZvciAoY29uc3QgbWF0Y2ggb2Ygc291cmNlLmJvZHkubWF0Y2hBbGwoTGluZVJlZ0V4cCkpIHtcbiAgICB0eXBlb2YgbWF0Y2guaW5kZXggPT09ICdudW1iZXInIHx8IGludmFyaWFudChmYWxzZSk7XG5cbiAgICBpZiAobWF0Y2guaW5kZXggPj0gcG9zaXRpb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxhc3RMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBsaW5lICs9IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sdW1uOiBwb3NpdGlvbiArIDEgLSBsYXN0TGluZVN0YXJ0LFxuICB9O1xufVxuIiwgImltcG9ydCB7IGdldExvY2F0aW9uIH0gZnJvbSAnLi9sb2NhdGlvbi5tanMnO1xuXG4vKipcbiAqIFJlbmRlciBhIGhlbHBmdWwgZGVzY3JpcHRpb24gb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBHcmFwaFFMIFNvdXJjZSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHByaW50U291cmNlTG9jYXRpb24oXG4gICAgbG9jYXRpb24uc291cmNlLFxuICAgIGdldExvY2F0aW9uKGxvY2F0aW9uLnNvdXJjZSwgbG9jYXRpb24uc3RhcnQpLFxuICApO1xufVxuLyoqXG4gKiBSZW5kZXIgYSBoZWxwZnVsIGRlc2NyaXB0aW9uIG9mIHRoZSBsb2NhdGlvbiBpbiB0aGUgR3JhcGhRTCBTb3VyY2UgZG9jdW1lbnQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50U291cmNlTG9jYXRpb24oc291cmNlLCBzb3VyY2VMb2NhdGlvbikge1xuICBjb25zdCBmaXJzdExpbmVDb2x1bW5PZmZzZXQgPSBzb3VyY2UubG9jYXRpb25PZmZzZXQuY29sdW1uIC0gMTtcbiAgY29uc3QgYm9keSA9ICcnLnBhZFN0YXJ0KGZpcnN0TGluZUNvbHVtbk9mZnNldCkgKyBzb3VyY2UuYm9keTtcbiAgY29uc3QgbGluZUluZGV4ID0gc291cmNlTG9jYXRpb24ubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVPZmZzZXQgPSBzb3VyY2UubG9jYXRpb25PZmZzZXQubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVOdW0gPSBzb3VyY2VMb2NhdGlvbi5saW5lICsgbGluZU9mZnNldDtcbiAgY29uc3QgY29sdW1uT2Zmc2V0ID0gc291cmNlTG9jYXRpb24ubGluZSA9PT0gMSA/IGZpcnN0TGluZUNvbHVtbk9mZnNldCA6IDA7XG4gIGNvbnN0IGNvbHVtbk51bSA9IHNvdXJjZUxvY2F0aW9uLmNvbHVtbiArIGNvbHVtbk9mZnNldDtcbiAgY29uc3QgbG9jYXRpb25TdHIgPSBgJHtzb3VyY2UubmFtZX06JHtsaW5lTnVtfToke2NvbHVtbk51bX1cXG5gO1xuICBjb25zdCBsaW5lcyA9IGJvZHkuc3BsaXQoL1xcclxcbnxbXFxuXFxyXS9nKTtcbiAgY29uc3QgbG9jYXRpb25MaW5lID0gbGluZXNbbGluZUluZGV4XTsgLy8gU3BlY2lhbCBjYXNlIGZvciBtaW5pZmllZCBkb2N1bWVudHNcblxuICBpZiAobG9jYXRpb25MaW5lLmxlbmd0aCA+IDEyMCkge1xuICAgIGNvbnN0IHN1YkxpbmVJbmRleCA9IE1hdGguZmxvb3IoY29sdW1uTnVtIC8gODApO1xuICAgIGNvbnN0IHN1YkxpbmVDb2x1bW5OdW0gPSBjb2x1bW5OdW0gJSA4MDtcbiAgICBjb25zdCBzdWJMaW5lcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbkxpbmUubGVuZ3RoOyBpICs9IDgwKSB7XG4gICAgICBzdWJMaW5lcy5wdXNoKGxvY2F0aW9uTGluZS5zbGljZShpLCBpICsgODApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgbG9jYXRpb25TdHIgK1xuICAgICAgcHJpbnRQcmVmaXhlZExpbmVzKFtcbiAgICAgICAgW2Ake2xpbmVOdW19IHxgLCBzdWJMaW5lc1swXV0sXG4gICAgICAgIC4uLnN1YkxpbmVzLnNsaWNlKDEsIHN1YkxpbmVJbmRleCArIDEpLm1hcCgoc3ViTGluZSkgPT4gWyd8Jywgc3ViTGluZV0pLFxuICAgICAgICBbJ3wnLCAnXicucGFkU3RhcnQoc3ViTGluZUNvbHVtbk51bSldLFxuICAgICAgICBbJ3wnLCBzdWJMaW5lc1tzdWJMaW5lSW5kZXggKyAxXV0sXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGxvY2F0aW9uU3RyICtcbiAgICBwcmludFByZWZpeGVkTGluZXMoW1xuICAgICAgLy8gTGluZXMgc3BlY2lmaWVkIGxpa2UgdGhpczogW1wicHJlZml4XCIsIFwic3RyaW5nXCJdLFxuICAgICAgW2Ake2xpbmVOdW0gLSAxfSB8YCwgbGluZXNbbGluZUluZGV4IC0gMV1dLFxuICAgICAgW2Ake2xpbmVOdW19IHxgLCBsb2NhdGlvbkxpbmVdLFxuICAgICAgWyd8JywgJ14nLnBhZFN0YXJ0KGNvbHVtbk51bSldLFxuICAgICAgW2Ake2xpbmVOdW0gKyAxfSB8YCwgbGluZXNbbGluZUluZGV4ICsgMV1dLFxuICAgIF0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHByaW50UHJlZml4ZWRMaW5lcyhsaW5lcykge1xuICBjb25zdCBleGlzdGluZ0xpbmVzID0gbGluZXMuZmlsdGVyKChbXywgbGluZV0pID0+IGxpbmUgIT09IHVuZGVmaW5lZCk7XG4gIGNvbnN0IHBhZExlbiA9IE1hdGgubWF4KC4uLmV4aXN0aW5nTGluZXMubWFwKChbcHJlZml4XSkgPT4gcHJlZml4Lmxlbmd0aCkpO1xuICByZXR1cm4gZXhpc3RpbmdMaW5lc1xuICAgIC5tYXAoKFtwcmVmaXgsIGxpbmVdKSA9PiBwcmVmaXgucGFkU3RhcnQocGFkTGVuKSArIChsaW5lID8gJyAnICsgbGluZSA6ICcnKSlcbiAgICAuam9pbignXFxuJyk7XG59XG4iLCAiaW1wb3J0IHsgaXNPYmplY3RMaWtlIH0gZnJvbSAnLi4vanN1dGlscy9pc09iamVjdExpa2UubWpzJztcbmltcG9ydCB7IGdldExvY2F0aW9uIH0gZnJvbSAnLi4vbGFuZ3VhZ2UvbG9jYXRpb24ubWpzJztcbmltcG9ydCB7XG4gIHByaW50TG9jYXRpb24sXG4gIHByaW50U291cmNlTG9jYXRpb24sXG59IGZyb20gJy4uL2xhbmd1YWdlL3ByaW50TG9jYXRpb24ubWpzJztcblxuZnVuY3Rpb24gdG9Ob3JtYWxpemVkT3B0aW9ucyhhcmdzKSB7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXTtcblxuICBpZiAoZmlyc3RBcmcgPT0gbnVsbCB8fCAna2luZCcgaW4gZmlyc3RBcmcgfHwgJ2xlbmd0aCcgaW4gZmlyc3RBcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IGZpcnN0QXJnLFxuICAgICAgc291cmNlOiBhcmdzWzFdLFxuICAgICAgcG9zaXRpb25zOiBhcmdzWzJdLFxuICAgICAgcGF0aDogYXJnc1szXSxcbiAgICAgIG9yaWdpbmFsRXJyb3I6IGFyZ3NbNF0sXG4gICAgICBleHRlbnNpb25zOiBhcmdzWzVdLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmlyc3RBcmc7XG59XG4vKipcbiAqIEEgR3JhcGhRTEVycm9yIGRlc2NyaWJlcyBhbiBFcnJvciBmb3VuZCBkdXJpbmcgdGhlIHBhcnNlLCB2YWxpZGF0ZSwgb3JcbiAqIGV4ZWN1dGUgcGhhc2VzIG9mIHBlcmZvcm1pbmcgYSBHcmFwaFFMIG9wZXJhdGlvbi4gSW4gYWRkaXRpb24gdG8gYSBtZXNzYWdlXG4gKiBhbmQgc3RhY2sgdHJhY2UsIGl0IGFsc28gaW5jbHVkZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvY2F0aW9ucyBpbiBhXG4gKiBHcmFwaFFMIGRvY3VtZW50IGFuZC9vciBleGVjdXRpb24gcmVzdWx0IHRoYXQgY29ycmVzcG9uZCB0byB0aGUgRXJyb3IuXG4gKi9cblxuZXhwb3J0IGNsYXNzIEdyYXBoUUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGB7IGxpbmUsIGNvbHVtbiB9YCBsb2NhdGlvbnMgd2l0aGluIHRoZSBzb3VyY2UgR3JhcGhRTCBkb2N1bWVudFxuICAgKiB3aGljaCBjb3JyZXNwb25kIHRvIHRoaXMgZXJyb3IuXG4gICAqXG4gICAqIEVycm9ycyBkdXJpbmcgdmFsaWRhdGlvbiBvZnRlbiBjb250YWluIG11bHRpcGxlIGxvY2F0aW9ucywgZm9yIGV4YW1wbGUgdG9cbiAgICogcG9pbnQgb3V0IHR3byB0aGluZ3Mgd2l0aCB0aGUgc2FtZSBuYW1lLiBFcnJvcnMgZHVyaW5nIGV4ZWN1dGlvbiBpbmNsdWRlIGFcbiAgICogc2luZ2xlIGxvY2F0aW9uLCB0aGUgZmllbGQgd2hpY2ggcHJvZHVjZWQgdGhlIGVycm9yLlxuICAgKlxuICAgKiBFbnVtZXJhYmxlLCBhbmQgYXBwZWFycyBpbiB0aGUgcmVzdWx0IG9mIEpTT04uc3RyaW5naWZ5KCkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBkZXNjcmliaW5nIHRoZSBKU09OLXBhdGggaW50byB0aGUgZXhlY3V0aW9uIHJlc3BvbnNlIHdoaWNoXG4gICAqIGNvcnJlc3BvbmRzIHRvIHRoaXMgZXJyb3IuIE9ubHkgaW5jbHVkZWQgZm9yIGVycm9ycyBkdXJpbmcgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBFbnVtZXJhYmxlLCBhbmQgYXBwZWFycyBpbiB0aGUgcmVzdWx0IG9mIEpTT04uc3RyaW5naWZ5KCkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBHcmFwaFFMIEFTVCBOb2RlcyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgZXJyb3IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgc291cmNlIEdyYXBoUUwgZG9jdW1lbnQgZm9yIHRoZSBmaXJzdCBsb2NhdGlvbiBvZiB0aGlzIGVycm9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgdGhpcyBFcnJvciByZXByZXNlbnRzIG1vcmUgdGhhbiBvbmUgbm9kZSwgdGhlIHNvdXJjZSBtYXkgbm90XG4gICAqIHJlcHJlc2VudCBub2RlcyBhZnRlciB0aGUgZmlyc3Qgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGNoYXJhY3RlciBvZmZzZXRzIHdpdGhpbiB0aGUgc291cmNlIEdyYXBoUUwgZG9jdW1lbnRcbiAgICogd2hpY2ggY29ycmVzcG9uZCB0byB0aGlzIGVycm9yLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIGVycm9yIHRocm93biBmcm9tIGEgZmllbGQgcmVzb2x2ZXIgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIEV4dGVuc2lvbiBmaWVsZHMgdG8gYWRkIHRvIHRoZSBmb3JtYXR0ZWQgZXJyb3IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHRoZSBgR3JhcGhRTEVycm9yT3B0aW9uc2AgY29uc3RydWN0b3Igb3ZlcmxvYWQgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIC4uLnJhd0FyZ3MpIHtcbiAgICB2YXIgX3RoaXMkbm9kZXMsIF9ub2RlTG9jYXRpb25zJCwgX3JlZjtcblxuICAgIGNvbnN0IHsgbm9kZXMsIHNvdXJjZSwgcG9zaXRpb25zLCBwYXRoLCBvcmlnaW5hbEVycm9yLCBleHRlbnNpb25zIH0gPVxuICAgICAgdG9Ob3JtYWxpemVkT3B0aW9ucyhyYXdBcmdzKTtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnR3JhcGhRTEVycm9yJztcbiAgICB0aGlzLnBhdGggPSBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID1cbiAgICAgIG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgb3JpZ2luYWxFcnJvciAhPT0gdm9pZCAwXG4gICAgICAgID8gb3JpZ2luYWxFcnJvclxuICAgICAgICA6IHVuZGVmaW5lZDsgLy8gQ29tcHV0ZSBsaXN0IG9mIGJsYW1lIG5vZGVzLlxuXG4gICAgdGhpcy5ub2RlcyA9IHVuZGVmaW5lZElmRW1wdHkoXG4gICAgICBBcnJheS5pc0FycmF5KG5vZGVzKSA/IG5vZGVzIDogbm9kZXMgPyBbbm9kZXNdIDogdW5kZWZpbmVkLFxuICAgICk7XG4gICAgY29uc3Qgbm9kZUxvY2F0aW9ucyA9IHVuZGVmaW5lZElmRW1wdHkoXG4gICAgICAoX3RoaXMkbm9kZXMgPSB0aGlzLm5vZGVzKSA9PT0gbnVsbCB8fCBfdGhpcyRub2RlcyA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogX3RoaXMkbm9kZXMubWFwKChub2RlKSA9PiBub2RlLmxvYykuZmlsdGVyKChsb2MpID0+IGxvYyAhPSBudWxsKSxcbiAgICApOyAvLyBDb21wdXRlIGxvY2F0aW9ucyBpbiB0aGUgc291cmNlIGZvciB0aGUgZ2l2ZW4gbm9kZXMvcG9zaXRpb25zLlxuXG4gICAgdGhpcy5zb3VyY2UgPVxuICAgICAgc291cmNlICE9PSBudWxsICYmIHNvdXJjZSAhPT0gdm9pZCAwXG4gICAgICAgID8gc291cmNlXG4gICAgICAgIDogbm9kZUxvY2F0aW9ucyA9PT0gbnVsbCB8fCBub2RlTG9jYXRpb25zID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiAoX25vZGVMb2NhdGlvbnMkID0gbm9kZUxvY2F0aW9uc1swXSkgPT09IG51bGwgfHxcbiAgICAgICAgICBfbm9kZUxvY2F0aW9ucyQgPT09IHZvaWQgMFxuICAgICAgICA/IHZvaWQgMFxuICAgICAgICA6IF9ub2RlTG9jYXRpb25zJC5zb3VyY2U7XG4gICAgdGhpcy5wb3NpdGlvbnMgPVxuICAgICAgcG9zaXRpb25zICE9PSBudWxsICYmIHBvc2l0aW9ucyAhPT0gdm9pZCAwXG4gICAgICAgID8gcG9zaXRpb25zXG4gICAgICAgIDogbm9kZUxvY2F0aW9ucyA9PT0gbnVsbCB8fCBub2RlTG9jYXRpb25zID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBub2RlTG9jYXRpb25zLm1hcCgobG9jKSA9PiBsb2Muc3RhcnQpO1xuICAgIHRoaXMubG9jYXRpb25zID1cbiAgICAgIHBvc2l0aW9ucyAmJiBzb3VyY2VcbiAgICAgICAgPyBwb3NpdGlvbnMubWFwKChwb3MpID0+IGdldExvY2F0aW9uKHNvdXJjZSwgcG9zKSlcbiAgICAgICAgOiBub2RlTG9jYXRpb25zID09PSBudWxsIHx8IG5vZGVMb2NhdGlvbnMgPT09IHZvaWQgMFxuICAgICAgICA/IHZvaWQgMFxuICAgICAgICA6IG5vZGVMb2NhdGlvbnMubWFwKChsb2MpID0+IGdldExvY2F0aW9uKGxvYy5zb3VyY2UsIGxvYy5zdGFydCkpO1xuICAgIGNvbnN0IG9yaWdpbmFsRXh0ZW5zaW9ucyA9IGlzT2JqZWN0TGlrZShcbiAgICAgIG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogb3JpZ2luYWxFcnJvci5leHRlbnNpb25zLFxuICAgIClcbiAgICAgID8gb3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBvcmlnaW5hbEVycm9yLmV4dGVuc2lvbnNcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9XG4gICAgICAoX3JlZiA9XG4gICAgICAgIGV4dGVuc2lvbnMgIT09IG51bGwgJiYgZXh0ZW5zaW9ucyAhPT0gdm9pZCAwXG4gICAgICAgICAgPyBleHRlbnNpb25zXG4gICAgICAgICAgOiBvcmlnaW5hbEV4dGVuc2lvbnMpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMFxuICAgICAgICA/IF9yZWZcbiAgICAgICAgOiBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBPbmx5IHByb3BlcnRpZXMgcHJlc2NyaWJlZCBieSB0aGUgc3BlYyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbiAgICAvLyBLZWVwIHRoZSByZXN0IGFzIG5vbi1lbnVtZXJhYmxlLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgbWVzc2FnZToge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBuYW1lOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIG5vZGVzOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHNvdXJjZToge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgb3JpZ2luYWxFcnJvcjoge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7IC8vIEluY2x1ZGUgKG5vbi1lbnVtZXJhYmxlKSBzdGFjayB0cmFjZS5cblxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMzE3XG5cbiAgICBpZiAoXG4gICAgICBvcmlnaW5hbEVycm9yICE9PSBudWxsICYmXG4gICAgICBvcmlnaW5hbEVycm9yICE9PSB2b2lkIDAgJiZcbiAgICAgIG9yaWdpbmFsRXJyb3Iuc3RhY2tcbiAgICApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLnN0YWNrLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgR3JhcGhRTEVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgdmFsdWU6IEVycm9yKCkuc3RhY2ssXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0dyYXBoUUxFcnJvcic7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgb3V0cHV0ID0gdGhpcy5tZXNzYWdlO1xuXG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgIG91dHB1dCArPSAnXFxuXFxuJyArIHByaW50TG9jYXRpb24obm9kZS5sb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLmxvY2F0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiB0aGlzLmxvY2F0aW9ucykge1xuICAgICAgICBvdXRwdXQgKz0gJ1xcblxcbicgKyBwcmludFNvdXJjZUxvY2F0aW9uKHRoaXMuc291cmNlLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRFcnJvciA9IHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubG9jYXRpb25zICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdHRlZEVycm9yLmxvY2F0aW9ucyA9IHRoaXMubG9jYXRpb25zO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCkge1xuICAgICAgZm9ybWF0dGVkRXJyb3IucGF0aCA9IHRoaXMucGF0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHRlbnNpb25zICE9IG51bGwgJiYgT2JqZWN0LmtleXModGhpcy5leHRlbnNpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3JtYXR0ZWRFcnJvci5leHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRlZmluZWRJZkVtcHR5KGFycmF5KSB7XG4gIHJldHVybiBhcnJheSA9PT0gdW5kZWZpbmVkIHx8IGFycmF5Lmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IGFycmF5O1xufVxuLyoqXG4gKiBTZWU6IGh0dHBzOi8vc3BlYy5ncmFwaHFsLm9yZy9kcmFmdC8jc2VjLUVycm9yc1xuICovXG5cbi8qKlxuICogUHJpbnRzIGEgR3JhcGhRTEVycm9yIHRvIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdXNlZnVsIGxvY2F0aW9uIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgZXJyb3IncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlLlxuICpcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYGVycm9yLnRvU3RyaW5nYCBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjE3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvci50b1N0cmluZygpO1xufVxuLyoqXG4gKiBHaXZlbiBhIEdyYXBoUUxFcnJvciwgZm9ybWF0IGl0IGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVzY3JpYmVkIGJ5IHRoZVxuICogUmVzcG9uc2UgRm9ybWF0LCBFcnJvcnMgc2VjdGlvbiBvZiB0aGUgR3JhcGhRTCBTcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYGVycm9yLnRvSlNPTmAgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIHYxN1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IudG9KU09OKCk7XG59XG4iLCAiaW1wb3J0IHsgR3JhcGhRTEVycm9yIH0gZnJvbSAnLi9HcmFwaFFMRXJyb3IubWpzJztcbi8qKlxuICogUHJvZHVjZXMgYSBHcmFwaFFMRXJyb3IgcmVwcmVzZW50aW5nIGEgc3ludGF4IGVycm9yLCBjb250YWluaW5nIHVzZWZ1bFxuICogZGVzY3JpcHRpdmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN5bnRheCBlcnJvcidzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bnRheEVycm9yKHNvdXJjZSwgcG9zaXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBuZXcgR3JhcGhRTEVycm9yKGBTeW50YXggRXJyb3I6ICR7ZGVzY3JpcHRpb259YCwge1xuICAgIHNvdXJjZSxcbiAgICBwb3NpdGlvbnM6IFtwb3NpdGlvbl0sXG4gIH0pO1xufVxuIiwgIi8qKlxuICogQ29udGFpbnMgYSByYW5nZSBvZiBVVEYtOCBjaGFyYWN0ZXIgb2Zmc2V0cyBhbmQgdG9rZW4gcmVmZXJlbmNlcyB0aGF0XG4gKiBpZGVudGlmeSB0aGUgcmVnaW9uIG9mIHRoZSBzb3VyY2UgZnJvbSB3aGljaCB0aGUgQVNUIGRlcml2ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyIG9mZnNldCBhdCB3aGljaCB0aGlzIE5vZGUgYmVnaW5zLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBUb2tlbiBhdCB3aGljaCB0aGlzIE5vZGUgZW5kcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBTb3VyY2UgZG9jdW1lbnQgdGhlIEFTVCByZXByZXNlbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RhcnRUb2tlbiwgZW5kVG9rZW4sIHNvdXJjZSkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydFRva2VuLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kVG9rZW4uZW5kO1xuICAgIHRoaXMuc3RhcnRUb2tlbiA9IHN0YXJ0VG9rZW47XG4gICAgdGhpcy5lbmRUb2tlbiA9IGVuZFRva2VuO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnTG9jYXRpb24nO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgIGVuZDogdGhpcy5lbmQsXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBhIGxleGljYWwgdG9rZW5cbiAqIHdpdGhpbiBhIFNvdXJjZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogVGhlIGtpbmQgb2YgVG9rZW4uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyIG9mZnNldCBhdCB3aGljaCB0aGlzIE5vZGUgYmVnaW5zLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgMS1pbmRleGVkIGxpbmUgbnVtYmVyIG9uIHdoaWNoIHRoaXMgVG9rZW4gYXBwZWFycy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSAxLWluZGV4ZWQgY29sdW1uIG51bWJlciBhdCB3aGljaCB0aGlzIFRva2VuIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZvciBub24tcHVuY3R1YXRpb24gdG9rZW5zLCByZXByZXNlbnRzIHRoZSBpbnRlcnByZXRlZCB2YWx1ZSBvZiB0aGUgdG9rZW4uXG4gICAqXG4gICAqIE5vdGU6IGlzIHVuZGVmaW5lZCBmb3IgcHVuY3R1YXRpb24gdG9rZW5zLCBidXQgdHlwZWQgYXMgc3RyaW5nIGZvclxuICAgKiBjb252ZW5pZW5jZSBpbiB0aGUgcGFyc2VyLlxuICAgKi9cblxuICAvKipcbiAgICogVG9rZW5zIGV4aXN0IGFzIG5vZGVzIGluIGEgZG91YmxlLWxpbmtlZC1saXN0IGFtb25nc3QgYWxsIHRva2Vuc1xuICAgKiBpbmNsdWRpbmcgaWdub3JlZCB0b2tlbnMuIDxTT0Y+IGlzIGFsd2F5cyB0aGUgZmlyc3Qgbm9kZSBhbmQgPEVPRj5cbiAgICogdGhlIGxhc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdUb2tlbic7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFRoZSBsaXN0IG9mIGFsbCBwb3NzaWJsZSBBU1Qgbm9kZSB0eXBlcy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgUXVlcnlEb2N1bWVudEtleXMgPSB7XG4gIE5hbWU6IFtdLFxuICBEb2N1bWVudDogWydkZWZpbml0aW9ucyddLFxuICBPcGVyYXRpb25EZWZpbml0aW9uOiBbXG4gICAgJ25hbWUnLFxuICAgICd2YXJpYWJsZURlZmluaXRpb25zJyxcbiAgICAnZGlyZWN0aXZlcycsXG4gICAgJ3NlbGVjdGlvblNldCcsXG4gIF0sXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogWyd2YXJpYWJsZScsICd0eXBlJywgJ2RlZmF1bHRWYWx1ZScsICdkaXJlY3RpdmVzJ10sXG4gIFZhcmlhYmxlOiBbJ25hbWUnXSxcbiAgU2VsZWN0aW9uU2V0OiBbJ3NlbGVjdGlvbnMnXSxcbiAgRmllbGQ6IFsnYWxpYXMnLCAnbmFtZScsICdhcmd1bWVudHMnLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgQXJndW1lbnQ6IFsnbmFtZScsICd2YWx1ZSddLFxuICBGcmFnbWVudFNwcmVhZDogWyduYW1lJywgJ2RpcmVjdGl2ZXMnXSxcbiAgSW5saW5lRnJhZ21lbnQ6IFsndHlwZUNvbmRpdGlvbicsICdkaXJlY3RpdmVzJywgJ3NlbGVjdGlvblNldCddLFxuICBGcmFnbWVudERlZmluaXRpb246IFtcbiAgICAnbmFtZScsIC8vIE5vdGU6IGZyYWdtZW50IHZhcmlhYmxlIGRlZmluaXRpb25zIGFyZSBkZXByZWNhdGVkIGFuZCB3aWxsIHJlbW92ZWQgaW4gdjE3LjAuMFxuICAgICd2YXJpYWJsZURlZmluaXRpb25zJyxcbiAgICAndHlwZUNvbmRpdGlvbicsXG4gICAgJ2RpcmVjdGl2ZXMnLFxuICAgICdzZWxlY3Rpb25TZXQnLFxuICBdLFxuICBJbnRWYWx1ZTogW10sXG4gIEZsb2F0VmFsdWU6IFtdLFxuICBTdHJpbmdWYWx1ZTogW10sXG4gIEJvb2xlYW5WYWx1ZTogW10sXG4gIE51bGxWYWx1ZTogW10sXG4gIEVudW1WYWx1ZTogW10sXG4gIExpc3RWYWx1ZTogWyd2YWx1ZXMnXSxcbiAgT2JqZWN0VmFsdWU6IFsnZmllbGRzJ10sXG4gIE9iamVjdEZpZWxkOiBbJ25hbWUnLCAndmFsdWUnXSxcbiAgRGlyZWN0aXZlOiBbJ25hbWUnLCAnYXJndW1lbnRzJ10sXG4gIE5hbWVkVHlwZTogWyduYW1lJ10sXG4gIExpc3RUeXBlOiBbJ3R5cGUnXSxcbiAgTm9uTnVsbFR5cGU6IFsndHlwZSddLFxuICBTY2hlbWFEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ2RpcmVjdGl2ZXMnLCAnb3BlcmF0aW9uVHlwZXMnXSxcbiAgT3BlcmF0aW9uVHlwZURlZmluaXRpb246IFsndHlwZSddLFxuICBTY2FsYXJUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnXSxcbiAgT2JqZWN0VHlwZURlZmluaXRpb246IFtcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICduYW1lJyxcbiAgICAnaW50ZXJmYWNlcycsXG4gICAgJ2RpcmVjdGl2ZXMnLFxuICAgICdmaWVsZHMnLFxuICBdLFxuICBGaWVsZERlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdhcmd1bWVudHMnLCAndHlwZScsICdkaXJlY3RpdmVzJ10sXG4gIElucHV0VmFsdWVEZWZpbml0aW9uOiBbXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnbmFtZScsXG4gICAgJ3R5cGUnLFxuICAgICdkZWZhdWx0VmFsdWUnLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgXSxcbiAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IFtcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICduYW1lJyxcbiAgICAnaW50ZXJmYWNlcycsXG4gICAgJ2RpcmVjdGl2ZXMnLFxuICAgICdmaWVsZHMnLFxuICBdLFxuICBVbmlvblR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcycsICd0eXBlcyddLFxuICBFbnVtVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ3ZhbHVlcyddLFxuICBFbnVtVmFsdWVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgRGlyZWN0aXZlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2FyZ3VtZW50cycsICdsb2NhdGlvbnMnXSxcbiAgU2NoZW1hRXh0ZW5zaW9uOiBbJ2RpcmVjdGl2ZXMnLCAnb3BlcmF0aW9uVHlwZXMnXSxcbiAgU2NhbGFyVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnXSxcbiAgT2JqZWN0VHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2ludGVyZmFjZXMnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2ludGVyZmFjZXMnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgVW5pb25UeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICd0eXBlcyddLFxuICBFbnVtVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndmFsdWVzJ10sXG4gIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG59O1xuY29uc3Qga2luZFZhbHVlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoUXVlcnlEb2N1bWVudEtleXMpKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZShtYXliZU5vZGUpIHtcbiAgY29uc3QgbWF5YmVLaW5kID1cbiAgICBtYXliZU5vZGUgPT09IG51bGwgfHwgbWF5YmVOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZU5vZGUua2luZDtcbiAgcmV0dXJuIHR5cGVvZiBtYXliZUtpbmQgPT09ICdzdHJpbmcnICYmIGtpbmRWYWx1ZXMuaGFzKG1heWJlS2luZCk7XG59XG4vKiogTmFtZSAqL1xuXG52YXIgT3BlcmF0aW9uVHlwZU5vZGU7XG5cbihmdW5jdGlvbiAoT3BlcmF0aW9uVHlwZU5vZGUpIHtcbiAgT3BlcmF0aW9uVHlwZU5vZGVbJ1FVRVJZJ10gPSAncXVlcnknO1xuICBPcGVyYXRpb25UeXBlTm9kZVsnTVVUQVRJT04nXSA9ICdtdXRhdGlvbic7XG4gIE9wZXJhdGlvblR5cGVOb2RlWydTVUJTQ1JJUFRJT04nXSA9ICdzdWJzY3JpcHRpb24nO1xufSkoT3BlcmF0aW9uVHlwZU5vZGUgfHwgKE9wZXJhdGlvblR5cGVOb2RlID0ge30pKTtcblxuZXhwb3J0IHsgT3BlcmF0aW9uVHlwZU5vZGUgfTtcbiIsICIvKipcbiAqIFRoZSBzZXQgb2YgYWxsb3dlZCBkaXJlY3RpdmUgbG9jYXRpb24gdmFsdWVzLlxuICovXG52YXIgRGlyZWN0aXZlTG9jYXRpb247XG5cbihmdW5jdGlvbiAoRGlyZWN0aXZlTG9jYXRpb24pIHtcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ1FVRVJZJ10gPSAnUVVFUlknO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnTVVUQVRJT04nXSA9ICdNVVRBVElPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydTVUJTQ1JJUFRJT04nXSA9ICdTVUJTQ1JJUFRJT04nO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnRklFTEQnXSA9ICdGSUVMRCc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydGUkFHTUVOVF9ERUZJTklUSU9OJ10gPSAnRlJBR01FTlRfREVGSU5JVElPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydGUkFHTUVOVF9TUFJFQUQnXSA9ICdGUkFHTUVOVF9TUFJFQUQnO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnSU5MSU5FX0ZSQUdNRU5UJ10gPSAnSU5MSU5FX0ZSQUdNRU5UJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ1ZBUklBQkxFX0RFRklOSVRJT04nXSA9ICdWQVJJQUJMRV9ERUZJTklUSU9OJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ1NDSEVNQSddID0gJ1NDSEVNQSc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydTQ0FMQVInXSA9ICdTQ0FMQVInO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnT0JKRUNUJ10gPSAnT0JKRUNUJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0ZJRUxEX0RFRklOSVRJT04nXSA9ICdGSUVMRF9ERUZJTklUSU9OJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0FSR1VNRU5UX0RFRklOSVRJT04nXSA9ICdBUkdVTUVOVF9ERUZJTklUSU9OJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0lOVEVSRkFDRSddID0gJ0lOVEVSRkFDRSc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydVTklPTiddID0gJ1VOSU9OJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0VOVU0nXSA9ICdFTlVNJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0VOVU1fVkFMVUUnXSA9ICdFTlVNX1ZBTFVFJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0lOUFVUX09CSkVDVCddID0gJ0lOUFVUX09CSkVDVCc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydJTlBVVF9GSUVMRF9ERUZJTklUSU9OJ10gPSAnSU5QVVRfRklFTERfREVGSU5JVElPTic7XG59KShEaXJlY3RpdmVMb2NhdGlvbiB8fCAoRGlyZWN0aXZlTG9jYXRpb24gPSB7fSkpO1xuXG5leHBvcnQgeyBEaXJlY3RpdmVMb2NhdGlvbiB9O1xuLyoqXG4gKiBUaGUgZW51bSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aXZlIGxvY2F0aW9uIHZhbHVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBEaXJlY3RpdmVMb2NhdGlvbmAuIFdpbGwgYmUgcmVtb3ZlIGluIHYxNy5cbiAqL1xuIiwgIi8qKlxuICogVGhlIHNldCBvZiBhbGxvd2VkIGtpbmQgdmFsdWVzIGZvciBBU1Qgbm9kZXMuXG4gKi9cbnZhciBLaW5kO1xuXG4oZnVuY3Rpb24gKEtpbmQpIHtcbiAgS2luZFsnTkFNRSddID0gJ05hbWUnO1xuICBLaW5kWydET0NVTUVOVCddID0gJ0RvY3VtZW50JztcbiAgS2luZFsnT1BFUkFUSU9OX0RFRklOSVRJT04nXSA9ICdPcGVyYXRpb25EZWZpbml0aW9uJztcbiAgS2luZFsnVkFSSUFCTEVfREVGSU5JVElPTiddID0gJ1ZhcmlhYmxlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ1NFTEVDVElPTl9TRVQnXSA9ICdTZWxlY3Rpb25TZXQnO1xuICBLaW5kWydGSUVMRCddID0gJ0ZpZWxkJztcbiAgS2luZFsnQVJHVU1FTlQnXSA9ICdBcmd1bWVudCc7XG4gIEtpbmRbJ0ZSQUdNRU5UX1NQUkVBRCddID0gJ0ZyYWdtZW50U3ByZWFkJztcbiAgS2luZFsnSU5MSU5FX0ZSQUdNRU5UJ10gPSAnSW5saW5lRnJhZ21lbnQnO1xuICBLaW5kWydGUkFHTUVOVF9ERUZJTklUSU9OJ10gPSAnRnJhZ21lbnREZWZpbml0aW9uJztcbiAgS2luZFsnVkFSSUFCTEUnXSA9ICdWYXJpYWJsZSc7XG4gIEtpbmRbJ0lOVCddID0gJ0ludFZhbHVlJztcbiAgS2luZFsnRkxPQVQnXSA9ICdGbG9hdFZhbHVlJztcbiAgS2luZFsnU1RSSU5HJ10gPSAnU3RyaW5nVmFsdWUnO1xuICBLaW5kWydCT09MRUFOJ10gPSAnQm9vbGVhblZhbHVlJztcbiAgS2luZFsnTlVMTCddID0gJ051bGxWYWx1ZSc7XG4gIEtpbmRbJ0VOVU0nXSA9ICdFbnVtVmFsdWUnO1xuICBLaW5kWydMSVNUJ10gPSAnTGlzdFZhbHVlJztcbiAgS2luZFsnT0JKRUNUJ10gPSAnT2JqZWN0VmFsdWUnO1xuICBLaW5kWydPQkpFQ1RfRklFTEQnXSA9ICdPYmplY3RGaWVsZCc7XG4gIEtpbmRbJ0RJUkVDVElWRSddID0gJ0RpcmVjdGl2ZSc7XG4gIEtpbmRbJ05BTUVEX1RZUEUnXSA9ICdOYW1lZFR5cGUnO1xuICBLaW5kWydMSVNUX1RZUEUnXSA9ICdMaXN0VHlwZSc7XG4gIEtpbmRbJ05PTl9OVUxMX1RZUEUnXSA9ICdOb25OdWxsVHlwZSc7XG4gIEtpbmRbJ1NDSEVNQV9ERUZJTklUSU9OJ10gPSAnU2NoZW1hRGVmaW5pdGlvbic7XG4gIEtpbmRbJ09QRVJBVElPTl9UWVBFX0RFRklOSVRJT04nXSA9ICdPcGVyYXRpb25UeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ1NDQUxBUl9UWVBFX0RFRklOSVRJT04nXSA9ICdTY2FsYXJUeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ09CSkVDVF9UWVBFX0RFRklOSVRJT04nXSA9ICdPYmplY3RUeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0ZJRUxEX0RFRklOSVRJT04nXSA9ICdGaWVsZERlZmluaXRpb24nO1xuICBLaW5kWydJTlBVVF9WQUxVRV9ERUZJTklUSU9OJ10gPSAnSW5wdXRWYWx1ZURlZmluaXRpb24nO1xuICBLaW5kWydJTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OJ10gPSAnSW50ZXJmYWNlVHlwZURlZmluaXRpb24nO1xuICBLaW5kWydVTklPTl9UWVBFX0RFRklOSVRJT04nXSA9ICdVbmlvblR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnRU5VTV9UWVBFX0RFRklOSVRJT04nXSA9ICdFbnVtVHlwZURlZmluaXRpb24nO1xuICBLaW5kWydFTlVNX1ZBTFVFX0RFRklOSVRJT04nXSA9ICdFbnVtVmFsdWVEZWZpbml0aW9uJztcbiAgS2luZFsnSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTiddID0gJ0lucHV0T2JqZWN0VHlwZURlZmluaXRpb24nO1xuICBLaW5kWydESVJFQ1RJVkVfREVGSU5JVElPTiddID0gJ0RpcmVjdGl2ZURlZmluaXRpb24nO1xuICBLaW5kWydTQ0hFTUFfRVhURU5TSU9OJ10gPSAnU2NoZW1hRXh0ZW5zaW9uJztcbiAgS2luZFsnU0NBTEFSX1RZUEVfRVhURU5TSU9OJ10gPSAnU2NhbGFyVHlwZUV4dGVuc2lvbic7XG4gIEtpbmRbJ09CSkVDVF9UWVBFX0VYVEVOU0lPTiddID0gJ09iamVjdFR5cGVFeHRlbnNpb24nO1xuICBLaW5kWydJTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT04nXSA9ICdJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uJztcbiAgS2luZFsnVU5JT05fVFlQRV9FWFRFTlNJT04nXSA9ICdVbmlvblR5cGVFeHRlbnNpb24nO1xuICBLaW5kWydFTlVNX1RZUEVfRVhURU5TSU9OJ10gPSAnRW51bVR5cGVFeHRlbnNpb24nO1xuICBLaW5kWydJTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT04nXSA9ICdJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24nO1xufSkoS2luZCB8fCAoS2luZCA9IHt9KSk7XG5cbmV4cG9ydCB7IEtpbmQgfTtcbi8qKlxuICogVGhlIGVudW0gdHlwZSByZXByZXNlbnRpbmcgdGhlIHBvc3NpYmxlIGtpbmQgdmFsdWVzIG9mIEFTVCBub2Rlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBLaW5kYC4gV2lsbCBiZSByZW1vdmUgaW4gdjE3LlxuICovXG4iLCAiLyoqXG4gKiBgYGBcbiAqIFdoaXRlU3BhY2UgOjpcbiAqICAgLSBcIkhvcml6b250YWwgVGFiIChVKzAwMDkpXCJcbiAqICAgLSBcIlNwYWNlIChVKzAwMjApXCJcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMDtcbn1cbi8qKlxuICogYGBgXG4gKiBEaWdpdCA6OiBvbmUgb2ZcbiAqICAgLSBgMGAgYDFgIGAyYCBgM2AgYDRgIGA1YCBgNmAgYDdgIGA4YCBgOWBcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzk7XG59XG4vKipcbiAqIGBgYFxuICogTGV0dGVyIDo6IG9uZSBvZlxuICogICAtIGBBYCBgQmAgYENgIGBEYCBgRWAgYEZgIGBHYCBgSGAgYElgIGBKYCBgS2AgYExgIGBNYFxuICogICAtIGBOYCBgT2AgYFBgIGBRYCBgUmAgYFNgIGBUYCBgVWAgYFZgIGBXYCBgWGAgYFlgIGBaYFxuICogICAtIGBhYCBgYmAgYGNgIGBkYCBgZWAgYGZgIGBnYCBgaGAgYGlgIGBqYCBga2AgYGxgIGBtYFxuICogICAtIGBuYCBgb2AgYHBgIGBxYCBgcmAgYHNgIGB0YCBgdWAgYHZgIGB3YCBgeGAgYHlgIGB6YFxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZXR0ZXIoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSkgfHwgLy8gQS1aXG4gICAgKGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDVhKSAvLyBhLXpcbiAgKTtcbn1cbi8qKlxuICogYGBgXG4gKiBOYW1lU3RhcnQgOjpcbiAqICAgLSBMZXR0ZXJcbiAqICAgLSBgX2BcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTmFtZVN0YXJ0KGNvZGUpIHtcbiAgcmV0dXJuIGlzTGV0dGVyKGNvZGUpIHx8IGNvZGUgPT09IDB4MDA1Zjtcbn1cbi8qKlxuICogYGBgXG4gKiBOYW1lQ29udGludWUgOjpcbiAqICAgLSBMZXR0ZXJcbiAqICAgLSBEaWdpdFxuICogICAtIGBfYFxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lQ29udGludWUoY29kZSkge1xuICByZXR1cm4gaXNMZXR0ZXIoY29kZSkgfHwgaXNEaWdpdChjb2RlKSB8fCBjb2RlID09PSAweDAwNWY7XG59XG4iLCAiaW1wb3J0IHsgaXNXaGl0ZVNwYWNlIH0gZnJvbSAnLi9jaGFyYWN0ZXJDbGFzc2VzLm1qcyc7XG4vKipcbiAqIFByb2R1Y2VzIHRoZSB2YWx1ZSBvZiBhIGJsb2NrIHN0cmluZyBmcm9tIGl0cyBwYXJzZWQgcmF3IHZhbHVlLCBzaW1pbGFyIHRvXG4gKiBDb2ZmZWVTY3JpcHQncyBibG9jayBzdHJpbmcsIFB5dGhvbidzIGRvY3N0cmluZyB0cmltIG9yIFJ1YnkncyBzdHJpcF9oZXJlZG9jLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyB0aGUgR3JhcGhRTCBzcGVjJ3MgQmxvY2tTdHJpbmdWYWx1ZSgpIHN0YXRpYyBhbGdvcml0aG0uXG4gKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZGVudEJsb2NrU3RyaW5nTGluZXMobGluZXMpIHtcbiAgdmFyIF9maXJzdE5vbkVtcHR5TGluZTI7XG5cbiAgbGV0IGNvbW1vbkluZGVudCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICBsZXQgZmlyc3ROb25FbXB0eUxpbmUgPSBudWxsO1xuICBsZXQgbGFzdE5vbkVtcHR5TGluZSA9IC0xO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgX2ZpcnN0Tm9uRW1wdHlMaW5lO1xuXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGluZGVudCA9IGxlYWRpbmdXaGl0ZXNwYWNlKGxpbmUpO1xuXG4gICAgaWYgKGluZGVudCA9PT0gbGluZS5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBza2lwIGVtcHR5IGxpbmVzXG4gICAgfVxuXG4gICAgZmlyc3ROb25FbXB0eUxpbmUgPVxuICAgICAgKF9maXJzdE5vbkVtcHR5TGluZSA9IGZpcnN0Tm9uRW1wdHlMaW5lKSAhPT0gbnVsbCAmJlxuICAgICAgX2ZpcnN0Tm9uRW1wdHlMaW5lICE9PSB2b2lkIDBcbiAgICAgICAgPyBfZmlyc3ROb25FbXB0eUxpbmVcbiAgICAgICAgOiBpO1xuICAgIGxhc3ROb25FbXB0eUxpbmUgPSBpO1xuXG4gICAgaWYgKGkgIT09IDAgJiYgaW5kZW50IDwgY29tbW9uSW5kZW50KSB7XG4gICAgICBjb21tb25JbmRlbnQgPSBpbmRlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzIC8vIFJlbW92ZSBjb21tb24gaW5kZW50YXRpb24gZnJvbSBhbGwgbGluZXMgYnV0IGZpcnN0LlxuICAgIC5tYXAoKGxpbmUsIGkpID0+IChpID09PSAwID8gbGluZSA6IGxpbmUuc2xpY2UoY29tbW9uSW5kZW50KSkpIC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBibGFuayBsaW5lcy5cbiAgICAuc2xpY2UoXG4gICAgICAoX2ZpcnN0Tm9uRW1wdHlMaW5lMiA9IGZpcnN0Tm9uRW1wdHlMaW5lKSAhPT0gbnVsbCAmJlxuICAgICAgICBfZmlyc3ROb25FbXB0eUxpbmUyICE9PSB2b2lkIDBcbiAgICAgICAgPyBfZmlyc3ROb25FbXB0eUxpbmUyXG4gICAgICAgIDogMCxcbiAgICAgIGxhc3ROb25FbXB0eUxpbmUgKyAxLFxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGxlYWRpbmdXaGl0ZXNwYWNlKHN0cikge1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoICYmIGlzV2hpdGVTcGFjZShzdHIuY2hhckNvZGVBdChpKSkpIHtcbiAgICArK2k7XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbnRhYmxlQXNCbG9ja1N0cmluZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBwcmludGFibGVcbiAgfVxuXG4gIGxldCBpc0VtcHR5TGluZSA9IHRydWU7XG4gIGxldCBoYXNJbmRlbnQgPSBmYWxzZTtcbiAgbGV0IGhhc0NvbW1vbkluZGVudCA9IHRydWU7XG4gIGxldCBzZWVuTm9uRW1wdHlMaW5lID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIHN3aXRjaCAodmFsdWUuY29kZVBvaW50QXQoaSkpIHtcbiAgICAgIGNhc2UgMHgwMDAwOlxuICAgICAgY2FzZSAweDAwMDE6XG4gICAgICBjYXNlIDB4MDAwMjpcbiAgICAgIGNhc2UgMHgwMDAzOlxuICAgICAgY2FzZSAweDAwMDQ6XG4gICAgICBjYXNlIDB4MDAwNTpcbiAgICAgIGNhc2UgMHgwMDA2OlxuICAgICAgY2FzZSAweDAwMDc6XG4gICAgICBjYXNlIDB4MDAwODpcbiAgICAgIGNhc2UgMHgwMDBiOlxuICAgICAgY2FzZSAweDAwMGM6XG4gICAgICBjYXNlIDB4MDAwZTpcbiAgICAgIGNhc2UgMHgwMDBmOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBIYXMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzXG5cbiAgICAgIGNhc2UgMHgwMDBkOlxuICAgICAgICAvLyAgXFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIEhhcyBcXHIgb3IgXFxyXFxuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgYXMgXFxuXG5cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIC8vICBcXG5cbiAgICAgICAgaWYgKGlzRW1wdHlMaW5lICYmICFzZWVuTm9uRW1wdHlMaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBIYXMgbGVhZGluZyBuZXcgbGluZVxuICAgICAgICB9XG5cbiAgICAgICAgc2Vlbk5vbkVtcHR5TGluZSA9IHRydWU7XG4gICAgICAgIGlzRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgaGFzSW5kZW50ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDk6IC8vICAgXFx0XG5cbiAgICAgIGNhc2UgMzI6XG4gICAgICAgIC8vICA8c3BhY2U+XG4gICAgICAgIGhhc0luZGVudCB8fCAoaGFzSW5kZW50ID0gaXNFbXB0eUxpbmUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaGFzQ29tbW9uSW5kZW50ICYmIChoYXNDb21tb25JbmRlbnQgPSBoYXNJbmRlbnQpO1xuICAgICAgICBpc0VtcHR5TGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0VtcHR5TGluZSkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gSGFzIHRyYWlsaW5nIGVtcHR5IGxpbmVzXG4gIH1cblxuICBpZiAoaGFzQ29tbW9uSW5kZW50ICYmIHNlZW5Ob25FbXB0eUxpbmUpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIEhhcyBpbnRlcm5hbCBpbmRlbnRcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBQcmludCBhIGJsb2NrIHN0cmluZyBpbiB0aGUgaW5kZW50ZWQgYmxvY2sgZm9ybSBieSBhZGRpbmcgYSBsZWFkaW5nIGFuZFxuICogdHJhaWxpbmcgYmxhbmsgbGluZS4gSG93ZXZlciwgaWYgYSBibG9jayBzdHJpbmcgc3RhcnRzIHdpdGggd2hpdGVzcGFjZSBhbmQgaXNcbiAqIGEgc2luZ2xlLWxpbmUsIGFkZGluZyBhIGxlYWRpbmcgYmxhbmsgbGluZSB3b3VsZCBzdHJpcCB0aGF0IHdoaXRlc3BhY2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50QmxvY2tTdHJpbmcodmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZXNjYXBlZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvXCJcIlwiL2csICdcXFxcXCJcIlwiJyk7IC8vIEV4cGFuZCBhIGJsb2NrIHN0cmluZydzIHJhdyB2YWx1ZSBpbnRvIGluZGVwZW5kZW50IGxpbmVzLlxuXG4gIGNvbnN0IGxpbmVzID0gZXNjYXBlZFZhbHVlLnNwbGl0KC9cXHJcXG58W1xcblxccl0vZyk7XG4gIGNvbnN0IGlzU2luZ2xlTGluZSA9IGxpbmVzLmxlbmd0aCA9PT0gMTsgLy8gSWYgY29tbW9uIGluZGVudGF0aW9uIGlzIGZvdW5kIHdlIGNhbiBmaXggc29tZSBvZiB0aG9zZSBjYXNlcyBieSBhZGRpbmcgbGVhZGluZyBuZXcgbGluZVxuXG4gIGNvbnN0IGZvcmNlTGVhZGluZ05ld0xpbmUgPVxuICAgIGxpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICBsaW5lc1xuICAgICAgLnNsaWNlKDEpXG4gICAgICAuZXZlcnkoKGxpbmUpID0+IGxpbmUubGVuZ3RoID09PSAwIHx8IGlzV2hpdGVTcGFjZShsaW5lLmNoYXJDb2RlQXQoMCkpKTsgLy8gVHJhaWxpbmcgdHJpcGxlIHF1b3RlcyBqdXN0IGxvb2tzIGNvbmZ1c2luZyBidXQgZG9lc24ndCBmb3JjZSB0cmFpbGluZyBuZXcgbGluZVxuXG4gIGNvbnN0IGhhc1RyYWlsaW5nVHJpcGxlUXVvdGVzID0gZXNjYXBlZFZhbHVlLmVuZHNXaXRoKCdcXFxcXCJcIlwiJyk7IC8vIFRyYWlsaW5nIHF1b3RlIChzaW5nbGUgb3IgZG91YmxlKSBvciBzbGFzaCBmb3JjZXMgdHJhaWxpbmcgbmV3IGxpbmVcblxuICBjb25zdCBoYXNUcmFpbGluZ1F1b3RlID0gdmFsdWUuZW5kc1dpdGgoJ1wiJykgJiYgIWhhc1RyYWlsaW5nVHJpcGxlUXVvdGVzO1xuICBjb25zdCBoYXNUcmFpbGluZ1NsYXNoID0gdmFsdWUuZW5kc1dpdGgoJ1xcXFwnKTtcbiAgY29uc3QgZm9yY2VUcmFpbGluZ05ld2xpbmUgPSBoYXNUcmFpbGluZ1F1b3RlIHx8IGhhc1RyYWlsaW5nU2xhc2g7XG4gIGNvbnN0IHByaW50QXNNdWx0aXBsZUxpbmVzID1cbiAgICAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubWluaW1pemUpICYmIC8vIGFkZCBsZWFkaW5nIGFuZCB0cmFpbGluZyBuZXcgbGluZXMgb25seSBpZiBpdCBpbXByb3ZlcyByZWFkYWJpbGl0eVxuICAgICghaXNTaW5nbGVMaW5lIHx8XG4gICAgICB2YWx1ZS5sZW5ndGggPiA3MCB8fFxuICAgICAgZm9yY2VUcmFpbGluZ05ld2xpbmUgfHxcbiAgICAgIGZvcmNlTGVhZGluZ05ld0xpbmUgfHxcbiAgICAgIGhhc1RyYWlsaW5nVHJpcGxlUXVvdGVzKTtcbiAgbGV0IHJlc3VsdCA9ICcnOyAvLyBGb3JtYXQgYSBtdWx0aS1saW5lIGJsb2NrIHF1b3RlIHRvIGFjY291bnQgZm9yIGxlYWRpbmcgc3BhY2UuXG5cbiAgY29uc3Qgc2tpcExlYWRpbmdOZXdMaW5lID0gaXNTaW5nbGVMaW5lICYmIGlzV2hpdGVTcGFjZSh2YWx1ZS5jaGFyQ29kZUF0KDApKTtcblxuICBpZiAoKHByaW50QXNNdWx0aXBsZUxpbmVzICYmICFza2lwTGVhZGluZ05ld0xpbmUpIHx8IGZvcmNlTGVhZGluZ05ld0xpbmUpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICByZXN1bHQgKz0gZXNjYXBlZFZhbHVlO1xuXG4gIGlmIChwcmludEFzTXVsdGlwbGVMaW5lcyB8fCBmb3JjZVRyYWlsaW5nTmV3bGluZSkge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIHJldHVybiAnXCJcIlwiJyArIHJlc3VsdCArICdcIlwiXCInO1xufVxuIiwgIi8qKlxuICogQW4gZXhwb3J0ZWQgZW51bSBkZXNjcmliaW5nIHRoZSBkaWZmZXJlbnQga2luZHMgb2YgdG9rZW5zIHRoYXQgdGhlXG4gKiBsZXhlciBlbWl0cy5cbiAqL1xudmFyIFRva2VuS2luZDtcblxuKGZ1bmN0aW9uIChUb2tlbktpbmQpIHtcbiAgVG9rZW5LaW5kWydTT0YnXSA9ICc8U09GPic7XG4gIFRva2VuS2luZFsnRU9GJ10gPSAnPEVPRj4nO1xuICBUb2tlbktpbmRbJ0JBTkcnXSA9ICchJztcbiAgVG9rZW5LaW5kWydET0xMQVInXSA9ICckJztcbiAgVG9rZW5LaW5kWydBTVAnXSA9ICcmJztcbiAgVG9rZW5LaW5kWydQQVJFTl9MJ10gPSAnKCc7XG4gIFRva2VuS2luZFsnUEFSRU5fUiddID0gJyknO1xuICBUb2tlbktpbmRbJ1NQUkVBRCddID0gJy4uLic7XG4gIFRva2VuS2luZFsnQ09MT04nXSA9ICc6JztcbiAgVG9rZW5LaW5kWydFUVVBTFMnXSA9ICc9JztcbiAgVG9rZW5LaW5kWydBVCddID0gJ0AnO1xuICBUb2tlbktpbmRbJ0JSQUNLRVRfTCddID0gJ1snO1xuICBUb2tlbktpbmRbJ0JSQUNLRVRfUiddID0gJ10nO1xuICBUb2tlbktpbmRbJ0JSQUNFX0wnXSA9ICd7JztcbiAgVG9rZW5LaW5kWydQSVBFJ10gPSAnfCc7XG4gIFRva2VuS2luZFsnQlJBQ0VfUiddID0gJ30nO1xuICBUb2tlbktpbmRbJ05BTUUnXSA9ICdOYW1lJztcbiAgVG9rZW5LaW5kWydJTlQnXSA9ICdJbnQnO1xuICBUb2tlbktpbmRbJ0ZMT0FUJ10gPSAnRmxvYXQnO1xuICBUb2tlbktpbmRbJ1NUUklORyddID0gJ1N0cmluZyc7XG4gIFRva2VuS2luZFsnQkxPQ0tfU1RSSU5HJ10gPSAnQmxvY2tTdHJpbmcnO1xuICBUb2tlbktpbmRbJ0NPTU1FTlQnXSA9ICdDb21tZW50Jztcbn0pKFRva2VuS2luZCB8fCAoVG9rZW5LaW5kID0ge30pKTtcblxuZXhwb3J0IHsgVG9rZW5LaW5kIH07XG4vKipcbiAqIFRoZSBlbnVtIHR5cGUgcmVwcmVzZW50aW5nIHRoZSB0b2tlbiBraW5kcyB2YWx1ZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgVG9rZW5LaW5kYC4gV2lsbCBiZSByZW1vdmUgaW4gdjE3LlxuICovXG4iLCAiaW1wb3J0IHsgc3ludGF4RXJyb3IgfSBmcm9tICcuLi9lcnJvci9zeW50YXhFcnJvci5tanMnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuL2FzdC5tanMnO1xuaW1wb3J0IHsgZGVkZW50QmxvY2tTdHJpbmdMaW5lcyB9IGZyb20gJy4vYmxvY2tTdHJpbmcubWpzJztcbmltcG9ydCB7IGlzRGlnaXQsIGlzTmFtZUNvbnRpbnVlLCBpc05hbWVTdGFydCB9IGZyb20gJy4vY2hhcmFjdGVyQ2xhc3Nlcy5tanMnO1xuaW1wb3J0IHsgVG9rZW5LaW5kIH0gZnJvbSAnLi90b2tlbktpbmQubWpzJztcbi8qKlxuICogR2l2ZW4gYSBTb3VyY2Ugb2JqZWN0LCBjcmVhdGVzIGEgTGV4ZXIgZm9yIHRoYXQgc291cmNlLlxuICogQSBMZXhlciBpcyBhIHN0YXRlZnVsIHN0cmVhbSBnZW5lcmF0b3IgaW4gdGhhdCBldmVyeSB0aW1lXG4gKiBpdCBpcyBhZHZhbmNlZCwgaXQgcmV0dXJucyB0aGUgbmV4dCB0b2tlbiBpbiB0aGUgU291cmNlLiBBc3N1bWluZyB0aGVcbiAqIHNvdXJjZSBsZXhlcywgdGhlIGZpbmFsIFRva2VuIGVtaXR0ZWQgYnkgdGhlIGxleGVyIHdpbGwgYmUgb2Yga2luZFxuICogRU9GLCBhZnRlciB3aGljaCB0aGUgbGV4ZXIgd2lsbCByZXBlYXRlZGx5IHJldHVybiB0aGUgc2FtZSBFT0YgdG9rZW5cbiAqIHdoZW5ldmVyIGNhbGxlZC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgTGV4ZXIge1xuICAvKipcbiAgICogVGhlIHByZXZpb3VzbHkgZm9jdXNlZCBub24taWdub3JlZCB0b2tlbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgZm9jdXNlZCBub24taWdub3JlZCB0b2tlbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSAoMS1pbmRleGVkKSBsaW5lIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyIG9mZnNldCBhdCB3aGljaCB0aGUgY3VycmVudCBsaW5lIGJlZ2lucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIGNvbnN0IHN0YXJ0T2ZGaWxlVG9rZW4gPSBuZXcgVG9rZW4oVG9rZW5LaW5kLlNPRiwgMCwgMCwgMCwgMCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5sYXN0VG9rZW4gPSBzdGFydE9mRmlsZVRva2VuO1xuICAgIHRoaXMudG9rZW4gPSBzdGFydE9mRmlsZVRva2VuO1xuICAgIHRoaXMubGluZSA9IDE7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnTGV4ZXInO1xuICB9XG4gIC8qKlxuICAgKiBBZHZhbmNlcyB0aGUgdG9rZW4gc3RyZWFtIHRvIHRoZSBuZXh0IG5vbi1pZ25vcmVkIHRva2VuLlxuICAgKi9cblxuICBhZHZhbmNlKCkge1xuICAgIHRoaXMubGFzdFRva2VuID0gdGhpcy50b2tlbjtcbiAgICBjb25zdCB0b2tlbiA9ICh0aGlzLnRva2VuID0gdGhpcy5sb29rYWhlYWQoKSk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBhaGVhZCBhbmQgcmV0dXJucyB0aGUgbmV4dCBub24taWdub3JlZCB0b2tlbiwgYnV0IGRvZXMgbm90IGNoYW5nZVxuICAgKiB0aGUgc3RhdGUgb2YgTGV4ZXIuXG4gICAqL1xuXG4gIGxvb2thaGVhZCgpIHtcbiAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgIT09IFRva2VuS2luZC5FT0YpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRva2VuLm5leHQpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2VuLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB0b2tlbiBhbmQgZm9ybSBhIGxpbmsgaW4gdGhlIHRva2VuIGxpbmtlZC1saXN0LlxuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHJlYWROZXh0VG9rZW4odGhpcywgdG9rZW4uZW5kKTsgLy8gQHRzLWV4cGVjdC1lcnJvciBuZXh0IGlzIG9ubHkgbXV0YWJsZSBkdXJpbmcgcGFyc2luZy5cblxuICAgICAgICAgIHRva2VuLm5leHQgPSBuZXh0VG9rZW47IC8vIEB0cy1leHBlY3QtZXJyb3IgcHJldiBpcyBvbmx5IG11dGFibGUgZHVyaW5nIHBhcnNpbmcuXG5cbiAgICAgICAgICBuZXh0VG9rZW4ucHJldiA9IHRva2VuO1xuICAgICAgICAgIHRva2VuID0gbmV4dFRva2VuO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0b2tlbi5raW5kID09PSBUb2tlbktpbmQuQ09NTUVOVCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1B1bmN0dWF0b3JUb2tlbktpbmQoa2luZCkge1xuICByZXR1cm4gKFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5CQU5HIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLkRPTExBUiB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5BTVAgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuUEFSRU5fTCB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5QQVJFTl9SIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLlNQUkVBRCB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5DT0xPTiB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5FUVVBTFMgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQVQgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQlJBQ0tFVF9MIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNLRVRfUiB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5CUkFDRV9MIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLlBJUEUgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQlJBQ0VfUlxuICApO1xufVxuLyoqXG4gKiBBIFVuaWNvZGUgc2NhbGFyIHZhbHVlIGlzIGFueSBVbmljb2RlIGNvZGUgcG9pbnQgZXhjZXB0IHN1cnJvZ2F0ZSBjb2RlXG4gKiBwb2ludHMuIEluIG90aGVyIHdvcmRzLCB0aGUgaW5jbHVzaXZlIHJhbmdlcyBvZiB2YWx1ZXMgMHgwMDAwIHRvIDB4RDdGRiBhbmRcbiAqIDB4RTAwMCB0byAweDEwRkZGRi5cbiAqXG4gKiBTb3VyY2VDaGFyYWN0ZXIgOjpcbiAqICAgLSBcIkFueSBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG4gKi9cblxuZnVuY3Rpb24gaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDB4MDAwMCAmJiBjb2RlIDw9IDB4ZDdmZikgfHwgKGNvZGUgPj0gMHhlMDAwICYmIGNvZGUgPD0gMHgxMGZmZmYpXG4gICk7XG59XG4vKipcbiAqIFRoZSBHcmFwaFFMIHNwZWNpZmljYXRpb24gZGVmaW5lcyBzb3VyY2UgdGV4dCBhcyBhIHNlcXVlbmNlIG9mIHVuaWNvZGUgc2NhbGFyXG4gKiB2YWx1ZXMgKHdoaWNoIFVuaWNvZGUgZGVmaW5lcyB0byBleGNsdWRlIHN1cnJvZ2F0ZSBjb2RlIHBvaW50cykuIEhvd2V2ZXJcbiAqIEphdmFTY3JpcHQgZGVmaW5lcyBzdHJpbmdzIGFzIGEgc2VxdWVuY2Ugb2YgVVRGLTE2IGNvZGUgdW5pdHMgd2hpY2ggbWF5XG4gKiBpbmNsdWRlIHN1cnJvZ2F0ZXMuIEEgc3Vycm9nYXRlIHBhaXIgaXMgYSB2YWxpZCBzb3VyY2UgY2hhcmFjdGVyIGFzIGl0XG4gKiBlbmNvZGVzIGEgc3VwcGxlbWVudGFyeSBjb2RlIHBvaW50IChhYm92ZSBVK0ZGRkYpLCBidXQgdW5wYWlyZWQgc3Vycm9nYXRlXG4gKiBjb2RlIHBvaW50cyBhcmUgbm90IHZhbGlkIHNvdXJjZSBjaGFyYWN0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBsb2NhdGlvbikge1xuICByZXR1cm4gKFxuICAgIGlzTGVhZGluZ1N1cnJvZ2F0ZShib2R5LmNoYXJDb2RlQXQobG9jYXRpb24pKSAmJlxuICAgIGlzVHJhaWxpbmdTdXJyb2dhdGUoYm9keS5jaGFyQ29kZUF0KGxvY2F0aW9uICsgMSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzTGVhZGluZ1N1cnJvZ2F0ZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZjtcbn1cblxuZnVuY3Rpb24gaXNUcmFpbGluZ1N1cnJvZ2F0ZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4ZGMwMCAmJiBjb2RlIDw9IDB4ZGZmZjtcbn1cbi8qKlxuICogUHJpbnRzIHRoZSBjb2RlIHBvaW50IChvciBlbmQgb2YgZmlsZSByZWZlcmVuY2UpIGF0IGEgZ2l2ZW4gbG9jYXRpb24gaW4gYVxuICogc291cmNlIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXMuXG4gKlxuICogUHJpbnRhYmxlIEFTQ0lJIGlzIHByaW50ZWQgcXVvdGVkLCB3aGlsZSBvdGhlciBwb2ludHMgYXJlIHByaW50ZWQgaW4gVW5pY29kZVxuICogY29kZSBwb2ludCBmb3JtIChpZS4gVSsxMjM0KS5cbiAqL1xuXG5mdW5jdGlvbiBwcmludENvZGVQb2ludEF0KGxleGVyLCBsb2NhdGlvbikge1xuICBjb25zdCBjb2RlID0gbGV4ZXIuc291cmNlLmJvZHkuY29kZVBvaW50QXQobG9jYXRpb24pO1xuXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gVG9rZW5LaW5kLkVPRjtcbiAgfSBlbHNlIGlmIChjb2RlID49IDB4MDAyMCAmJiBjb2RlIDw9IDB4MDA3ZSkge1xuICAgIC8vIFByaW50YWJsZSBBU0NJSVxuICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICByZXR1cm4gY2hhciA9PT0gJ1wiJyA/IFwiJ1xcXCInXCIgOiBgXCIke2NoYXJ9XCJgO1xuICB9IC8vIFVuaWNvZGUgY29kZSBwb2ludFxuXG4gIHJldHVybiAnVSsnICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCAnMCcpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0b2tlbiB3aXRoIGxpbmUgYW5kIGNvbHVtbiBsb2NhdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUb2tlbihsZXhlciwga2luZCwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcbiAgY29uc3QgbGluZSA9IGxleGVyLmxpbmU7XG4gIGNvbnN0IGNvbCA9IDEgKyBzdGFydCAtIGxleGVyLmxpbmVTdGFydDtcbiAgcmV0dXJuIG5ldyBUb2tlbihraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2wsIHZhbHVlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBzb3VyY2Ugc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICpcbiAqIFRoaXMgc2tpcHMgb3ZlciB3aGl0ZXNwYWNlIHVudGlsIGl0IGZpbmRzIHRoZSBuZXh0IGxleGFibGUgdG9rZW4sIHRoZW4gbGV4ZXNcbiAqIHB1bmN0dWF0b3JzIGltbWVkaWF0ZWx5IG9yIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vcmVcbiAqIGNvbXBsaWNhdGVkIHRva2Vucy5cbiAqL1xuXG5mdW5jdGlvbiByZWFkTmV4dFRva2VuKGxleGVyLCBzdGFydCkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQ7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pOyAvLyBTb3VyY2VDaGFyYWN0ZXJcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgLy8gSWdub3JlZCA6OlxuICAgICAgLy8gICAtIFVuaWNvZGVCT01cbiAgICAgIC8vICAgLSBXaGl0ZVNwYWNlXG4gICAgICAvLyAgIC0gTGluZVRlcm1pbmF0b3JcbiAgICAgIC8vICAgLSBDb21tZW50XG4gICAgICAvLyAgIC0gQ29tbWFcbiAgICAgIC8vXG4gICAgICAvLyBVbmljb2RlQk9NIDo6IFwiQnl0ZSBPcmRlciBNYXJrIChVK0ZFRkYpXCJcbiAgICAgIC8vXG4gICAgICAvLyBXaGl0ZVNwYWNlIDo6XG4gICAgICAvLyAgIC0gXCJIb3Jpem9udGFsIFRhYiAoVSswMDA5KVwiXG4gICAgICAvLyAgIC0gXCJTcGFjZSAoVSswMDIwKVwiXG4gICAgICAvL1xuICAgICAgLy8gQ29tbWEgOjogLFxuICAgICAgY2FzZSAweGZlZmY6IC8vIDxCT00+XG5cbiAgICAgIGNhc2UgMHgwMDA5OiAvLyBcXHRcblxuICAgICAgY2FzZSAweDAwMjA6IC8vIDxzcGFjZT5cblxuICAgICAgY2FzZSAweDAwMmM6XG4gICAgICAgIC8vICxcbiAgICAgICAgKytwb3NpdGlvbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyBMaW5lVGVybWluYXRvciA6OlxuICAgICAgLy8gICAtIFwiTmV3IExpbmUgKFUrMDAwQSlcIlxuICAgICAgLy8gICAtIFwiQ2FycmlhZ2UgUmV0dXJuIChVKzAwMEQpXCIgW2xvb2thaGVhZCAhPSBcIk5ldyBMaW5lIChVKzAwMEEpXCJdXG4gICAgICAvLyAgIC0gXCJDYXJyaWFnZSBSZXR1cm4gKFUrMDAwRClcIiBcIk5ldyBMaW5lIChVKzAwMEEpXCJcblxuICAgICAgY2FzZSAweDAwMGE6XG4gICAgICAgIC8vIFxcblxuICAgICAgICArK3Bvc2l0aW9uO1xuICAgICAgICArK2xleGVyLmxpbmU7XG4gICAgICAgIGxleGVyLmxpbmVTdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSAweDAwMGQ6XG4gICAgICAgIC8vIFxcclxuICAgICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDB4MDAwYSkge1xuICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKytwb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgICsrbGV4ZXIubGluZTtcbiAgICAgICAgbGV4ZXIubGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gQ29tbWVudFxuXG4gICAgICBjYXNlIDB4MDAyMzpcbiAgICAgICAgLy8gI1xuICAgICAgICByZXR1cm4gcmVhZENvbW1lbnQobGV4ZXIsIHBvc2l0aW9uKTtcbiAgICAgIC8vIFRva2VuIDo6XG4gICAgICAvLyAgIC0gUHVuY3R1YXRvclxuICAgICAgLy8gICAtIE5hbWVcbiAgICAgIC8vICAgLSBJbnRWYWx1ZVxuICAgICAgLy8gICAtIEZsb2F0VmFsdWVcbiAgICAgIC8vICAgLSBTdHJpbmdWYWx1ZVxuICAgICAgLy9cbiAgICAgIC8vIFB1bmN0dWF0b3IgOjogb25lIG9mICEgJCAmICggKSAuLi4gOiA9IEAgWyBdIHsgfCB9XG5cbiAgICAgIGNhc2UgMHgwMDIxOlxuICAgICAgICAvLyAhXG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkJBTkcsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDAyNDpcbiAgICAgICAgLy8gJFxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5ET0xMQVIsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDAyNjpcbiAgICAgICAgLy8gJlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5BTVAsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDAyODpcbiAgICAgICAgLy8gKFxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5QQVJFTl9MLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwMjk6XG4gICAgICAgIC8vIClcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuUEFSRU5fUiwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDJlOlxuICAgICAgICAvLyAuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDJlICYmXG4gICAgICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDB4MDAyZVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5TUFJFQUQsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgwMDNhOlxuICAgICAgICAvLyA6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkNPTE9OLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwM2Q6XG4gICAgICAgIC8vID1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuRVFVQUxTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwNDA6XG4gICAgICAgIC8vIEBcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQVQsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDA1YjpcbiAgICAgICAgLy8gW1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDS0VUX0wsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDA1ZDpcbiAgICAgICAgLy8gXVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDS0VUX1IsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDA3YjpcbiAgICAgICAgLy8ge1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDRV9MLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwN2M6XG4gICAgICAgIC8vIHxcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuUElQRSwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDdkOlxuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkJSQUNFX1IsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuICAgICAgLy8gU3RyaW5nVmFsdWVcblxuICAgICAgY2FzZSAweDAwMjI6XG4gICAgICAgIC8vIFwiXG4gICAgICAgIGlmIChcbiAgICAgICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDIyICYmXG4gICAgICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDB4MDAyMlxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2NrU3RyaW5nKGxleGVyLCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVhZFN0cmluZyhsZXhlciwgcG9zaXRpb24pO1xuICAgIH0gLy8gSW50VmFsdWUgfCBGbG9hdFZhbHVlIChEaWdpdCB8IC0pXG5cbiAgICBpZiAoaXNEaWdpdChjb2RlKSB8fCBjb2RlID09PSAweDAwMmQpIHtcbiAgICAgIHJldHVybiByZWFkTnVtYmVyKGxleGVyLCBwb3NpdGlvbiwgY29kZSk7XG4gICAgfSAvLyBOYW1lXG5cbiAgICBpZiAoaXNOYW1lU3RhcnQoY29kZSkpIHtcbiAgICAgIHJldHVybiByZWFkTmFtZShsZXhlciwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjb2RlID09PSAweDAwMjdcbiAgICAgICAgPyAnVW5leHBlY3RlZCBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyIChcXCcpLCBkaWQgeW91IG1lYW4gdG8gdXNlIGEgZG91YmxlIHF1b3RlIChcIik/J1xuICAgICAgICA6IGlzVW5pY29kZVNjYWxhclZhbHVlKGNvZGUpIHx8IGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBwb3NpdGlvbilcbiAgICAgICAgPyBgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7cHJpbnRDb2RlUG9pbnRBdChsZXhlciwgcG9zaXRpb24pfS5gXG4gICAgICAgIDogYEludmFsaWQgY2hhcmFjdGVyOiAke3ByaW50Q29kZVBvaW50QXQobGV4ZXIsIHBvc2l0aW9uKX0uYCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuRU9GLCBib2R5TGVuZ3RoLCBib2R5TGVuZ3RoKTtcbn1cbi8qKlxuICogUmVhZHMgYSBjb21tZW50IHRva2VuIGZyb20gdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIGBgYFxuICogQ29tbWVudCA6OiAjIENvbW1lbnRDaGFyKiBbbG9va2FoZWFkICE9IENvbW1lbnRDaGFyXVxuICpcbiAqIENvbW1lbnRDaGFyIDo6IFNvdXJjZUNoYXJhY3RlciBidXQgbm90IExpbmVUZXJtaW5hdG9yXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZWFkQ29tbWVudChsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcblxuICB3aGlsZSAocG9zaXRpb24gPCBib2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7IC8vIExpbmVUZXJtaW5hdG9yIChcXG4gfCBcXHIpXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDBhIHx8IGNvZGUgPT09IDB4MDAwZCkge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBTb3VyY2VDaGFyYWN0ZXJcblxuICAgIGlmIChpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSkge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUb2tlbihcbiAgICBsZXhlcixcbiAgICBUb2tlbktpbmQuQ09NTUVOVCxcbiAgICBzdGFydCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LnNsaWNlKHN0YXJ0ICsgMSwgcG9zaXRpb24pLFxuICApO1xufVxuLyoqXG4gKiBSZWFkcyBhIG51bWJlciB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZSwgZWl0aGVyIGEgRmxvYXRWYWx1ZSBvciBhbiBJbnRWYWx1ZVxuICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBGcmFjdGlvbmFsUGFydCBvciBFeHBvbmVudFBhcnQgaXMgZW5jb3VudGVyZWQuXG4gKlxuICogYGBgXG4gKiBJbnRWYWx1ZSA6OiBJbnRlZ2VyUGFydCBbbG9va2FoZWFkICE9IHtEaWdpdCwgYC5gLCBOYW1lU3RhcnR9XVxuICpcbiAqIEludGVnZXJQYXJ0IDo6XG4gKiAgIC0gTmVnYXRpdmVTaWduPyAwXG4gKiAgIC0gTmVnYXRpdmVTaWduPyBOb25aZXJvRGlnaXQgRGlnaXQqXG4gKlxuICogTmVnYXRpdmVTaWduIDo6IC1cbiAqXG4gKiBOb25aZXJvRGlnaXQgOjogRGlnaXQgYnV0IG5vdCBgMGBcbiAqXG4gKiBGbG9hdFZhbHVlIDo6XG4gKiAgIC0gSW50ZWdlclBhcnQgRnJhY3Rpb25hbFBhcnQgRXhwb25lbnRQYXJ0IFtsb29rYWhlYWQgIT0ge0RpZ2l0LCBgLmAsIE5hbWVTdGFydH1dXG4gKiAgIC0gSW50ZWdlclBhcnQgRnJhY3Rpb25hbFBhcnQgW2xvb2thaGVhZCAhPSB7RGlnaXQsIGAuYCwgTmFtZVN0YXJ0fV1cbiAqICAgLSBJbnRlZ2VyUGFydCBFeHBvbmVudFBhcnQgW2xvb2thaGVhZCAhPSB7RGlnaXQsIGAuYCwgTmFtZVN0YXJ0fV1cbiAqXG4gKiBGcmFjdGlvbmFsUGFydCA6OiAuIERpZ2l0K1xuICpcbiAqIEV4cG9uZW50UGFydCA6OiBFeHBvbmVudEluZGljYXRvciBTaWduPyBEaWdpdCtcbiAqXG4gKiBFeHBvbmVudEluZGljYXRvciA6OiBvbmUgb2YgYGVgIGBFYFxuICpcbiAqIFNpZ24gOjogb25lIG9mICsgLVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVhZE51bWJlcihsZXhlciwgc3RhcnQsIGZpcnN0Q29kZSkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0O1xuICBsZXQgY29kZSA9IGZpcnN0Q29kZTtcbiAgbGV0IGlzRmxvYXQgPSBmYWxzZTsgLy8gTmVnYXRpdmVTaWduICgtKVxuXG4gIGlmIChjb2RlID09PSAweDAwMmQpIHtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICB9IC8vIFplcm8gKDApXG5cbiAgaWYgKGNvZGUgPT09IDB4MDAzMCkge1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG5cbiAgICBpZiAoaXNEaWdpdChjb2RlKSkge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGBJbnZhbGlkIG51bWJlciwgdW5leHBlY3RlZCBkaWdpdCBhZnRlciAwOiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgICAgbGV4ZXIsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICl9LmAsXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbiA9IHJlYWREaWdpdHMobGV4ZXIsIHBvc2l0aW9uLCBjb2RlKTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgfSAvLyBGdWxsIHN0b3AgKC4pXG5cbiAgaWYgKGNvZGUgPT09IDB4MDAyZSkge1xuICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKGxleGVyLCBwb3NpdGlvbiwgY29kZSk7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIH0gLy8gRSBlXG5cbiAgaWYgKGNvZGUgPT09IDB4MDA0NSB8fCBjb2RlID09PSAweDAwNjUpIHtcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pOyAvLyArIC1cblxuICAgIGlmIChjb2RlID09PSAweDAwMmIgfHwgY29kZSA9PT0gMHgwMDJkKSB7XG4gICAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIH1cblxuICAgIHBvc2l0aW9uID0gcmVhZERpZ2l0cyhsZXhlciwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9IC8vIE51bWJlcnMgY2Fubm90IGJlIGZvbGxvd2VkIGJ5IC4gb3IgTmFtZVN0YXJ0XG5cbiAgaWYgKGNvZGUgPT09IDB4MDAyZSB8fCBpc05hbWVTdGFydChjb2RlKSkge1xuICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBgSW52YWxpZCBudW1iZXIsIGV4cGVjdGVkIGRpZ2l0IGJ1dCBnb3Q6ICR7cHJpbnRDb2RlUG9pbnRBdChcbiAgICAgICAgbGV4ZXIsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgKX0uYCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFxuICAgIGxleGVyLFxuICAgIGlzRmxvYXQgPyBUb2tlbktpbmQuRkxPQVQgOiBUb2tlbktpbmQuSU5ULFxuICAgIHN0YXJ0LFxuICAgIHBvc2l0aW9uLFxuICAgIGJvZHkuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uKSxcbiAgKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgYWZ0ZXIgcmVhZGluZyBvbmUgb3IgbW9yZSBkaWdpdHMuXG4gKi9cblxuZnVuY3Rpb24gcmVhZERpZ2l0cyhsZXhlciwgc3RhcnQsIGZpcnN0Q29kZSkge1xuICBpZiAoIWlzRGlnaXQoZmlyc3RDb2RlKSkge1xuICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgc3RhcnQsXG4gICAgICBgSW52YWxpZCBudW1iZXIsIGV4cGVjdGVkIGRpZ2l0IGJ1dCBnb3Q6ICR7cHJpbnRDb2RlUG9pbnRBdChcbiAgICAgICAgbGV4ZXIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgKX0uYCxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDE7IC8vICsxIHRvIHNraXAgZmlyc3QgZmlyc3RDb2RlXG5cbiAgd2hpbGUgKGlzRGlnaXQoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKSkpIHtcbiAgICArK3Bvc2l0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuLyoqXG4gKiBSZWFkcyBhIHNpbmdsZS1xdW90ZSBzdHJpbmcgdG9rZW4gZnJvbSB0aGUgc291cmNlIGZpbGUuXG4gKlxuICogYGBgXG4gKiBTdHJpbmdWYWx1ZSA6OlxuICogICAtIGBcIlwiYCBbbG9va2FoZWFkICE9IGBcImBdXG4gKiAgIC0gYFwiYCBTdHJpbmdDaGFyYWN0ZXIrIGBcImBcbiAqXG4gKiBTdHJpbmdDaGFyYWN0ZXIgOjpcbiAqICAgLSBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBgXCJgIG9yIGBcXGAgb3IgTGluZVRlcm1pbmF0b3JcbiAqICAgLSBgXFx1YCBFc2NhcGVkVW5pY29kZVxuICogICAtIGBcXGAgRXNjYXBlZENoYXJhY3RlclxuICpcbiAqIEVzY2FwZWRVbmljb2RlIDo6XG4gKiAgIC0gYHtgIEhleERpZ2l0KyBgfWBcbiAqICAgLSBIZXhEaWdpdCBIZXhEaWdpdCBIZXhEaWdpdCBIZXhEaWdpdFxuICpcbiAqIEVzY2FwZWRDaGFyYWN0ZXIgOjogb25lIG9mIGBcImAgYFxcYCBgL2AgYGJgIGBmYCBgbmAgYHJgIGB0YFxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVhZFN0cmluZyhsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcbiAgbGV0IGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgbGV0IHZhbHVlID0gJyc7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pOyAvLyBDbG9zaW5nIFF1b3RlIChcIilcblxuICAgIGlmIChjb2RlID09PSAweDAwMjIpIHtcbiAgICAgIHZhbHVlICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuU1RSSU5HLCBzdGFydCwgcG9zaXRpb24gKyAxLCB2YWx1ZSk7XG4gICAgfSAvLyBFc2NhcGUgU2VxdWVuY2UgKFxcKVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MDA1Yykge1xuICAgICAgdmFsdWUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICBjb25zdCBlc2NhcGUgPVxuICAgICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDc1IC8vIHVcbiAgICAgICAgICA/IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAweDAwN2IgLy8ge1xuICAgICAgICAgICAgPyByZWFkRXNjYXBlZFVuaWNvZGVWYXJpYWJsZVdpZHRoKGxleGVyLCBwb3NpdGlvbilcbiAgICAgICAgICAgIDogcmVhZEVzY2FwZWRVbmljb2RlRml4ZWRXaWR0aChsZXhlciwgcG9zaXRpb24pXG4gICAgICAgICAgOiByZWFkRXNjYXBlZENoYXJhY3RlcihsZXhlciwgcG9zaXRpb24pO1xuICAgICAgdmFsdWUgKz0gZXNjYXBlLnZhbHVlO1xuICAgICAgcG9zaXRpb24gKz0gZXNjYXBlLnNpemU7XG4gICAgICBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIExpbmVUZXJtaW5hdG9yIChcXG4gfCBcXHIpXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDBhIHx8IGNvZGUgPT09IDB4MDAwZCkge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBTb3VyY2VDaGFyYWN0ZXJcblxuICAgIGlmIChpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSkge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChib2R5LCBwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICBsZXhlci5zb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBgSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogJHtwcmludENvZGVQb2ludEF0KFxuICAgICAgICAgIGxleGVyLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICApfS5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBzeW50YXhFcnJvcihsZXhlci5zb3VyY2UsIHBvc2l0aW9uLCAnVW50ZXJtaW5hdGVkIHN0cmluZy4nKTtcbn0gLy8gVGhlIHN0cmluZyB2YWx1ZSBhbmQgbGV4ZWQgc2l6ZSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG5cbmZ1bmN0aW9uIHJlYWRFc2NhcGVkVW5pY29kZVZhcmlhYmxlV2lkdGgobGV4ZXIsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgbGV0IHBvaW50ID0gMDtcbiAgbGV0IHNpemUgPSAzOyAvLyBDYW5ub3QgYmUgbGFyZ2VyIHRoYW4gMTIgY2hhcnMgKFxcdXswMDAwMDAwMH0pLlxuXG4gIHdoaWxlIChzaXplIDwgMTIpIHtcbiAgICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgc2l6ZSsrKTsgLy8gQ2xvc2luZyBCcmFjZSAofSlcblxuICAgIGlmIChjb2RlID09PSAweDAwN2QpIHtcbiAgICAgIC8vIE11c3QgYmUgYXQgbGVhc3QgNSBjaGFycyAoXFx1ezB9KSBhbmQgZW5jb2RlIGEgVW5pY29kZSBzY2FsYXIgdmFsdWUuXG4gICAgICBpZiAoc2l6ZSA8IDUgfHwgIWlzVW5pY29kZVNjYWxhclZhbHVlKHBvaW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ29kZVBvaW50KHBvaW50KSxcbiAgICAgICAgc2l6ZSxcbiAgICAgIH07XG4gICAgfSAvLyBBcHBlbmQgdGhpcyBoZXggZGlnaXQgdG8gdGhlIGNvZGUgcG9pbnQuXG5cbiAgICBwb2ludCA9IChwb2ludCA8PCA0KSB8IHJlYWRIZXhEaWdpdChjb2RlKTtcblxuICAgIGlmIChwb2ludCA8IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IHN5bnRheEVycm9yKFxuICAgIGxleGVyLnNvdXJjZSxcbiAgICBwb3NpdGlvbixcbiAgICBgSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZTogXCIke2JvZHkuc2xpY2UoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uICsgc2l6ZSxcbiAgICApfVwiLmAsXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlYWRFc2NhcGVkVW5pY29kZUZpeGVkV2lkdGgobGV4ZXIsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgY29kZSA9IHJlYWQxNkJpdEhleENvZGUoYm9keSwgcG9zaXRpb24gKyAyKTtcblxuICBpZiAoaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpLFxuICAgICAgc2l6ZTogNixcbiAgICB9O1xuICB9IC8vIEdyYXBoUUwgYWxsb3dzIEpTT04tc3R5bGUgc3Vycm9nYXRlIHBhaXIgZXNjYXBlIHNlcXVlbmNlcywgYnV0IG9ubHkgd2hlblxuICAvLyBhIHZhbGlkIHBhaXIgaXMgZm9ybWVkLlxuXG4gIGlmIChpc0xlYWRpbmdTdXJyb2dhdGUoY29kZSkpIHtcbiAgICAvLyBcXHVcbiAgICBpZiAoXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyA2KSA9PT0gMHgwMDVjICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyA3KSA9PT0gMHgwMDc1XG4gICAgKSB7XG4gICAgICBjb25zdCB0cmFpbGluZ0NvZGUgPSByZWFkMTZCaXRIZXhDb2RlKGJvZHksIHBvc2l0aW9uICsgOCk7XG5cbiAgICAgIGlmIChpc1RyYWlsaW5nU3Vycm9nYXRlKHRyYWlsaW5nQ29kZSkpIHtcbiAgICAgICAgLy8gSmF2YVNjcmlwdCBkZWZpbmVzIHN0cmluZ3MgYXMgYSBzZXF1ZW5jZSBvZiBVVEYtMTYgY29kZSB1bml0cyBhbmRcbiAgICAgICAgLy8gZW5jb2RlcyBVbmljb2RlIGNvZGUgcG9pbnRzIGFib3ZlIFUrRkZGRiB1c2luZyBhIHN1cnJvZ2F0ZSBwYWlyIG9mXG4gICAgICAgIC8vIGNvZGUgdW5pdHMuIFNpbmNlIHRoaXMgaXMgYSBzdXJyb2dhdGUgcGFpciBlc2NhcGUgc2VxdWVuY2UsIGp1c3RcbiAgICAgICAgLy8gaW5jbHVkZSBib3RoIGNvZGVzIGludG8gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHZhbHVlLiBIYWQgSmF2YVNjcmlwdFxuICAgICAgICAvLyBub3QgYmVlbiBpbnRlcm5hbGx5IGJhc2VkIG9uIFVURi0xNiwgdGhlbiB0aGlzIHN1cnJvZ2F0ZSBwYWlyIHdvdWxkXG4gICAgICAgIC8vIGJlIGRlY29kZWQgdG8gcmV0cmlldmUgdGhlIHN1cHBsZW1lbnRhcnkgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSwgdHJhaWxpbmdDb2RlKSxcbiAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICBsZXhlci5zb3VyY2UsXG4gICAgcG9zaXRpb24sXG4gICAgYEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2U6IFwiJHtib2R5LnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDYpfVwiLmAsXG4gICk7XG59XG4vKipcbiAqIFJlYWRzIGZvdXIgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyBhbmQgcmV0dXJucyB0aGUgcG9zaXRpdmUgaW50ZWdlciB0aGF0IDE2Yml0XG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50cy4gRm9yIGV4YW1wbGUsIFwiMDAwZlwiIHdpbGwgcmV0dXJuIDE1LCBhbmQgXCJkZWFkXCJcbiAqIHdpbGwgcmV0dXJuIDU3MDA1LlxuICpcbiAqIFJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIgaWYgYW55IGNoYXIgd2FzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIGRpZ2l0LlxuICovXG5cbmZ1bmN0aW9uIHJlYWQxNkJpdEhleENvZGUoYm9keSwgcG9zaXRpb24pIHtcbiAgLy8gcmVhZEhleERpZ2l0KCkgcmV0dXJucyAtMSBvbiBlcnJvci4gT1JpbmcgYSBuZWdhdGl2ZSB2YWx1ZSB3aXRoIGFueSBvdGhlclxuICAvLyB2YWx1ZSBhbHdheXMgcHJvZHVjZXMgYSBuZWdhdGl2ZSB2YWx1ZS5cbiAgcmV0dXJuIChcbiAgICAocmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpIDw8IDEyKSB8XG4gICAgKHJlYWRIZXhEaWdpdChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPDwgOCkgfFxuICAgIChyZWFkSGV4RGlnaXQoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikpIDw8IDQpIHxcbiAgICByZWFkSGV4RGlnaXQoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMykpXG4gICk7XG59XG4vKipcbiAqIFJlYWRzIGEgaGV4YWRlY2ltYWwgY2hhcmFjdGVyIGFuZCByZXR1cm5zIGl0cyBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlICgwLTE1KS5cbiAqXG4gKiAnMCcgYmVjb21lcyAwLCAnOScgYmVjb21lcyA5XG4gKiAnQScgYmVjb21lcyAxMCwgJ0YnIGJlY29tZXMgMTVcbiAqICdhJyBiZWNvbWVzIDEwLCAnZicgYmVjb21lcyAxNVxuICpcbiAqIFJldHVybnMgLTEgaWYgdGhlIHByb3ZpZGVkIGNoYXJhY3RlciBjb2RlIHdhcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBkaWdpdC5cbiAqXG4gKiBIZXhEaWdpdCA6OiBvbmUgb2ZcbiAqICAgLSBgMGAgYDFgIGAyYCBgM2AgYDRgIGA1YCBgNmAgYDdgIGA4YCBgOWBcbiAqICAgLSBgQWAgYEJgIGBDYCBgRGAgYEVgIGBGYFxuICogICAtIGBhYCBgYmAgYGNgIGBkYCBgZWAgYGZgXG4gKi9cblxuZnVuY3Rpb24gcmVhZEhleERpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5IC8vIDAtOVxuICAgID8gY29kZSAtIDB4MDAzMFxuICAgIDogY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNDYgLy8gQS1GXG4gICAgPyBjb2RlIC0gMHgwMDM3XG4gICAgOiBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA2NiAvLyBhLWZcbiAgICA/IGNvZGUgLSAweDAwNTdcbiAgICA6IC0xO1xufVxuLyoqXG4gKiB8IEVzY2FwZWQgQ2hhcmFjdGVyIHwgQ29kZSBQb2ludCB8IENoYXJhY3RlciBOYW1lICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYFwiYCAgICAgICAgICAgICAgIHwgVSswMDIyICAgICB8IGRvdWJsZSBxdW90ZSAgICAgICAgICAgICAgICAgfFxuICogfCBgXFxgICAgICAgICAgICAgICAgfCBVKzAwNUMgICAgIHwgcmV2ZXJzZSBzb2xpZHVzIChiYWNrIHNsYXNoKSB8XG4gKiB8IGAvYCAgICAgICAgICAgICAgIHwgVSswMDJGICAgICB8IHNvbGlkdXMgKGZvcndhcmQgc2xhc2gpICAgICAgfFxuICogfCBgYmAgICAgICAgICAgICAgICB8IFUrMDAwOCAgICAgfCBiYWNrc3BhY2UgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYGZgICAgICAgICAgICAgICAgfCBVKzAwMEMgICAgIHwgZm9ybSBmZWVkICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGBuYCAgICAgICAgICAgICAgIHwgVSswMDBBICAgICB8IGxpbmUgZmVlZCAobmV3IGxpbmUpICAgICAgICAgfFxuICogfCBgcmAgICAgICAgICAgICAgICB8IFUrMDAwRCAgICAgfCBjYXJyaWFnZSByZXR1cm4gICAgICAgICAgICAgIHxcbiAqIHwgYHRgICAgICAgICAgICAgICAgfCBVKzAwMDkgICAgIHwgaG9yaXpvbnRhbCB0YWIgICAgICAgICAgICAgICB8XG4gKi9cblxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyYWN0ZXIobGV4ZXIsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHgwMDIyOlxuICAgICAgLy8gXCJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDAyMicsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuXG4gICAgY2FzZSAweDAwNWM6XG4gICAgICAvLyBcXFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6ICdcXHUwMDVjJyxcbiAgICAgICAgc2l6ZTogMixcbiAgICAgIH07XG5cbiAgICBjYXNlIDB4MDAyZjpcbiAgICAgIC8vIC9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDAyZicsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuXG4gICAgY2FzZSAweDAwNjI6XG4gICAgICAvLyBiXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1xcdTAwMDgnLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgfTtcblxuICAgIGNhc2UgMHgwMDY2OlxuICAgICAgLy8gZlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6ICdcXHUwMDBjJyxcbiAgICAgICAgc2l6ZTogMixcbiAgICAgIH07XG5cbiAgICBjYXNlIDB4MDA2ZTpcbiAgICAgIC8vIG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDAwYScsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuXG4gICAgY2FzZSAweDAwNzI6XG4gICAgICAvLyByXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1xcdTAwMGQnLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgfTtcblxuICAgIGNhc2UgMHgwMDc0OlxuICAgICAgLy8gdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6ICdcXHUwMDA5JyxcbiAgICAgICAgc2l6ZTogMixcbiAgICAgIH07XG4gIH1cblxuICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICBsZXhlci5zb3VyY2UsXG4gICAgcG9zaXRpb24sXG4gICAgYEludmFsaWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZTogXCIke2JvZHkuc2xpY2UoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uICsgMixcbiAgICApfVwiLmAsXG4gICk7XG59XG4vKipcbiAqIFJlYWRzIGEgYmxvY2sgc3RyaW5nIHRva2VuIGZyb20gdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIGBgYFxuICogU3RyaW5nVmFsdWUgOjpcbiAqICAgLSBgXCJcIlwiYCBCbG9ja1N0cmluZ0NoYXJhY3RlciogYFwiXCJcImBcbiAqXG4gKiBCbG9ja1N0cmluZ0NoYXJhY3RlciA6OlxuICogICAtIFNvdXJjZUNoYXJhY3RlciBidXQgbm90IGBcIlwiXCJgIG9yIGBcXFwiXCJcImBcbiAqICAgLSBgXFxcIlwiXCJgXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZWFkQmxvY2tTdHJpbmcobGV4ZXIsIHN0YXJ0KSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICBsZXQgbGluZVN0YXJ0ID0gbGV4ZXIubGluZVN0YXJ0O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDM7XG4gIGxldCBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gIGxldCBjdXJyZW50TGluZSA9ICcnO1xuICBjb25zdCBibG9ja0xpbmVzID0gW107XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pOyAvLyBDbG9zaW5nIFRyaXBsZS1RdW90ZSAoXCJcIlwiKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gMHgwMDIyICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDIyICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAyKSA9PT0gMHgwMDIyXG4gICAgKSB7XG4gICAgICBjdXJyZW50TGluZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIGJsb2NrTGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVRva2VuKFxuICAgICAgICBsZXhlcixcbiAgICAgICAgVG9rZW5LaW5kLkJMT0NLX1NUUklORyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBvc2l0aW9uICsgMywgLy8gUmV0dXJuIGEgc3RyaW5nIG9mIHRoZSBsaW5lcyBqb2luZWQgd2l0aCBVKzAwMEEuXG4gICAgICAgIGRlZGVudEJsb2NrU3RyaW5nTGluZXMoYmxvY2tMaW5lcykuam9pbignXFxuJyksXG4gICAgICApO1xuICAgICAgbGV4ZXIubGluZSArPSBibG9ja0xpbmVzLmxlbmd0aCAtIDE7XG4gICAgICBsZXhlci5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSAvLyBFc2NhcGVkIFRyaXBsZS1RdW90ZSAoXFxcIlwiXCIpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSAweDAwNWMgJiZcbiAgICAgIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAweDAwMjIgJiZcbiAgICAgIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAweDAwMjIgJiZcbiAgICAgIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDMpID09PSAweDAwMjJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRMaW5lICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgY2h1bmtTdGFydCA9IHBvc2l0aW9uICsgMTsgLy8gc2tpcCBvbmx5IHNsYXNoXG5cbiAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIExpbmVUZXJtaW5hdG9yXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDBhIHx8IGNvZGUgPT09IDB4MDAwZCkge1xuICAgICAgY3VycmVudExpbmUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICBibG9ja0xpbmVzLnB1c2goY3VycmVudExpbmUpO1xuXG4gICAgICBpZiAoY29kZSA9PT0gMHgwMDBkICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAweDAwMGEpIHtcbiAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMaW5lID0gJyc7XG4gICAgICBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gICAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gU291cmNlQ2hhcmFjdGVyXG5cbiAgICBpZiAoaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkpIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgcG9zaXRpb24pKSB7XG4gICAgICBwb3NpdGlvbiArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgYEludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6ICR7cHJpbnRDb2RlUG9pbnRBdChcbiAgICAgICAgICBsZXhlcixcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgKX0uYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3IobGV4ZXIuc291cmNlLCBwb3NpdGlvbiwgJ1VudGVybWluYXRlZCBzdHJpbmcuJyk7XG59XG4vKipcbiAqIFJlYWRzIGFuIGFscGhhbnVtZXJpYyArIHVuZGVyc2NvcmUgbmFtZSBmcm9tIHRoZSBzb3VyY2UuXG4gKlxuICogYGBgXG4gKiBOYW1lIDo6XG4gKiAgIC0gTmFtZVN0YXJ0IE5hbWVDb250aW51ZSogW2xvb2thaGVhZCAhPSBOYW1lQ29udGludWVdXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZWFkTmFtZShsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0ICsgMTtcblxuICB3aGlsZSAocG9zaXRpb24gPCBib2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG5cbiAgICBpZiAoaXNOYW1lQ29udGludWUoY29kZSkpIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUb2tlbihcbiAgICBsZXhlcixcbiAgICBUb2tlbktpbmQuTkFNRSxcbiAgICBzdGFydCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbiksXG4gICk7XG59XG4iLCAiY29uc3QgTUFYX0FSUkFZX0xFTkdUSCA9IDEwO1xuY29uc3QgTUFYX1JFQ1VSU0lWRV9ERVBUSCA9IDI7XG4vKipcbiAqIFVzZWQgdG8gcHJpbnQgdmFsdWVzIGluIGVycm9yIG1lc3NhZ2VzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlKSB7XG4gIHJldHVybiBmb3JtYXRWYWx1ZSh2YWx1ZSwgW10pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcykge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgPyBgW2Z1bmN0aW9uICR7dmFsdWUubmFtZX1dYCA6ICdbZnVuY3Rpb25dJztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBwcmV2aW91c2x5U2VlblZhbHVlcykge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzbHlTZWVuVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gIH1cblxuICBjb25zdCBzZWVuVmFsdWVzID0gWy4uLnByZXZpb3VzbHlTZWVuVmFsdWVzLCB2YWx1ZV07XG5cbiAgaWYgKGlzSlNPTmFibGUodmFsdWUpKSB7XG4gICAgY29uc3QganNvblZhbHVlID0gdmFsdWUudG9KU09OKCk7IC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cblxuICAgIGlmIChqc29uVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGpzb25WYWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBqc29uVmFsdWVcbiAgICAgICAgOiBmb3JtYXRWYWx1ZShqc29uVmFsdWUsIHNlZW5WYWx1ZXMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRBcnJheSh2YWx1ZSwgc2VlblZhbHVlcyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0T2JqZWN0KHZhbHVlLCBzZWVuVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gaXNKU09OYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG9iamVjdCwgc2VlblZhbHVlcykge1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqZWN0KTtcblxuICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3t9JztcbiAgfVxuXG4gIGlmIChzZWVuVmFsdWVzLmxlbmd0aCA+IE1BWF9SRUNVUlNJVkVfREVQVEgpIHtcbiAgICByZXR1cm4gJ1snICsgZ2V0T2JqZWN0VGFnKG9iamVjdCkgKyAnXSc7XG4gIH1cblxuICBjb25zdCBwcm9wZXJ0aWVzID0gZW50cmllcy5tYXAoXG4gICAgKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzogJyArIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKSxcbiAgKTtcbiAgcmV0dXJuICd7ICcgKyBwcm9wZXJ0aWVzLmpvaW4oJywgJykgKyAnIH0nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdbXSc7XG4gIH1cblxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuICdbQXJyYXldJztcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKE1BWF9BUlJBWV9MRU5HVEgsIGFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aCAtIGxlbjtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaXRlbXMucHVzaChmb3JtYXRWYWx1ZShhcnJheVtpXSwgc2VlblZhbHVlcykpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA9PT0gMSkge1xuICAgIGl0ZW1zLnB1c2goJy4uLiAxIG1vcmUgaXRlbScpO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDEpIHtcbiAgICBpdGVtcy5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbXNgKTtcbiAgfVxuXG4gIHJldHVybiAnWycgKyBpdGVtcy5qb2luKCcsICcpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RUYWcob2JqZWN0KSB7XG4gIGNvbnN0IHRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbChvYmplY3QpXG4gICAgLnJlcGxhY2UoL15cXFtvYmplY3QgLywgJycpXG4gICAgLnJlcGxhY2UoL10kLywgJycpO1xuXG4gIGlmICh0YWcgPT09ICdPYmplY3QnICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUgIT09ICcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFnO1xufVxuIiwgImltcG9ydCB7IGluc3BlY3QgfSBmcm9tICcuL2luc3BlY3QubWpzJztcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cblxuY29uc3QgaXNQcm9kdWN0aW9uID1cbiAgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuLyoqXG4gKiBBIHJlcGxhY2VtZW50IGZvciBpbnN0YW5jZW9mIHdoaWNoIGluY2x1ZGVzIGFuIGVycm9yIHdhcm5pbmcgd2hlbiBtdWx0aS1yZWFsbVxuICogY29uc3RydWN0b3JzIGFyZSBkZXRlY3RlZC5cbiAqIFNlZTogaHR0cHM6Ly9leHByZXNzanMuY29tL2VuL2FkdmFuY2VkL2Jlc3QtcHJhY3RpY2UtcGVyZm9ybWFuY2UuaHRtbCNzZXQtbm9kZV9lbnYtdG8tcHJvZHVjdGlvblxuICogU2VlOiBodHRwczovL3dlYnBhY2suanMub3JnL2d1aWRlcy9wcm9kdWN0aW9uL1xuICovXG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZU9mID1cbiAgLyogYzggaWdub3JlIG5leHQgNiAqL1xuICAvLyBGSVhNRTogaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxN1xuICBpc1Byb2R1Y3Rpb25cbiAgICA/IGZ1bmN0aW9uIGluc3RhbmNlT2YodmFsdWUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24gaW5zdGFuY2VPZih2YWx1ZSwgY29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF92YWx1ZSRjb25zdHJ1Y3RvcjtcblxuICAgICAgICAgIC8vIFByZWZlciBTeW1ib2wudG9TdHJpbmdUYWcgc2luY2UgaXQgaXMgaW1tdW5lIHRvIG1pbmlmaWNhdGlvbi5cbiAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgICAgICBjb25zdCB2YWx1ZUNsYXNzTmFtZSA9IC8vIFdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBjb25zdHJ1Y3RvcidzIG5hbWUgdG8gZGV0ZWN0IGNvbmZsaWN0cyB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIHRoaXMgbGlicmFyeS5cbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGJ1ZyBzZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzgwMDlcbiAgICAgICAgICAgICAgPyB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddXG4gICAgICAgICAgICAgIDogKF92YWx1ZSRjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIF92YWx1ZSRjb25zdHJ1Y3RvciA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgIDogX3ZhbHVlJGNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09PSB2YWx1ZUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IGluc3BlY3QodmFsdWUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlICR7Y2xhc3NOYW1lfSBcIiR7c3RyaW5naWZpZWRWYWx1ZX1cIiBmcm9tIGFub3RoZXIgbW9kdWxlIG9yIHJlYWxtLlxuXG5FbnN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiBcImdyYXBocWxcIiBpbiB0aGUgbm9kZV9tb2R1bGVzXG5kaXJlY3RvcnkuIElmIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBcImdyYXBocWxcIiBhcmUgdGhlIGRlcGVuZGVuY2llcyBvZiBvdGhlclxucmVsaWVkIG9uIG1vZHVsZXMsIHVzZSBcInJlc29sdXRpb25zXCIgdG8gZW5zdXJlIG9ubHkgb25lIHZlcnNpb24gaXMgaW5zdGFsbGVkLlxuXG5odHRwczovL3lhcm5wa2cuY29tL2VuL2RvY3Mvc2VsZWN0aXZlLXZlcnNpb24tcmVzb2x1dGlvbnNcblxuRHVwbGljYXRlIFwiZ3JhcGhxbFwiIG1vZHVsZXMgY2Fubm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZSBzaW5jZSBkaWZmZXJlbnRcbnZlcnNpb25zIG1heSBoYXZlIGRpZmZlcmVudCBjYXBhYmlsaXRpZXMgYW5kIGJlaGF2aW9yLiBUaGUgZGF0YSBmcm9tIG9uZVxudmVyc2lvbiB1c2VkIGluIHRoZSBmdW5jdGlvbiBmcm9tIGFub3RoZXIgY291bGQgcHJvZHVjZSBjb25mdXNpbmcgYW5kXG5zcHVyaW91cyByZXN1bHRzLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4iLCAiaW1wb3J0IHsgZGV2QXNzZXJ0IH0gZnJvbSAnLi4vanN1dGlscy9kZXZBc3NlcnQubWpzJztcbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tICcuLi9qc3V0aWxzL2luc3BlY3QubWpzJztcbmltcG9ydCB7IGluc3RhbmNlT2YgfSBmcm9tICcuLi9qc3V0aWxzL2luc3RhbmNlT2YubWpzJztcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIHNvdXJjZSBpbnB1dCB0byBHcmFwaFFMLiBUaGUgYG5hbWVgIGFuZCBgbG9jYXRpb25PZmZzZXRgIHBhcmFtZXRlcnMgYXJlXG4gKiBvcHRpb25hbCwgYnV0IHRoZXkgYXJlIHVzZWZ1bCBmb3IgY2xpZW50cyB3aG8gc3RvcmUgR3JhcGhRTCBkb2N1bWVudHMgaW4gc291cmNlIGZpbGVzLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBHcmFwaFFMIGlucHV0IHN0YXJ0cyBhdCBsaW5lIDQwIGluIGEgZmlsZSBuYW1lZCBgRm9vLmdyYXBocWxgLCBpdCBtaWdodFxuICogYmUgdXNlZnVsIGZvciBgbmFtZWAgdG8gYmUgYFwiRm9vLmdyYXBocWxcImAgYW5kIGxvY2F0aW9uIHRvIGJlIGB7IGxpbmU6IDQwLCBjb2x1bW46IDEgfWAuXG4gKiBUaGUgYGxpbmVgIGFuZCBgY29sdW1uYCBwcm9wZXJ0aWVzIGluIGBsb2NhdGlvbk9mZnNldGAgYXJlIDEtaW5kZXhlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGJvZHksXG4gICAgbmFtZSA9ICdHcmFwaFFMIHJlcXVlc3QnLFxuICAgIGxvY2F0aW9uT2Zmc2V0ID0ge1xuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMSxcbiAgICB9LFxuICApIHtcbiAgICB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgfHxcbiAgICAgIGRldkFzc2VydChmYWxzZSwgYEJvZHkgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7aW5zcGVjdChib2R5KX0uYCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYXRpb25PZmZzZXQgPSBsb2NhdGlvbk9mZnNldDtcbiAgICB0aGlzLmxvY2F0aW9uT2Zmc2V0LmxpbmUgPiAwIHx8XG4gICAgICBkZXZBc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnbGluZSBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuJyxcbiAgICAgICk7XG4gICAgdGhpcy5sb2NhdGlvbk9mZnNldC5jb2x1bW4gPiAwIHx8XG4gICAgICBkZXZBc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnY29sdW1uIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS4nLFxuICAgICAgKTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ1NvdXJjZSc7XG4gIH1cbn1cbi8qKlxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBTb3VyY2Ugb2JqZWN0LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NvdXJjZShzb3VyY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2Yoc291cmNlLCBTb3VyY2UpO1xufVxuIiwgImltcG9ydCB7IHN5bnRheEVycm9yIH0gZnJvbSAnLi4vZXJyb3Ivc3ludGF4RXJyb3IubWpzJztcbmltcG9ydCB7IExvY2F0aW9uLCBPcGVyYXRpb25UeXBlTm9kZSB9IGZyb20gJy4vYXN0Lm1qcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmVMb2NhdGlvbiB9IGZyb20gJy4vZGlyZWN0aXZlTG9jYXRpb24ubWpzJztcbmltcG9ydCB7IEtpbmQgfSBmcm9tICcuL2tpbmRzLm1qcyc7XG5pbXBvcnQgeyBpc1B1bmN0dWF0b3JUb2tlbktpbmQsIExleGVyIH0gZnJvbSAnLi9sZXhlci5tanMnO1xuaW1wb3J0IHsgaXNTb3VyY2UsIFNvdXJjZSB9IGZyb20gJy4vc291cmNlLm1qcyc7XG5pbXBvcnQgeyBUb2tlbktpbmQgfSBmcm9tICcuL3Rva2VuS2luZC5tanMnO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gY29udHJvbCBwYXJzZXIgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEdpdmVuIGEgR3JhcGhRTCBzb3VyY2UsIHBhcnNlcyBpdCBpbnRvIGEgRG9jdW1lbnQuXG4gKiBUaHJvd3MgR3JhcGhRTEVycm9yIGlmIGEgc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgY29uc3QgZG9jdW1lbnQgPSBwYXJzZXIucGFyc2VEb2N1bWVudCgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsICd0b2tlbkNvdW50Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBwYXJzZXIudG9rZW5Db3VudCxcbiAgfSk7XG4gIHJldHVybiBkb2N1bWVudDtcbn1cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgY29udGFpbmluZyBhIEdyYXBoUUwgdmFsdWUgKGV4LiBgWzQyXWApLCBwYXJzZSB0aGUgQVNUIGZvclxuICogdGhhdCB2YWx1ZS5cbiAqIFRocm93cyBHcmFwaFFMRXJyb3IgaWYgYSBzeW50YXggZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2l0aGluIHRvb2xzIHRoYXQgb3BlcmF0ZSB1cG9uIEdyYXBoUUwgVmFsdWVzIGRpcmVjdGx5IGFuZFxuICogaW4gaXNvbGF0aW9uIG9mIGNvbXBsZXRlIEdyYXBoUUwgZG9jdW1lbnRzLlxuICpcbiAqIENvbnNpZGVyIHByb3ZpZGluZyB0aGUgcmVzdWx0cyB0byB0aGUgdXRpbGl0eSBmdW5jdGlvbjogdmFsdWVGcm9tQVNUKCkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmFsdWUoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5TT0YpO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlci5wYXJzZVZhbHVlTGl0ZXJhbChmYWxzZSk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuRU9GKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHBhcnNlVmFsdWUoKSwgYnV0IHJhaXNlcyBhIHBhcnNlIGVycm9yIGlmIGl0IGVuY291bnRlcnMgYVxuICogdmFyaWFibGUuIFRoZSByZXR1cm4gdHlwZSB3aWxsIGJlIGEgY29uc3RhbnQgdmFsdWUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uc3RWYWx1ZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihzb3VyY2UsIG9wdGlvbnMpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLlNPRik7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VyLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5FT0YpO1xuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEdpdmVuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBHcmFwaFFMIFR5cGUgKGV4LiBgW0ludCFdYCksIHBhcnNlIHRoZSBBU1QgZm9yXG4gKiB0aGF0IHR5cGUuXG4gKiBUaHJvd3MgR3JhcGhRTEVycm9yIGlmIGEgc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdpdGhpbiB0b29scyB0aGF0IG9wZXJhdGUgdXBvbiBHcmFwaFFMIFR5cGVzIGRpcmVjdGx5IGFuZFxuICogaW4gaXNvbGF0aW9uIG9mIGNvbXBsZXRlIEdyYXBoUUwgZG9jdW1lbnRzLlxuICpcbiAqIENvbnNpZGVyIHByb3ZpZGluZyB0aGUgcmVzdWx0cyB0byB0aGUgdXRpbGl0eSBmdW5jdGlvbjogdHlwZUZyb21BU1QoKS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUeXBlKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuU09GKTtcbiAgY29uc3QgdHlwZSA9IHBhcnNlci5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5FT0YpO1xuICByZXR1cm4gdHlwZTtcbn1cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBleHBvcnRlZCBvbmx5IHRvIGFzc2lzdCBwZW9wbGUgaW4gaW1wbGVtZW50aW5nIHRoZWlyIG93biBwYXJzZXJzXG4gKiB3aXRob3V0IGR1cGxpY2F0aW5nIHRvbyBtdWNoIGNvZGUgYW5kIHNob3VsZCBiZSB1c2VkIG9ubHkgYXMgbGFzdCByZXNvcnQgZm9yIGNhc2VzXG4gKiBzdWNoIGFzIGV4cGVyaW1lbnRhbCBzeW50YXggb3IgaWYgY2VydGFpbiBmZWF0dXJlcyBjb3VsZCBub3QgYmUgY29udHJpYnV0ZWQgdXBzdHJlYW0uXG4gKlxuICogSXQgaXMgc3RpbGwgcGFydCBvZiB0aGUgaW50ZXJuYWwgQVBJIGFuZCBpcyB2ZXJzaW9uZWQsIHNvIGFueSBjaGFuZ2VzIHRvIGl0IGFyZSBuZXZlclxuICogY29uc2lkZXJlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IG11bHRpcGxlIHZlcnNpb25zIG9mIHRoZVxuICogbGlicmFyeSwgcGxlYXNlIHVzZSB0aGUgYHZlcnNpb25JbmZvYCB2YXJpYWJsZSBmb3IgdmVyc2lvbiBkZXRlY3Rpb24uXG4gKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc291cmNlT2JqID0gaXNTb3VyY2Uoc291cmNlKSA/IHNvdXJjZSA6IG5ldyBTb3VyY2Uoc291cmNlKTtcbiAgICB0aGlzLl9sZXhlciA9IG5ldyBMZXhlcihzb3VyY2VPYmopO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Rva2VuQ291bnRlciA9IDA7XG4gIH1cblxuICBnZXQgdG9rZW5Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW5Db3VudGVyO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG5hbWUgbGV4IHRva2VuIGludG8gYSBuYW1lIHBhcnNlIG5vZGUuXG4gICAqL1xuXG4gIHBhcnNlTmFtZSgpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLk5BTUUpO1xuICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuTkFNRSxcbiAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICB9KTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBEb2N1bWVudCBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBEb2N1bWVudCA6IERlZmluaXRpb24rXG4gICAqL1xuXG4gIHBhcnNlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbiwge1xuICAgICAga2luZDogS2luZC5ET0NVTUVOVCxcbiAgICAgIGRlZmluaXRpb25zOiB0aGlzLm1hbnkoXG4gICAgICAgIFRva2VuS2luZC5TT0YsXG4gICAgICAgIHRoaXMucGFyc2VEZWZpbml0aW9uLFxuICAgICAgICBUb2tlbktpbmQuRU9GLFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVmaW5pdGlvbiA6XG4gICAqICAgLSBFeGVjdXRhYmxlRGVmaW5pdGlvblxuICAgKiAgIC0gVHlwZVN5c3RlbURlZmluaXRpb25cbiAgICogICAtIFR5cGVTeXN0ZW1FeHRlbnNpb25cbiAgICpcbiAgICogRXhlY3V0YWJsZURlZmluaXRpb24gOlxuICAgKiAgIC0gT3BlcmF0aW9uRGVmaW5pdGlvblxuICAgKiAgIC0gRnJhZ21lbnREZWZpbml0aW9uXG4gICAqXG4gICAqIFR5cGVTeXN0ZW1EZWZpbml0aW9uIDpcbiAgICogICAtIFNjaGVtYURlZmluaXRpb25cbiAgICogICAtIFR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBEaXJlY3RpdmVEZWZpbml0aW9uXG4gICAqXG4gICAqIFR5cGVEZWZpbml0aW9uIDpcbiAgICogICAtIFNjYWxhclR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBPYmplY3RUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gSW50ZXJmYWNlVHlwZURlZmluaXRpb25cbiAgICogICAtIFVuaW9uVHlwZURlZmluaXRpb25cbiAgICogICAtIEVudW1UeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvblxuICAgKi9cblxuICBwYXJzZURlZmluaXRpb24oKSB7XG4gICAgaWYgKHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuICAgIH0gLy8gTWFueSBkZWZpbml0aW9ucyBiZWdpbiB3aXRoIGEgZGVzY3JpcHRpb24gYW5kIHJlcXVpcmUgYSBsb29rYWhlYWQuXG5cbiAgICBjb25zdCBoYXNEZXNjcmlwdGlvbiA9IHRoaXMucGVla0Rlc2NyaXB0aW9uKCk7XG4gICAgY29uc3Qga2V5d29yZFRva2VuID0gaGFzRGVzY3JpcHRpb25cbiAgICAgID8gdGhpcy5fbGV4ZXIubG9va2FoZWFkKClcbiAgICAgIDogdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAoa2V5d29yZFRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FKSB7XG4gICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdzY2hlbWEnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2FsYXJUeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZGlyZWN0aXZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURpcmVjdGl2ZURlZmluaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0Rlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgICAgICB0aGlzLl9sZXhlci50b2tlbi5zdGFydCxcbiAgICAgICAgICAnVW5leHBlY3RlZCBkZXNjcmlwdGlvbiwgZGVzY3JpcHRpb25zIGFyZSBzdXBwb3J0ZWQgb25seSBvbiB0eXBlIGRlZmluaXRpb25zLicsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoa2V5d29yZFRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2ZyYWdtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZyYWdtZW50RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2V4dGVuZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKGtleXdvcmRUb2tlbik7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgT3BlcmF0aW9ucyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBPcGVyYXRpb25EZWZpbml0aW9uIDpcbiAgICogIC0gU2VsZWN0aW9uU2V0XG4gICAqICAtIE9wZXJhdGlvblR5cGUgTmFtZT8gVmFyaWFibGVEZWZpbml0aW9ucz8gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0XG4gICAqL1xuXG4gIHBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAga2luZDogS2luZC5PUEVSQVRJT05fREVGSU5JVElPTixcbiAgICAgICAgb3BlcmF0aW9uOiBPcGVyYXRpb25UeXBlTm9kZS5RVUVSWSxcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiBbXSxcbiAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtcbiAgICBsZXQgbmFtZTtcblxuICAgIGlmICh0aGlzLnBlZWsoVG9rZW5LaW5kLk5BTUUpKSB7XG4gICAgICBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnM6IHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlcmF0aW9uVHlwZSA6IG9uZSBvZiBxdWVyeSBtdXRhdGlvbiBzdWJzY3JpcHRpb25cbiAgICovXG5cbiAgcGFyc2VPcGVyYXRpb25UeXBlKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvblRva2VuID0gdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuTkFNRSk7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvblRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgIHJldHVybiBPcGVyYXRpb25UeXBlTm9kZS5RVUVSWTtcblxuICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICByZXR1cm4gT3BlcmF0aW9uVHlwZU5vZGUuTVVUQVRJT047XG5cbiAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgIHJldHVybiBPcGVyYXRpb25UeXBlTm9kZS5TVUJTQ1JJUFRJT047XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG9wZXJhdGlvblRva2VuKTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGVEZWZpbml0aW9ucyA6ICggVmFyaWFibGVEZWZpbml0aW9uKyApXG4gICAqL1xuXG4gIHBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoXG4gICAgICBUb2tlbktpbmQuUEFSRU5fTCxcbiAgICAgIHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb24sXG4gICAgICBUb2tlbktpbmQuUEFSRU5fUixcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBWYXJpYWJsZURlZmluaXRpb24gOiBWYXJpYWJsZSA6IFR5cGUgRGVmYXVsdFZhbHVlPyBEaXJlY3RpdmVzW0NvbnN0XT9cbiAgICovXG5cbiAgcGFyc2VWYXJpYWJsZURlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbiwge1xuICAgICAga2luZDogS2luZC5WQVJJQUJMRV9ERUZJTklUSU9OLFxuICAgICAgdmFyaWFibGU6IHRoaXMucGFyc2VWYXJpYWJsZSgpLFxuICAgICAgdHlwZTogKHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKSwgdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKSksXG4gICAgICBkZWZhdWx0VmFsdWU6IHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuRVFVQUxTKVxuICAgICAgICA/IHRoaXMucGFyc2VDb25zdFZhbHVlTGl0ZXJhbCgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBWYXJpYWJsZSA6ICQgTmFtZVxuICAgKi9cblxuICBwYXJzZVZhcmlhYmxlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuRE9MTEFSKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLlZBUklBQkxFLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIFNlbGVjdGlvblNldCA6IHsgU2VsZWN0aW9uKyB9XG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZVNlbGVjdGlvblNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICBraW5kOiBLaW5kLlNFTEVDVElPTl9TRVQsXG4gICAgICBzZWxlY3Rpb25zOiB0aGlzLm1hbnkoXG4gICAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgICB0aGlzLnBhcnNlU2VsZWN0aW9uLFxuICAgICAgICBUb2tlbktpbmQuQlJBQ0VfUixcbiAgICAgICksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdGlvbiA6XG4gICAqICAgLSBGaWVsZFxuICAgKiAgIC0gRnJhZ21lbnRTcHJlYWRcbiAgICogICAtIElubGluZUZyYWdtZW50XG4gICAqL1xuXG4gIHBhcnNlU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBlZWsoVG9rZW5LaW5kLlNQUkVBRClcbiAgICAgID8gdGhpcy5wYXJzZUZyYWdtZW50KClcbiAgICAgIDogdGhpcy5wYXJzZUZpZWxkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpZWxkIDogQWxpYXM/IE5hbWUgQXJndW1lbnRzPyBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXQ/XG4gICAqXG4gICAqIEFsaWFzIDogTmFtZSA6XG4gICAqL1xuXG4gIHBhcnNlRmllbGQoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBuYW1lT3JBbGlhcyA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgbGV0IGFsaWFzO1xuICAgIGxldCBuYW1lO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQ09MT04pKSB7XG4gICAgICBhbGlhcyA9IG5hbWVPckFsaWFzO1xuICAgICAgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lT3JBbGlhcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkZJRUxELFxuICAgICAgYWxpYXMsXG4gICAgICBuYW1lLFxuICAgICAgYXJndW1lbnRzOiB0aGlzLnBhcnNlQXJndW1lbnRzKGZhbHNlKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wZWVrKFRva2VuS2luZC5CUkFDRV9MKVxuICAgICAgICA/IHRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXJndW1lbnRzW0NvbnN0XSA6ICggQXJndW1lbnRbP0NvbnN0XSsgKVxuICAgKi9cblxuICBwYXJzZUFyZ3VtZW50cyhpc0NvbnN0KSB7XG4gICAgY29uc3QgaXRlbSA9IGlzQ29uc3QgPyB0aGlzLnBhcnNlQ29uc3RBcmd1bWVudCA6IHRoaXMucGFyc2VBcmd1bWVudDtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoVG9rZW5LaW5kLlBBUkVOX0wsIGl0ZW0sIFRva2VuS2luZC5QQVJFTl9SKTtcbiAgfVxuICAvKipcbiAgICogQXJndW1lbnRbQ29uc3RdIDogTmFtZSA6IFZhbHVlWz9Db25zdF1cbiAgICovXG5cbiAgcGFyc2VBcmd1bWVudChpc0NvbnN0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkFSR1VNRU5ULFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKGlzQ29uc3QpLFxuICAgIH0pO1xuICB9XG5cbiAgcGFyc2VDb25zdEFyZ3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnQodHJ1ZSk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgRnJhZ21lbnRzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIENvcnJlc3BvbmRzIHRvIGJvdGggRnJhZ21lbnRTcHJlYWQgYW5kIElubGluZUZyYWdtZW50IGluIHRoZSBzcGVjLlxuICAgKlxuICAgKiBGcmFnbWVudFNwcmVhZCA6IC4uLiBGcmFnbWVudE5hbWUgRGlyZWN0aXZlcz9cbiAgICpcbiAgICogSW5saW5lRnJhZ21lbnQgOiAuLi4gVHlwZUNvbmRpdGlvbj8gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0XG4gICAqL1xuXG4gIHBhcnNlRnJhZ21lbnQoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5TUFJFQUQpO1xuICAgIGNvbnN0IGhhc1R5cGVDb25kaXRpb24gPSB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgnb24nKTtcblxuICAgIGlmICghaGFzVHlwZUNvbmRpdGlvbiAmJiB0aGlzLnBlZWsoVG9rZW5LaW5kLk5BTUUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgIGtpbmQ6IEtpbmQuRlJBR01FTlRfU1BSRUFELFxuICAgICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuSU5MSU5FX0ZSQUdNRU5ULFxuICAgICAgdHlwZUNvbmRpdGlvbjogaGFzVHlwZUNvbmRpdGlvbiA/IHRoaXMucGFyc2VOYW1lZFR5cGUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGcmFnbWVudERlZmluaXRpb24gOlxuICAgKiAgIC0gZnJhZ21lbnQgRnJhZ21lbnROYW1lIG9uIFR5cGVDb25kaXRpb24gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0XG4gICAqXG4gICAqIFR5cGVDb25kaXRpb24gOiBOYW1lZFR5cGVcbiAgICovXG5cbiAgcGFyc2VGcmFnbWVudERlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZyYWdtZW50Jyk7IC8vIExlZ2FjeSBzdXBwb3J0IGZvciBkZWZpbmluZyB2YXJpYWJsZXMgd2l0aGluIGZyYWdtZW50cyBjaGFuZ2VzXG4gICAgLy8gdGhlIGdyYW1tYXIgb2YgRnJhZ21lbnREZWZpbml0aW9uOlxuICAgIC8vICAgLSBmcmFnbWVudCBGcmFnbWVudE5hbWUgVmFyaWFibGVEZWZpbml0aW9ucz8gb24gVHlwZUNvbmRpdGlvbiBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXRcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmFsbG93TGVnYWN5RnJhZ21lbnRWYXJpYWJsZXMgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAga2luZDogS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnM6IHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksXG4gICAgICAgIHR5cGVDb25kaXRpb246ICh0aGlzLmV4cGVjdEtleXdvcmQoJ29uJyksIHRoaXMucGFyc2VOYW1lZFR5cGUoKSksXG4gICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkZSQUdNRU5UX0RFRklOSVRJT04sXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksXG4gICAgICB0eXBlQ29uZGl0aW9uOiAodGhpcy5leHBlY3RLZXl3b3JkKCdvbicpLCB0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZyYWdtZW50TmFtZSA6IE5hbWUgYnV0IG5vdCBgb25gXG4gICAqL1xuXG4gIHBhcnNlRnJhZ21lbnROYW1lKCkge1xuICAgIGlmICh0aGlzLl9sZXhlci50b2tlbi52YWx1ZSA9PT0gJ29uJykge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lKCk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgVmFsdWVzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIFZhbHVlW0NvbnN0XSA6XG4gICAqICAgLSBbfkNvbnN0XSBWYXJpYWJsZVxuICAgKiAgIC0gSW50VmFsdWVcbiAgICogICAtIEZsb2F0VmFsdWVcbiAgICogICAtIFN0cmluZ1ZhbHVlXG4gICAqICAgLSBCb29sZWFuVmFsdWVcbiAgICogICAtIE51bGxWYWx1ZVxuICAgKiAgIC0gRW51bVZhbHVlXG4gICAqICAgLSBMaXN0VmFsdWVbP0NvbnN0XVxuICAgKiAgIC0gT2JqZWN0VmFsdWVbP0NvbnN0XVxuICAgKlxuICAgKiBCb29sZWFuVmFsdWUgOiBvbmUgb2YgYHRydWVgIGBmYWxzZWBcbiAgICpcbiAgICogTnVsbFZhbHVlIDogYG51bGxgXG4gICAqXG4gICAqIEVudW1WYWx1ZSA6IE5hbWUgYnV0IG5vdCBgdHJ1ZWAsIGBmYWxzZWAgb3IgYG51bGxgXG4gICAqL1xuXG4gIHBhcnNlVmFsdWVMaXRlcmFsKGlzQ29uc3QpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgc3dpdGNoICh0b2tlbi5raW5kKSB7XG4gICAgICBjYXNlIFRva2VuS2luZC5CUkFDS0VUX0w6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChpc0NvbnN0KTtcblxuICAgICAgY2FzZSBUb2tlbktpbmQuQlJBQ0VfTDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3QoaXNDb25zdCk7XG5cbiAgICAgIGNhc2UgVG9rZW5LaW5kLklOVDpcbiAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuSU5ULFxuICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgVG9rZW5LaW5kLkZMT0FUOlxuICAgICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAga2luZDogS2luZC5GTE9BVCxcbiAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5TVFJJTkc6XG4gICAgICBjYXNlIFRva2VuS2luZC5CTE9DS19TVFJJTkc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5OQU1FOlxuICAgICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgICAgICAgICAga2luZDogS2luZC5CT09MRUFOLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgICAgICBraW5kOiBLaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgIGtpbmQ6IEtpbmQuTlVMTCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgICAgICAgICAga2luZDogS2luZC5FTlVNLFxuICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFRva2VuS2luZC5ET0xMQVI6XG4gICAgICAgIGlmIChpc0NvbnN0KSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuRE9MTEFSKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9sZXhlci50b2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSkge1xuICAgICAgICAgICAgY29uc3QgdmFyTmFtZSA9IHRoaXMuX2xleGVyLnRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgICAgICAgICAgdG9rZW4uc3RhcnQsXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIHZhcmlhYmxlIFwiJCR7dmFyTmFtZX1cIiBpbiBjb25zdGFudCB2YWx1ZS5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhcmlhYmxlKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodHJ1ZSk7XG4gIH1cblxuICBwYXJzZVN0cmluZ0xpdGVyYWwoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuU1RSSU5HLFxuICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgYmxvY2s6IHRva2VuLmtpbmQgPT09IFRva2VuS2luZC5CTE9DS19TVFJJTkcsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RWYWx1ZVtDb25zdF0gOlxuICAgKiAgIC0gWyBdXG4gICAqICAgLSBbIFZhbHVlWz9Db25zdF0rIF1cbiAgICovXG5cbiAgcGFyc2VMaXN0KGlzQ29uc3QpIHtcbiAgICBjb25zdCBpdGVtID0gKCkgPT4gdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KTtcblxuICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuTElTVCxcbiAgICAgIHZhbHVlczogdGhpcy5hbnkoVG9rZW5LaW5kLkJSQUNLRVRfTCwgaXRlbSwgVG9rZW5LaW5kLkJSQUNLRVRfUiksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBPYmplY3RWYWx1ZVtDb25zdF0gOlxuICAgKiAgIC0geyB9XG4gICAqICAgLSB7IE9iamVjdEZpZWxkWz9Db25zdF0rIH1cbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlT2JqZWN0KGlzQ29uc3QpIHtcbiAgICBjb25zdCBpdGVtID0gKCkgPT4gdGhpcy5wYXJzZU9iamVjdEZpZWxkKGlzQ29uc3QpO1xuXG4gICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbiwge1xuICAgICAga2luZDogS2luZC5PQkpFQ1QsXG4gICAgICBmaWVsZHM6IHRoaXMuYW55KFRva2VuS2luZC5CUkFDRV9MLCBpdGVtLCBUb2tlbktpbmQuQlJBQ0VfUiksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdEZpZWxkW0NvbnN0XSA6IE5hbWUgOiBWYWx1ZVs/Q29uc3RdXG4gICAqL1xuXG4gIHBhcnNlT2JqZWN0RmllbGQoaXNDb25zdCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNUX0ZJRUxELFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKGlzQ29uc3QpLFxuICAgIH0pO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIERpcmVjdGl2ZXMgc2VjdGlvbi5cblxuICAvKipcbiAgICogRGlyZWN0aXZlc1tDb25zdF0gOiBEaXJlY3RpdmVbP0NvbnN0XStcbiAgICovXG5cbiAgcGFyc2VEaXJlY3RpdmVzKGlzQ29uc3QpIHtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gW107XG5cbiAgICB3aGlsZSAodGhpcy5wZWVrKFRva2VuS2luZC5BVCkpIHtcbiAgICAgIGRpcmVjdGl2ZXMucHVzaCh0aGlzLnBhcnNlRGlyZWN0aXZlKGlzQ29uc3QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aXZlcztcbiAgfVxuXG4gIHBhcnNlQ29uc3REaXJlY3RpdmVzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIERpcmVjdGl2ZVtDb25zdF0gOiBAIE5hbWUgQXJndW1lbnRzWz9Db25zdF0/XG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZURpcmVjdGl2ZShpc0NvbnN0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5BVCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5ESVJFQ1RJVkUsXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgICAgYXJndW1lbnRzOiB0aGlzLnBhcnNlQXJndW1lbnRzKGlzQ29uc3QpLFxuICAgIH0pO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFR5cGVzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIFR5cGUgOlxuICAgKiAgIC0gTmFtZWRUeXBlXG4gICAqICAgLSBMaXN0VHlwZVxuICAgKiAgIC0gTm9uTnVsbFR5cGVcbiAgICovXG5cbiAgcGFyc2VUeXBlUmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgbGV0IHR5cGU7XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5CUkFDS0VUX0wpKSB7XG4gICAgICBjb25zdCBpbm5lclR5cGUgPSB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQlJBQ0tFVF9SKTtcbiAgICAgIHR5cGUgPSB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgICAga2luZDogS2luZC5MSVNUX1RZUEUsXG4gICAgICAgIHR5cGU6IGlubmVyVHlwZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5wYXJzZU5hbWVkVHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkJBTkcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgIGtpbmQ6IEtpbmQuTk9OX05VTExfVFlQRSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIC8qKlxuICAgKiBOYW1lZFR5cGUgOiBOYW1lXG4gICAqL1xuXG4gIHBhcnNlTmFtZWRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuTkFNRURfVFlQRSxcbiAgICAgIG5hbWU6IHRoaXMucGFyc2VOYW1lKCksXG4gICAgfSk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgVHlwZSBEZWZpbml0aW9uIHNlY3Rpb24uXG5cbiAgcGVla0Rlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBlZWsoVG9rZW5LaW5kLlNUUklORykgfHwgdGhpcy5wZWVrKFRva2VuS2luZC5CTE9DS19TVFJJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiA6IFN0cmluZ1ZhbHVlXG4gICAqL1xuXG4gIHBhcnNlRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKHRoaXMucGVla0Rlc2NyaXB0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIFNjaGVtYURlZmluaXRpb24gOiBEZXNjcmlwdGlvbj8gc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdPyB7IE9wZXJhdGlvblR5cGVEZWZpbml0aW9uKyB9XG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZVNjaGVtYURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NoZW1hJyk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlcyA9IHRoaXMubWFueShcbiAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLFxuICAgICAgVG9rZW5LaW5kLkJSQUNFX1IsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLlNDSEVNQV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgb3BlcmF0aW9uVHlwZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uIDogT3BlcmF0aW9uVHlwZSA6IE5hbWVkVHlwZVxuICAgKi9cblxuICBwYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMucGFyc2VOYW1lZFR5cGUoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLk9QRVJBVElPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBvcGVyYXRpb24sXG4gICAgICB0eXBlLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTY2FsYXJUeXBlRGVmaW5pdGlvbiA6IERlc2NyaXB0aW9uPyBzY2FsYXIgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT9cbiAgICovXG5cbiAgcGFyc2VTY2FsYXJUeXBlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzY2FsYXInKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuU0NBTEFSX1RZUEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdFR5cGVEZWZpbml0aW9uIDpcbiAgICogICBEZXNjcmlwdGlvbj9cbiAgICogICB0eXBlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdPyBGaWVsZHNEZWZpbml0aW9uP1xuICAgKi9cblxuICBwYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3R5cGUnKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBpbnRlcmZhY2VzID0gdGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNUX1RZUEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIGludGVyZmFjZXMsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgZmllbGRzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzSW50ZXJmYWNlcyA6XG4gICAqICAgLSBpbXBsZW1lbnRzIGAmYD8gTmFtZWRUeXBlXG4gICAqICAgLSBJbXBsZW1lbnRzSW50ZXJmYWNlcyAmIE5hbWVkVHlwZVxuICAgKi9cblxuICBwYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgnaW1wbGVtZW50cycpXG4gICAgICA/IHRoaXMuZGVsaW1pdGVkTWFueShUb2tlbktpbmQuQU1QLCB0aGlzLnBhcnNlTmFtZWRUeXBlKVxuICAgICAgOiBbXTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIEZpZWxkc0RlZmluaXRpb24gOiB7IEZpZWxkRGVmaW5pdGlvbisgfVxuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VGaWVsZHNEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShcbiAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgdGhpcy5wYXJzZUZpZWxkRGVmaW5pdGlvbixcbiAgICAgIFRva2VuS2luZC5CUkFDRV9SLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZpZWxkRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gTmFtZSBBcmd1bWVudHNEZWZpbml0aW9uPyA6IFR5cGUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuXG4gIHBhcnNlRmllbGREZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50RGVmcygpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuRklFTERfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgIHR5cGUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBcmd1bWVudHNEZWZpbml0aW9uIDogKCBJbnB1dFZhbHVlRGVmaW5pdGlvbisgKVxuICAgKi9cblxuICBwYXJzZUFyZ3VtZW50RGVmcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoXG4gICAgICBUb2tlbktpbmQuUEFSRU5fTCxcbiAgICAgIHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLFxuICAgICAgVG9rZW5LaW5kLlBBUkVOX1IsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRWYWx1ZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IE5hbWUgOiBUeXBlIERlZmF1bHRWYWx1ZT8gRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuXG4gIHBhcnNlSW5wdXRWYWx1ZURlZigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgIGxldCBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5FUVVBTFMpKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuSU5QVVRfVkFMVUVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gaW50ZXJmYWNlIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb24/XG4gICAqL1xuXG4gIHBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW50ZXJmYWNlJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5pb25UeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gVW5pb25NZW1iZXJUeXBlcz9cbiAgICovXG5cbiAgcGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3VuaW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCB0eXBlcyA9IHRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5VTklPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgdHlwZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW9uTWVtYmVyVHlwZXMgOlxuICAgKiAgIC0gPSBgfGA/IE5hbWVkVHlwZVxuICAgKiAgIC0gVW5pb25NZW1iZXJUeXBlcyB8IE5hbWVkVHlwZVxuICAgKi9cblxuICBwYXJzZVVuaW9uTWVtYmVyVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuRVFVQUxTKVxuICAgICAgPyB0aGlzLmRlbGltaXRlZE1hbnkoVG9rZW5LaW5kLlBJUEUsIHRoaXMucGFyc2VOYW1lZFR5cGUpXG4gICAgICA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBFbnVtVHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRW51bVZhbHVlc0RlZmluaXRpb24/XG4gICAqL1xuXG4gIHBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2VudW0nKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VFbnVtVmFsdWVzRGVmaW5pdGlvbigpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuRU5VTV9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgdmFsdWVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBgYGBcbiAgICogRW51bVZhbHVlc0RlZmluaXRpb24gOiB7IEVudW1WYWx1ZURlZmluaXRpb24rIH1cbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgVG9rZW5LaW5kLkJSQUNFX0wsXG4gICAgICB0aGlzLnBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbixcbiAgICAgIFRva2VuS2luZC5CUkFDRV9SLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEVudW1WYWx1ZURlZmluaXRpb24gOiBEZXNjcmlwdGlvbj8gRW51bVZhbHVlIERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cblxuICBwYXJzZUVudW1WYWx1ZURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlRW51bVZhbHVlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5FTlVNX1ZBTFVFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnVtVmFsdWUgOiBOYW1lIGJ1dCBub3QgYHRydWVgLCBgZmFsc2VgIG9yIGBudWxsYFxuICAgKi9cblxuICBwYXJzZUVudW1WYWx1ZU5hbWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fbGV4ZXIudG9rZW4udmFsdWUgPT09ICd0cnVlJyB8fFxuICAgICAgdGhpcy5fbGV4ZXIudG9rZW4udmFsdWUgPT09ICdmYWxzZScgfHxcbiAgICAgIHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSAnbnVsbCdcbiAgICApIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgIHRoaXMuX2xleGVyLnRva2VuLnN0YXJ0LFxuICAgICAgICBgJHtnZXRUb2tlbkRlc2MoXG4gICAgICAgICAgdGhpcy5fbGV4ZXIudG9rZW4sXG4gICAgICAgICl9IGlzIHJlc2VydmVkIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgYW4gZW51bSB2YWx1ZS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5hbWUoKTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gSW5wdXRGaWVsZHNEZWZpbml0aW9uP1xuICAgKi9cblxuICBwYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW5wdXQnKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgZmllbGRzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBgYGBcbiAgICogSW5wdXRGaWVsZHNEZWZpbml0aW9uIDogeyBJbnB1dFZhbHVlRGVmaW5pdGlvbisgfVxuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgVG9rZW5LaW5kLkJSQUNFX0wsXG4gICAgICB0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixcbiAgICAgIFRva2VuS2luZC5CUkFDRV9SLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFR5cGVTeXN0ZW1FeHRlbnNpb24gOlxuICAgKiAgIC0gU2NoZW1hRXh0ZW5zaW9uXG4gICAqICAgLSBUeXBlRXh0ZW5zaW9uXG4gICAqXG4gICAqIFR5cGVFeHRlbnNpb24gOlxuICAgKiAgIC0gU2NhbGFyVHlwZUV4dGVuc2lvblxuICAgKiAgIC0gT2JqZWN0VHlwZUV4dGVuc2lvblxuICAgKiAgIC0gSW50ZXJmYWNlVHlwZUV4dGVuc2lvblxuICAgKiAgIC0gVW5pb25UeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBFbnVtVHlwZUV4dGVuc2lvblxuICAgKiAgIC0gSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvblxuICAgKi9cblxuICBwYXJzZVR5cGVTeXN0ZW1FeHRlbnNpb24oKSB7XG4gICAgY29uc3Qga2V5d29yZFRva2VuID0gdGhpcy5fbGV4ZXIubG9va2FoZWFkKCk7XG5cbiAgICBpZiAoa2V5d29yZFRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FKSB7XG4gICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdzY2hlbWEnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoa2V5d29yZFRva2VuKTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIFNjaGVtYUV4dGVuc2lvbiA6XG4gICAqICAtIGV4dGVuZCBzY2hlbWEgRGlyZWN0aXZlc1tDb25zdF0/IHsgT3BlcmF0aW9uVHlwZURlZmluaXRpb24rIH1cbiAgICogIC0gZXh0ZW5kIHNjaGVtYSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VTY2hlbWFFeHRlbnNpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NoZW1hJyk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlcyA9IHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgVG9rZW5LaW5kLkJSQUNFX0wsXG4gICAgICB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24sXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfUixcbiAgICApO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIG9wZXJhdGlvblR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5TQ0hFTUFfRVhURU5TSU9OLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIG9wZXJhdGlvblR5cGVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTY2FsYXJUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBzY2FsYXIgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cblxuICBwYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NhbGFyJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5TQ0FMQVJfVFlQRV9FWFRFTlNJT04sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT2JqZWN0VHlwZUV4dGVuc2lvbiA6XG4gICAqICAtIGV4dGVuZCB0eXBlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdPyBGaWVsZHNEZWZpbml0aW9uXG4gICAqICAtIGV4dGVuZCB0eXBlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqICAtIGV4dGVuZCB0eXBlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXNcbiAgICovXG5cbiAgcGFyc2VPYmplY3RUeXBlRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3R5cGUnKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBpbnRlcmZhY2VzID0gdGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKFxuICAgICAgaW50ZXJmYWNlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmXG4gICAgICBmaWVsZHMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiA6XG4gICAqICAtIGV4dGVuZCBpbnRlcmZhY2UgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb25cbiAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKiAgLSBleHRlbmQgaW50ZXJmYWNlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXNcbiAgICovXG5cbiAgcGFyc2VJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ludGVyZmFjZScpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGludGVyZmFjZXMgPSB0aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoXG4gICAgICBpbnRlcmZhY2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGZpZWxkcy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZSxcbiAgICAgIGludGVyZmFjZXMsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgZmllbGRzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbmlvblR5cGVFeHRlbnNpb24gOlxuICAgKiAgIC0gZXh0ZW5kIHVuaW9uIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IFVuaW9uTWVtYmVyVHlwZXNcbiAgICogICAtIGV4dGVuZCB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuXG4gIHBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3VuaW9uJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCB0eXBlcyA9IHRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLlVOSU9OX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICB0eXBlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW51bVR5cGVFeHRlbnNpb24gOlxuICAgKiAgIC0gZXh0ZW5kIGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRW51bVZhbHVlc0RlZmluaXRpb25cbiAgICogICAtIGV4dGVuZCBlbnVtIE5hbWUgRGlyZWN0aXZlc1tDb25zdF1cbiAgICovXG5cbiAgcGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdlbnVtJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkVOVU1fVFlQRV9FWFRFTlNJT04sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIHZhbHVlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBJbnB1dEZpZWxkc0RlZmluaXRpb25cbiAgICogICAtIGV4dGVuZCBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuXG4gIHBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lucHV0Jyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT04sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIERpcmVjdGl2ZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGRpcmVjdGl2ZSBAIE5hbWUgQXJndW1lbnRzRGVmaW5pdGlvbj8gYHJlcGVhdGFibGVgPyBvbiBEaXJlY3RpdmVMb2NhdGlvbnNcbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkaXJlY3RpdmUnKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5BVCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudERlZnMoKTtcbiAgICBjb25zdCByZXBlYXRhYmxlID0gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ3JlcGVhdGFibGUnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ29uJyk7XG4gICAgY29uc3QgbG9jYXRpb25zID0gdGhpcy5wYXJzZURpcmVjdGl2ZUxvY2F0aW9ucygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuRElSRUNUSVZFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICByZXBlYXRhYmxlLFxuICAgICAgbG9jYXRpb25zLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXJlY3RpdmVMb2NhdGlvbnMgOlxuICAgKiAgIC0gYHxgPyBEaXJlY3RpdmVMb2NhdGlvblxuICAgKiAgIC0gRGlyZWN0aXZlTG9jYXRpb25zIHwgRGlyZWN0aXZlTG9jYXRpb25cbiAgICovXG5cbiAgcGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsaW1pdGVkTWFueShUb2tlbktpbmQuUElQRSwgdGhpcy5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uKTtcbiAgfVxuICAvKlxuICAgKiBEaXJlY3RpdmVMb2NhdGlvbiA6XG4gICAqICAgLSBFeGVjdXRhYmxlRGlyZWN0aXZlTG9jYXRpb25cbiAgICogICAtIFR5cGVTeXN0ZW1EaXJlY3RpdmVMb2NhdGlvblxuICAgKlxuICAgKiBFeGVjdXRhYmxlRGlyZWN0aXZlTG9jYXRpb24gOiBvbmUgb2ZcbiAgICogICBgUVVFUllgXG4gICAqICAgYE1VVEFUSU9OYFxuICAgKiAgIGBTVUJTQ1JJUFRJT05gXG4gICAqICAgYEZJRUxEYFxuICAgKiAgIGBGUkFHTUVOVF9ERUZJTklUSU9OYFxuICAgKiAgIGBGUkFHTUVOVF9TUFJFQURgXG4gICAqICAgYElOTElORV9GUkFHTUVOVGBcbiAgICpcbiAgICogVHlwZVN5c3RlbURpcmVjdGl2ZUxvY2F0aW9uIDogb25lIG9mXG4gICAqICAgYFNDSEVNQWBcbiAgICogICBgU0NBTEFSYFxuICAgKiAgIGBPQkpFQ1RgXG4gICAqICAgYEZJRUxEX0RFRklOSVRJT05gXG4gICAqICAgYEFSR1VNRU5UX0RFRklOSVRJT05gXG4gICAqICAgYElOVEVSRkFDRWBcbiAgICogICBgVU5JT05gXG4gICAqICAgYEVOVU1gXG4gICAqICAgYEVOVU1fVkFMVUVgXG4gICAqICAgYElOUFVUX09CSkVDVGBcbiAgICogICBgSU5QVVRfRklFTERfREVGSU5JVElPTmBcbiAgICovXG5cbiAgcGFyc2VEaXJlY3RpdmVMb2NhdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChEaXJlY3RpdmVMb2NhdGlvbiwgbmFtZS52YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChzdGFydCk7XG4gIH0gLy8gQ29yZSBwYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBub2RlIHRoYXQsIGlmIGNvbmZpZ3VyZWQgdG8gZG8gc28sIHNldHMgYSBcImxvY1wiIGZpZWxkIGFzIGFcbiAgICogbG9jYXRpb24gb2JqZWN0LCB1c2VkIHRvIGlkZW50aWZ5IHRoZSBwbGFjZSBpbiB0aGUgc291cmNlIHRoYXQgY3JlYXRlZCBhXG4gICAqIGdpdmVuIHBhcnNlZCBvYmplY3QuXG4gICAqL1xuXG4gIG5vZGUoc3RhcnRUb2tlbiwgbm9kZSkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLm5vTG9jYXRpb24gIT09IHRydWUpIHtcbiAgICAgIG5vZGUubG9jID0gbmV3IExvY2F0aW9uKFxuICAgICAgICBzdGFydFRva2VuLFxuICAgICAgICB0aGlzLl9sZXhlci5sYXN0VG9rZW4sXG4gICAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIG5leHQgdG9rZW4gaXMgb2YgYSBnaXZlbiBraW5kXG4gICAqL1xuXG4gIHBlZWsoa2luZCkge1xuICAgIHJldHVybiB0aGlzLl9sZXhlci50b2tlbi5raW5kID09PSBraW5kO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW4ga2luZCwgcmV0dXJuIHRoYXQgdG9rZW4gYWZ0ZXIgYWR2YW5jaW5nIHRoZSBsZXhlci5cbiAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93IGFuIGVycm9yLlxuICAgKi9cblxuICBleHBlY3RUb2tlbihraW5kKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIGlmICh0b2tlbi5raW5kID09PSBraW5kKSB7XG4gICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgdG9rZW4uc3RhcnQsXG4gICAgICBgRXhwZWN0ZWQgJHtnZXRUb2tlbktpbmREZXNjKGtpbmQpfSwgZm91bmQgJHtnZXRUb2tlbkRlc2ModG9rZW4pfS5gLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlbiBraW5kLCByZXR1cm4gXCJ0cnVlXCIgYWZ0ZXIgYWR2YW5jaW5nIHRoZSBsZXhlci5cbiAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHJldHVybiBcImZhbHNlXCIuXG4gICAqL1xuXG4gIGV4cGVjdE9wdGlvbmFsVG9rZW4oa2luZCkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0ga2luZCkge1xuICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBnaXZlbiBrZXl3b3JkLCBhZHZhbmNlIHRoZSBsZXhlci5cbiAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93IGFuIGVycm9yLlxuICAgKi9cblxuICBleHBlY3RLZXl3b3JkKHZhbHVlKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIGlmICh0b2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSAmJiB0b2tlbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuYWR2YW5jZUxleGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgICBgRXhwZWN0ZWQgXCIke3ZhbHVlfVwiLCBmb3VuZCAke2dldFRva2VuRGVzYyh0b2tlbil9LmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBnaXZlbiBrZXl3b3JkLCByZXR1cm4gXCJ0cnVlXCIgYWZ0ZXIgYWR2YW5jaW5nIHRoZSBsZXhlci5cbiAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHJldHVybiBcImZhbHNlXCIuXG4gICAqL1xuXG4gIGV4cGVjdE9wdGlvbmFsS2V5d29yZCh2YWx1ZSkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGVycm9yIHdoZW4gYW4gdW5leHBlY3RlZCBsZXhlZCB0b2tlbiBpcyBlbmNvdW50ZXJlZC5cbiAgICovXG5cbiAgdW5leHBlY3RlZChhdFRva2VuKSB7XG4gICAgY29uc3QgdG9rZW4gPVxuICAgICAgYXRUb2tlbiAhPT0gbnVsbCAmJiBhdFRva2VuICE9PSB2b2lkIDAgPyBhdFRva2VuIDogdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHN5bnRheEVycm9yKFxuICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgdG9rZW4uc3RhcnQsXG4gICAgICBgVW5leHBlY3RlZCAke2dldFRva2VuRGVzYyh0b2tlbil9LmAsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHBvc3NpYmx5IGVtcHR5IGxpc3Qgb2YgcGFyc2Ugbm9kZXMsIGRldGVybWluZWQgYnkgdGhlIHBhcnNlRm4uXG4gICAqIFRoaXMgbGlzdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC5cbiAgICogQWR2YW5jZXMgdGhlIHBhcnNlciB0byB0aGUgbmV4dCBsZXggdG9rZW4gYWZ0ZXIgdGhlIGNsb3NpbmcgdG9rZW4uXG4gICAqL1xuXG4gIGFueShvcGVuS2luZCwgcGFyc2VGbiwgY2xvc2VLaW5kKSB7XG4gICAgdGhpcy5leHBlY3RUb2tlbihvcGVuS2luZCk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgIHdoaWxlICghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGNsb3NlS2luZCkpIHtcbiAgICAgIG5vZGVzLnB1c2gocGFyc2VGbi5jYWxsKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgKiBJdCBjYW4gYmUgZW1wdHkgb25seSBpZiBvcGVuIHRva2VuIGlzIG1pc3Npbmcgb3RoZXJ3aXNlIGl0IHdpbGwgYWx3YXlzIHJldHVybiBub24tZW1wdHkgbGlzdFxuICAgKiB0aGF0IGJlZ2lucyB3aXRoIGEgbGV4IHRva2VuIG9mIG9wZW5LaW5kIGFuZCBlbmRzIHdpdGggYSBsZXggdG9rZW4gb2YgY2xvc2VLaW5kLlxuICAgKiBBZHZhbmNlcyB0aGUgcGFyc2VyIHRvIHRoZSBuZXh0IGxleCB0b2tlbiBhZnRlciB0aGUgY2xvc2luZyB0b2tlbi5cbiAgICovXG5cbiAgb3B0aW9uYWxNYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKG9wZW5LaW5kKSkge1xuICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgICAgZG8ge1xuICAgICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgICB9IHdoaWxlICghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGNsb3NlS2luZCkpO1xuXG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9uLWVtcHR5IGxpc3Qgb2YgcGFyc2Ugbm9kZXMsIGRldGVybWluZWQgYnkgdGhlIHBhcnNlRm4uXG4gICAqIFRoaXMgbGlzdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC5cbiAgICogQWR2YW5jZXMgdGhlIHBhcnNlciB0byB0aGUgbmV4dCBsZXggdG9rZW4gYWZ0ZXIgdGhlIGNsb3NpbmcgdG9rZW4uXG4gICAqL1xuXG4gIG1hbnkob3BlbktpbmQsIHBhcnNlRm4sIGNsb3NlS2luZCkge1xuICAgIHRoaXMuZXhwZWN0VG9rZW4ob3BlbktpbmQpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICBkbyB7XG4gICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgfSB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi1lbXB0eSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgKiBUaGlzIGxpc3QgbWF5IGJlZ2luIHdpdGggYSBsZXggdG9rZW4gb2YgZGVsaW1pdGVyS2luZCBmb2xsb3dlZCBieSBpdGVtcyBzZXBhcmF0ZWQgYnkgbGV4IHRva2VucyBvZiB0b2tlbktpbmQuXG4gICAqIEFkdmFuY2VzIHRoZSBwYXJzZXIgdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIGxhc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZGVsaW1pdGVkTWFueShkZWxpbWl0ZXJLaW5kLCBwYXJzZUZuKSB7XG4gICAgdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGRlbGltaXRlcktpbmQpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICBkbyB7XG4gICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgfSB3aGlsZSAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGRlbGltaXRlcktpbmQpKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGFkdmFuY2VMZXhlcigpIHtcbiAgICBjb25zdCB7IG1heFRva2VucyB9ID0gdGhpcy5fb3B0aW9ucztcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgIT09IFRva2VuS2luZC5FT0YpIHtcbiAgICAgICsrdGhpcy5fdG9rZW5Db3VudGVyO1xuXG4gICAgICBpZiAobWF4VG9rZW5zICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdG9rZW5Db3VudGVyID4gbWF4VG9rZW5zKSB7XG4gICAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgICAgICB0b2tlbi5zdGFydCxcbiAgICAgICAgICBgRG9jdW1lbnQgY29udGFpbnMgbW9yZSB0aGF0ICR7bWF4VG9rZW5zfSB0b2tlbnMuIFBhcnNpbmcgYWJvcnRlZC5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBkZXNjcmliZSBhIHRva2VuIGFzIGEgc3RyaW5nIGZvciBkZWJ1Z2dpbmcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VG9rZW5EZXNjKHRva2VuKSB7XG4gIGNvbnN0IHZhbHVlID0gdG9rZW4udmFsdWU7XG4gIHJldHVybiBnZXRUb2tlbktpbmREZXNjKHRva2VuLmtpbmQpICsgKHZhbHVlICE9IG51bGwgPyBgIFwiJHt2YWx1ZX1cImAgOiAnJyk7XG59XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGRlc2NyaWJlIGEgdG9rZW4ga2luZCBhcyBhIHN0cmluZyBmb3IgZGVidWdnaW5nLlxuICovXG5cbmZ1bmN0aW9uIGdldFRva2VuS2luZERlc2Moa2luZCkge1xuICByZXR1cm4gaXNQdW5jdHVhdG9yVG9rZW5LaW5kKGtpbmQpID8gYFwiJHtraW5kfVwiYCA6IGtpbmQ7XG59XG4iLCAiLyoqXG4gKiBQcmludHMgYSBzdHJpbmcgYXMgYSBHcmFwaFFMIFN0cmluZ1ZhbHVlIGxpdGVyYWwuIFJlcGxhY2VzIGNvbnRyb2wgY2hhcmFjdGVyc1xuICogYW5kIGV4Y2x1ZGVkIGNoYXJhY3RlcnMgKFwiIFUrMDAyMiBhbmQgXFxcXCBVKzAwNUMpIHdpdGggZXNjYXBlIHNlcXVlbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RyaW5nKHN0cikge1xuICByZXR1cm4gYFwiJHtzdHIucmVwbGFjZShlc2NhcGVkUmVnRXhwLCBlc2NhcGVkUmVwbGFjZXIpfVwiYDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuY29uc3QgZXNjYXBlZFJlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyMlxceDVjXFx4N2YtXFx4OWZdL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZWRSZXBsYWNlcihzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZVNlcXVlbmNlc1tzdHIuY2hhckNvZGVBdCgwKV07XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5jb25zdCBlc2NhcGVTZXF1ZW5jZXMgPSBbXG4gICdcXFxcdTAwMDAnLFxuICAnXFxcXHUwMDAxJyxcbiAgJ1xcXFx1MDAwMicsXG4gICdcXFxcdTAwMDMnLFxuICAnXFxcXHUwMDA0JyxcbiAgJ1xcXFx1MDAwNScsXG4gICdcXFxcdTAwMDYnLFxuICAnXFxcXHUwMDA3JyxcbiAgJ1xcXFxiJyxcbiAgJ1xcXFx0JyxcbiAgJ1xcXFxuJyxcbiAgJ1xcXFx1MDAwQicsXG4gICdcXFxcZicsXG4gICdcXFxccicsXG4gICdcXFxcdTAwMEUnLFxuICAnXFxcXHUwMDBGJyxcbiAgJ1xcXFx1MDAxMCcsXG4gICdcXFxcdTAwMTEnLFxuICAnXFxcXHUwMDEyJyxcbiAgJ1xcXFx1MDAxMycsXG4gICdcXFxcdTAwMTQnLFxuICAnXFxcXHUwMDE1JyxcbiAgJ1xcXFx1MDAxNicsXG4gICdcXFxcdTAwMTcnLFxuICAnXFxcXHUwMDE4JyxcbiAgJ1xcXFx1MDAxOScsXG4gICdcXFxcdTAwMUEnLFxuICAnXFxcXHUwMDFCJyxcbiAgJ1xcXFx1MDAxQycsXG4gICdcXFxcdTAwMUQnLFxuICAnXFxcXHUwMDFFJyxcbiAgJ1xcXFx1MDAxRicsXG4gICcnLFxuICAnJyxcbiAgJ1xcXFxcIicsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyAyRlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJywgLy8gM0ZcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsIC8vIDRGXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICdcXFxcXFxcXCcsXG4gICcnLFxuICAnJyxcbiAgJycsIC8vIDVGXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyA2RlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnXFxcXHUwMDdGJyxcbiAgJ1xcXFx1MDA4MCcsXG4gICdcXFxcdTAwODEnLFxuICAnXFxcXHUwMDgyJyxcbiAgJ1xcXFx1MDA4MycsXG4gICdcXFxcdTAwODQnLFxuICAnXFxcXHUwMDg1JyxcbiAgJ1xcXFx1MDA4NicsXG4gICdcXFxcdTAwODcnLFxuICAnXFxcXHUwMDg4JyxcbiAgJ1xcXFx1MDA4OScsXG4gICdcXFxcdTAwOEEnLFxuICAnXFxcXHUwMDhCJyxcbiAgJ1xcXFx1MDA4QycsXG4gICdcXFxcdTAwOEQnLFxuICAnXFxcXHUwMDhFJyxcbiAgJ1xcXFx1MDA4RicsXG4gICdcXFxcdTAwOTAnLFxuICAnXFxcXHUwMDkxJyxcbiAgJ1xcXFx1MDA5MicsXG4gICdcXFxcdTAwOTMnLFxuICAnXFxcXHUwMDk0JyxcbiAgJ1xcXFx1MDA5NScsXG4gICdcXFxcdTAwOTYnLFxuICAnXFxcXHUwMDk3JyxcbiAgJ1xcXFx1MDA5OCcsXG4gICdcXFxcdTAwOTknLFxuICAnXFxcXHUwMDlBJyxcbiAgJ1xcXFx1MDA5QicsXG4gICdcXFxcdTAwOUMnLFxuICAnXFxcXHUwMDlEJyxcbiAgJ1xcXFx1MDA5RScsXG4gICdcXFxcdTAwOUYnLFxuXTtcbiIsICJpbXBvcnQgeyBkZXZBc3NlcnQgfSBmcm9tICcuLi9qc3V0aWxzL2RldkFzc2VydC5tanMnO1xuaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJy4uL2pzdXRpbHMvaW5zcGVjdC5tanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBRdWVyeURvY3VtZW50S2V5cyB9IGZyb20gJy4vYXN0Lm1qcyc7XG5pbXBvcnQgeyBLaW5kIH0gZnJvbSAnLi9raW5kcy5tanMnO1xuLyoqXG4gKiBBIHZpc2l0b3IgaXMgcHJvdmlkZWQgdG8gdmlzaXQsIGl0IGNvbnRhaW5zIHRoZSBjb2xsZWN0aW9uIG9mXG4gKiByZWxldmFudCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdmlzaXRvcidzIHRyYXZlcnNhbC5cbiAqL1xuXG5leHBvcnQgY29uc3QgQlJFQUsgPSBPYmplY3QuZnJlZXplKHt9KTtcbi8qKlxuICogdmlzaXQoKSB3aWxsIHdhbGsgdGhyb3VnaCBhbiBBU1QgdXNpbmcgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwsIGNhbGxpbmdcbiAqIHRoZSB2aXNpdG9yJ3MgZW50ZXIgZnVuY3Rpb24gYXQgZWFjaCBub2RlIGluIHRoZSB0cmF2ZXJzYWwsIGFuZCBjYWxsaW5nIHRoZVxuICogbGVhdmUgZnVuY3Rpb24gYWZ0ZXIgdmlzaXRpbmcgdGhhdCBub2RlIGFuZCBhbGwgb2YgaXRzIGNoaWxkIG5vZGVzLlxuICpcbiAqIEJ5IHJldHVybmluZyBkaWZmZXJlbnQgdmFsdWVzIGZyb20gdGhlIGVudGVyIGFuZCBsZWF2ZSBmdW5jdGlvbnMsIHRoZVxuICogYmVoYXZpb3Igb2YgdGhlIHZpc2l0b3IgY2FuIGJlIGFsdGVyZWQsIGluY2x1ZGluZyBza2lwcGluZyBvdmVyIGEgc3ViLXRyZWUgb2ZcbiAqIHRoZSBBU1QgKGJ5IHJldHVybmluZyBmYWxzZSksIGVkaXRpbmcgdGhlIEFTVCBieSByZXR1cm5pbmcgYSB2YWx1ZSBvciBudWxsXG4gKiB0byByZW1vdmUgdGhlIHZhbHVlLCBvciB0byBzdG9wIHRoZSB3aG9sZSB0cmF2ZXJzYWwgYnkgcmV0dXJuaW5nIEJSRUFLLlxuICpcbiAqIFdoZW4gdXNpbmcgdmlzaXQoKSB0byBlZGl0IGFuIEFTVCwgdGhlIG9yaWdpbmFsIEFTVCB3aWxsIG5vdCBiZSBtb2RpZmllZCwgYW5kXG4gKiBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBBU1Qgd2l0aCB0aGUgY2hhbmdlcyBhcHBsaWVkIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGVcbiAqIHZpc2l0IGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBlZGl0ZWRBU1QgPSB2aXNpdChhc3QsIHtcbiAqICAgZW50ZXIobm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycykge1xuICogICAgIC8vIEByZXR1cm5cbiAqICAgICAvLyAgIHVuZGVmaW5lZDogbm8gYWN0aW9uXG4gKiAgICAgLy8gICBmYWxzZTogc2tpcCB2aXNpdGluZyB0aGlzIG5vZGVcbiAqICAgICAvLyAgIHZpc2l0b3IuQlJFQUs6IHN0b3AgdmlzaXRpbmcgYWx0b2dldGhlclxuICogICAgIC8vICAgbnVsbDogZGVsZXRlIHRoaXMgbm9kZVxuICogICAgIC8vICAgYW55IHZhbHVlOiByZXBsYWNlIHRoaXMgbm9kZSB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZVxuICogICB9LFxuICogICBsZWF2ZShub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKSB7XG4gKiAgICAgLy8gQHJldHVyblxuICogICAgIC8vICAgdW5kZWZpbmVkOiBubyBhY3Rpb25cbiAqICAgICAvLyAgIGZhbHNlOiBubyBhY3Rpb25cbiAqICAgICAvLyAgIHZpc2l0b3IuQlJFQUs6IHN0b3AgdmlzaXRpbmcgYWx0b2dldGhlclxuICogICAgIC8vICAgbnVsbDogZGVsZXRlIHRoaXMgbm9kZVxuICogICAgIC8vICAgYW55IHZhbHVlOiByZXBsYWNlIHRoaXMgbm9kZSB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEFsdGVybmF0aXZlbHkgdG8gcHJvdmlkaW5nIGVudGVyKCkgYW5kIGxlYXZlKCkgZnVuY3Rpb25zLCBhIHZpc2l0b3IgY2FuXG4gKiBpbnN0ZWFkIHByb3ZpZGUgZnVuY3Rpb25zIG5hbWVkIHRoZSBzYW1lIGFzIHRoZSBraW5kcyBvZiBBU1Qgbm9kZXMsIG9yXG4gKiBlbnRlci9sZWF2ZSB2aXNpdG9ycyBhdCBhIG5hbWVkIGtleSwgbGVhZGluZyB0byB0aHJlZSBwZXJtdXRhdGlvbnMgb2YgdGhlXG4gKiB2aXNpdG9yIEFQSTpcbiAqXG4gKiAxKSBOYW1lZCB2aXNpdG9ycyB0cmlnZ2VyZWQgd2hlbiBlbnRlcmluZyBhIG5vZGUgb2YgYSBzcGVjaWZpYyBraW5kLlxuICpcbiAqIGBgYHRzXG4gKiB2aXNpdChhc3QsIHtcbiAqICAgS2luZChub2RlKSB7XG4gKiAgICAgLy8gZW50ZXIgdGhlIFwiS2luZFwiIG5vZGVcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIDIpIE5hbWVkIHZpc2l0b3JzIHRoYXQgdHJpZ2dlciB1cG9uIGVudGVyaW5nIGFuZCBsZWF2aW5nIGEgbm9kZSBvZiBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogYGBgdHNcbiAqIHZpc2l0KGFzdCwge1xuICogICBLaW5kOiB7XG4gKiAgICAgZW50ZXIobm9kZSkge1xuICogICAgICAgLy8gZW50ZXIgdGhlIFwiS2luZFwiIG5vZGVcbiAqICAgICB9XG4gKiAgICAgbGVhdmUobm9kZSkge1xuICogICAgICAgLy8gbGVhdmUgdGhlIFwiS2luZFwiIG5vZGVcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAzKSBHZW5lcmljIHZpc2l0b3JzIHRoYXQgdHJpZ2dlciB1cG9uIGVudGVyaW5nIGFuZCBsZWF2aW5nIGFueSBub2RlLlxuICpcbiAqIGBgYHRzXG4gKiB2aXNpdChhc3QsIHtcbiAqICAgZW50ZXIobm9kZSkge1xuICogICAgIC8vIGVudGVyIGFueSBub2RlXG4gKiAgIH0sXG4gKiAgIGxlYXZlKG5vZGUpIHtcbiAqICAgICAvLyBsZWF2ZSBhbnkgbm9kZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHJvb3QsIHZpc2l0b3IsIHZpc2l0b3JLZXlzID0gUXVlcnlEb2N1bWVudEtleXMpIHtcbiAgY29uc3QgZW50ZXJMZWF2ZU1hcCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IGtpbmQgb2YgT2JqZWN0LnZhbHVlcyhLaW5kKSkge1xuICAgIGVudGVyTGVhdmVNYXAuc2V0KGtpbmQsIGdldEVudGVyTGVhdmVGb3JLaW5kKHZpc2l0b3IsIGtpbmQpKTtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZi1pbml0ICovXG5cbiAgbGV0IHN0YWNrID0gdW5kZWZpbmVkO1xuICBsZXQgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIGxldCBrZXlzID0gW3Jvb3RdO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IGVkaXRzID0gW107XG4gIGxldCBub2RlID0gcm9vdDtcbiAgbGV0IGtleSA9IHVuZGVmaW5lZDtcbiAgbGV0IHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZi1pbml0ICovXG5cbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgY29uc3QgaXNMZWF2aW5nID0gaW5kZXggPT09IGtleXMubGVuZ3RoO1xuICAgIGNvbnN0IGlzRWRpdGVkID0gaXNMZWF2aW5nICYmIGVkaXRzLmxlbmd0aCAhPT0gMDtcblxuICAgIGlmIChpc0xlYXZpbmcpIHtcbiAgICAgIGtleSA9IGFuY2VzdG9ycy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gYW5jZXN0b3JzLnBvcCgpO1xuXG4gICAgICBpZiAoaXNFZGl0ZWQpIHtcbiAgICAgICAgaWYgKGluQXJyYXkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5zbGljZSgpO1xuICAgICAgICAgIGxldCBlZGl0T2Zmc2V0ID0gMDtcblxuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5S2V5ID0gZWRpdEtleSAtIGVkaXRPZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChlZGl0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbm9kZS5zcGxpY2UoYXJyYXlLZXksIDEpO1xuICAgICAgICAgICAgICBlZGl0T2Zmc2V0Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlW2FycmF5S2V5XSA9IGVkaXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBbZWRpdEtleSwgZWRpdFZhbHVlXSBvZiBlZGl0cykge1xuICAgICAgICAgICAgbm9kZVtlZGl0S2V5XSA9IGVkaXRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBzdGFjay5pbmRleDtcbiAgICAgIGtleXMgPSBzdGFjay5rZXlzO1xuICAgICAgZWRpdHMgPSBzdGFjay5lZGl0cztcbiAgICAgIGluQXJyYXkgPSBzdGFjay5pbkFycmF5O1xuICAgICAgc3RhY2sgPSBzdGFjay5wcmV2O1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICBrZXkgPSBpbkFycmF5ID8gaW5kZXggOiBrZXlzW2luZGV4XTtcbiAgICAgIG5vZGUgPSBwYXJlbnRba2V5XTtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICB2YXIgX2VudGVyTGVhdmVNYXAkZ2V0LCBfZW50ZXJMZWF2ZU1hcCRnZXQyO1xuXG4gICAgICBpc05vZGUobm9kZSkgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgSW52YWxpZCBBU1QgTm9kZTogJHtpbnNwZWN0KG5vZGUpfS5gKTtcbiAgICAgIGNvbnN0IHZpc2l0Rm4gPSBpc0xlYXZpbmdcbiAgICAgICAgPyAoX2VudGVyTGVhdmVNYXAkZ2V0ID0gZW50ZXJMZWF2ZU1hcC5nZXQobm9kZS5raW5kKSkgPT09IG51bGwgfHxcbiAgICAgICAgICBfZW50ZXJMZWF2ZU1hcCRnZXQgPT09IHZvaWQgMFxuICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgOiBfZW50ZXJMZWF2ZU1hcCRnZXQubGVhdmVcbiAgICAgICAgOiAoX2VudGVyTGVhdmVNYXAkZ2V0MiA9IGVudGVyTGVhdmVNYXAuZ2V0KG5vZGUua2luZCkpID09PSBudWxsIHx8XG4gICAgICAgICAgX2VudGVyTGVhdmVNYXAkZ2V0MiA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogX2VudGVyTGVhdmVNYXAkZ2V0Mi5lbnRlcjtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIHZpc2l0Rm4gPT09IG51bGwgfHwgdmlzaXRGbiA9PT0gdm9pZCAwXG4gICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICA6IHZpc2l0Rm4uY2FsbCh2aXNpdG9yLCBub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghaXNMZWF2aW5nKSB7XG4gICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuXG4gICAgICAgIGlmICghaXNMZWF2aW5nKSB7XG4gICAgICAgICAgaWYgKGlzTm9kZShyZXN1bHQpKSB7XG4gICAgICAgICAgICBub2RlID0gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGlzRWRpdGVkKSB7XG4gICAgICBlZGl0cy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX25vZGUka2luZDtcblxuICAgICAgc3RhY2sgPSB7XG4gICAgICAgIGluQXJyYXksXG4gICAgICAgIGluZGV4LFxuICAgICAgICBrZXlzLFxuICAgICAgICBlZGl0cyxcbiAgICAgICAgcHJldjogc3RhY2ssXG4gICAgICB9O1xuICAgICAgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSk7XG4gICAgICBrZXlzID0gaW5BcnJheVxuICAgICAgICA/IG5vZGVcbiAgICAgICAgOiAoX25vZGUka2luZCA9IHZpc2l0b3JLZXlzW25vZGUua2luZF0pICE9PSBudWxsICYmXG4gICAgICAgICAgX25vZGUka2luZCAhPT0gdm9pZCAwXG4gICAgICAgID8gX25vZGUka2luZFxuICAgICAgICA6IFtdO1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGVkaXRzID0gW107XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChlZGl0cy5sZW5ndGggIT09IDApIHtcbiAgICAvLyBOZXcgcm9vdFxuICAgIHJldHVybiBlZGl0c1tlZGl0cy5sZW5ndGggLSAxXVsxXTtcbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZpc2l0b3IgaW5zdGFuY2Ugd2hpY2ggZGVsZWdhdGVzIHRvIG1hbnkgdmlzaXRvcnMgdG8gcnVuIGluXG4gKiBwYXJhbGxlbC4gRWFjaCB2aXNpdG9yIHdpbGwgYmUgdmlzaXRlZCBmb3IgZWFjaCBub2RlIGJlZm9yZSBtb3Zpbmcgb24uXG4gKlxuICogSWYgYSBwcmlvciB2aXNpdG9yIGVkaXRzIGEgbm9kZSwgbm8gZm9sbG93aW5nIHZpc2l0b3JzIHdpbGwgc2VlIHRoYXQgbm9kZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXRJblBhcmFsbGVsKHZpc2l0b3JzKSB7XG4gIGNvbnN0IHNraXBwaW5nID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgY29uc3QgbWVyZ2VkVmlzaXRvciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBraW5kIG9mIE9iamVjdC52YWx1ZXMoS2luZCkpIHtcbiAgICBsZXQgaGFzVmlzaXRvciA9IGZhbHNlO1xuICAgIGNvbnN0IGVudGVyTGlzdCA9IG5ldyBBcnJheSh2aXNpdG9ycy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcbiAgICBjb25zdCBsZWF2ZUxpc3QgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB7IGVudGVyLCBsZWF2ZSB9ID0gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvcnNbaV0sIGtpbmQpO1xuICAgICAgaGFzVmlzaXRvciB8fCAoaGFzVmlzaXRvciA9IGVudGVyICE9IG51bGwgfHwgbGVhdmUgIT0gbnVsbCk7XG4gICAgICBlbnRlckxpc3RbaV0gPSBlbnRlcjtcbiAgICAgIGxlYXZlTGlzdFtpXSA9IGxlYXZlO1xuICAgIH1cblxuICAgIGlmICghaGFzVmlzaXRvcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VkRW50ZXJMZWF2ZSA9IHtcbiAgICAgIGVudGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChza2lwcGluZ1tpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9lbnRlckxpc3QkaTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgICAgICAgKF9lbnRlckxpc3QkaSA9IGVudGVyTGlzdFtpXSkgPT09IG51bGwgfHwgX2VudGVyTGlzdCRpID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgIDogX2VudGVyTGlzdCRpLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gQlJFQUs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsZWF2ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhcmdzWzBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2tpcHBpbmdbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfbGVhdmVMaXN0JGk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9XG4gICAgICAgICAgICAgIChfbGVhdmVMaXN0JGkgPSBsZWF2ZUxpc3RbaV0pID09PSBudWxsIHx8IF9sZWF2ZUxpc3QkaSA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICA6IF9sZWF2ZUxpc3QkaS5hcHBseSh2aXNpdG9yc1tpXSwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gQlJFQUs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBwaW5nW2ldID09PSBub2RlKSB7XG4gICAgICAgICAgICBza2lwcGluZ1tpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gICAgbWVyZ2VkVmlzaXRvcltraW5kXSA9IG1lcmdlZEVudGVyTGVhdmU7XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkVmlzaXRvcjtcbn1cbi8qKlxuICogR2l2ZW4gYSB2aXNpdG9yIGluc3RhbmNlIGFuZCBhIG5vZGUga2luZCwgcmV0dXJuIEVudGVyTGVhdmVWaXNpdG9yIGZvciB0aGF0IGtpbmQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudGVyTGVhdmVGb3JLaW5kKHZpc2l0b3IsIGtpbmQpIHtcbiAgY29uc3Qga2luZFZpc2l0b3IgPSB2aXNpdG9yW2tpbmRdO1xuXG4gIGlmICh0eXBlb2Yga2luZFZpc2l0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgLy8geyBLaW5kOiB7IGVudGVyKCkge30sIGxlYXZlKCkge30gfSB9XG4gICAgcmV0dXJuIGtpbmRWaXNpdG9yO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBraW5kVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHsgS2luZCgpIHt9IH1cbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXI6IGtpbmRWaXNpdG9yLFxuICAgICAgbGVhdmU6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IC8vIHsgZW50ZXIoKSB7fSwgbGVhdmUoKSB7fSB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlcjogdmlzaXRvci5lbnRlcixcbiAgICBsZWF2ZTogdmlzaXRvci5sZWF2ZSxcbiAgfTtcbn1cbi8qKlxuICogR2l2ZW4gYSB2aXNpdG9yIGluc3RhbmNlLCBpZiBpdCBpcyBsZWF2aW5nIG9yIG5vdCwgYW5kIGEgbm9kZSBraW5kLCByZXR1cm5cbiAqIHRoZSBmdW5jdGlvbiB0aGUgdmlzaXRvciBydW50aW1lIHNob3VsZCBjYWxsLlxuICpcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYGdldEVudGVyTGVhdmVGb3JLaW5kYCBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjE3XG4gKi9cblxuLyogYzggaWdub3JlIG5leHQgOCAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlzaXRGbih2aXNpdG9yLCBraW5kLCBpc0xlYXZpbmcpIHtcbiAgY29uc3QgeyBlbnRlciwgbGVhdmUgfSA9IGdldEVudGVyTGVhdmVGb3JLaW5kKHZpc2l0b3IsIGtpbmQpO1xuICByZXR1cm4gaXNMZWF2aW5nID8gbGVhdmUgOiBlbnRlcjtcbn1cbiIsICJpbXBvcnQgeyBwcmludEJsb2NrU3RyaW5nIH0gZnJvbSAnLi9ibG9ja1N0cmluZy5tanMnO1xuaW1wb3J0IHsgcHJpbnRTdHJpbmcgfSBmcm9tICcuL3ByaW50U3RyaW5nLm1qcyc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJy4vdmlzaXRvci5tanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU1QgaW50byBhIHN0cmluZywgdXNpbmcgb25lIHNldCBvZiByZWFzb25hYmxlXG4gKiBmb3JtYXR0aW5nIHJ1bGVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludChhc3QpIHtcbiAgcmV0dXJuIHZpc2l0KGFzdCwgcHJpbnREb2NBU1RSZWR1Y2VyKTtcbn1cbmNvbnN0IE1BWF9MSU5FX0xFTkdUSCA9IDgwO1xuY29uc3QgcHJpbnREb2NBU1RSZWR1Y2VyID0ge1xuICBOYW1lOiB7XG4gICAgbGVhdmU6IChub2RlKSA9PiBub2RlLnZhbHVlLFxuICB9LFxuICBWYXJpYWJsZToge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gJyQnICsgbm9kZS5uYW1lLFxuICB9LFxuICAvLyBEb2N1bWVudFxuICBEb2N1bWVudDoge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gam9pbihub2RlLmRlZmluaXRpb25zLCAnXFxuXFxuJyksXG4gIH0sXG4gIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICBsZWF2ZShub2RlKSB7XG4gICAgICBjb25zdCB2YXJEZWZzID0gd3JhcCgnKCcsIGpvaW4obm9kZS52YXJpYWJsZURlZmluaXRpb25zLCAnLCAnKSwgJyknKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGpvaW4oXG4gICAgICAgIFtcbiAgICAgICAgICBub2RlLm9wZXJhdGlvbixcbiAgICAgICAgICBqb2luKFtub2RlLm5hbWUsIHZhckRlZnNdKSxcbiAgICAgICAgICBqb2luKG5vZGUuZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgXSxcbiAgICAgICAgJyAnLFxuICAgICAgKTsgLy8gQW5vbnltb3VzIHF1ZXJpZXMgd2l0aCBubyBkaXJlY3RpdmVzIG9yIHZhcmlhYmxlIGRlZmluaXRpb25zIGNhbiB1c2VcbiAgICAgIC8vIHRoZSBxdWVyeSBzaG9ydCBmb3JtLlxuXG4gICAgICByZXR1cm4gKHByZWZpeCA9PT0gJ3F1ZXJ5JyA/ICcnIDogcHJlZml4ICsgJyAnKSArIG5vZGUuc2VsZWN0aW9uU2V0O1xuICAgIH0sXG4gIH0sXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyB2YXJpYWJsZSwgdHlwZSwgZGVmYXVsdFZhbHVlLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICB2YXJpYWJsZSArXG4gICAgICAnOiAnICtcbiAgICAgIHR5cGUgK1xuICAgICAgd3JhcCgnID0gJywgZGVmYXVsdFZhbHVlKSArXG4gICAgICB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKSxcbiAgfSxcbiAgU2VsZWN0aW9uU2V0OiB7XG4gICAgbGVhdmU6ICh7IHNlbGVjdGlvbnMgfSkgPT4gYmxvY2soc2VsZWN0aW9ucyksXG4gIH0sXG4gIEZpZWxkOiB7XG4gICAgbGVhdmUoeyBhbGlhcywgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCBkaXJlY3RpdmVzLCBzZWxlY3Rpb25TZXQgfSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gd3JhcCgnJywgYWxpYXMsICc6ICcpICsgbmFtZTtcbiAgICAgIGxldCBhcmdzTGluZSA9IHByZWZpeCArIHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpO1xuXG4gICAgICBpZiAoYXJnc0xpbmUubGVuZ3RoID4gTUFYX0xJTkVfTEVOR1RIKSB7XG4gICAgICAgIGFyZ3NMaW5lID0gcHJlZml4ICsgd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqb2luKFthcmdzTGluZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBzZWxlY3Rpb25TZXRdLCAnICcpO1xuICAgIH0sXG4gIH0sXG4gIEFyZ3VtZW50OiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIHZhbHVlIH0pID0+IG5hbWUgKyAnOiAnICsgdmFsdWUsXG4gIH0sXG4gIC8vIEZyYWdtZW50c1xuICBGcmFnbWVudFNwcmVhZDoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICAnLi4uJyArIG5hbWUgKyB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKSxcbiAgfSxcbiAgSW5saW5lRnJhZ21lbnQ6IHtcbiAgICBsZWF2ZTogKHsgdHlwZUNvbmRpdGlvbiwgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pID0+XG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJy4uLicsXG4gICAgICAgICAgd3JhcCgnb24gJywgdHlwZUNvbmRpdGlvbiksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIHNlbGVjdGlvblNldCxcbiAgICAgICAgXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgRnJhZ21lbnREZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6IChcbiAgICAgIHsgbmFtZSwgdHlwZUNvbmRpdGlvbiwgdmFyaWFibGVEZWZpbml0aW9ucywgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0sIC8vIE5vdGU6IGZyYWdtZW50IHZhcmlhYmxlIGRlZmluaXRpb25zIGFyZSBleHBlcmltZW50YWwgYW5kIG1heSBiZSBjaGFuZ2VkXG4gICAgKSA9PlxuICAgICAgLy8gb3IgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgYGZyYWdtZW50ICR7bmFtZX0ke3dyYXAoJygnLCBqb2luKHZhcmlhYmxlRGVmaW5pdGlvbnMsICcsICcpLCAnKScpfSBgICtcbiAgICAgIGBvbiAke3R5cGVDb25kaXRpb259ICR7d3JhcCgnJywgam9pbihkaXJlY3RpdmVzLCAnICcpLCAnICcpfWAgK1xuICAgICAgc2VsZWN0aW9uU2V0LFxuICB9LFxuICAvLyBWYWx1ZVxuICBJbnRWYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSxcbiAgfSxcbiAgRmxvYXRWYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSxcbiAgfSxcbiAgU3RyaW5nVmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUsIGJsb2NrOiBpc0Jsb2NrU3RyaW5nIH0pID0+XG4gICAgICBpc0Jsb2NrU3RyaW5nID8gcHJpbnRCbG9ja1N0cmluZyh2YWx1ZSkgOiBwcmludFN0cmluZyh2YWx1ZSksXG4gIH0sXG4gIEJvb2xlYW5WYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiAodmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKSxcbiAgfSxcbiAgTnVsbFZhbHVlOiB7XG4gICAgbGVhdmU6ICgpID0+ICdudWxsJyxcbiAgfSxcbiAgRW51bVZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlIH0pID0+IHZhbHVlLFxuICB9LFxuICBMaXN0VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWVzIH0pID0+ICdbJyArIGpvaW4odmFsdWVzLCAnLCAnKSArICddJyxcbiAgfSxcbiAgT2JqZWN0VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgZmllbGRzIH0pID0+ICd7JyArIGpvaW4oZmllbGRzLCAnLCAnKSArICd9JyxcbiAgfSxcbiAgT2JqZWN0RmllbGQ6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgdmFsdWUgfSkgPT4gbmFtZSArICc6ICcgKyB2YWx1ZSxcbiAgfSxcbiAgLy8gRGlyZWN0aXZlXG4gIERpcmVjdGl2ZToge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSkgPT5cbiAgICAgICdAJyArIG5hbWUgKyB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSxcbiAgfSxcbiAgLy8gVHlwZVxuICBOYW1lZFR5cGU6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSB9KSA9PiBuYW1lLFxuICB9LFxuICBMaXN0VHlwZToge1xuICAgIGxlYXZlOiAoeyB0eXBlIH0pID0+ICdbJyArIHR5cGUgKyAnXScsXG4gIH0sXG4gIE5vbk51bGxUeXBlOiB7XG4gICAgbGVhdmU6ICh7IHR5cGUgfSkgPT4gdHlwZSArICchJyxcbiAgfSxcbiAgLy8gVHlwZSBTeXN0ZW0gRGVmaW5pdGlvbnNcbiAgU2NoZW1hRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgZGlyZWN0aXZlcywgb3BlcmF0aW9uVHlwZXMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihbJ3NjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgJyAnKSxcbiAgfSxcbiAgT3BlcmF0aW9uVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgb3BlcmF0aW9uLCB0eXBlIH0pID0+IG9wZXJhdGlvbiArICc6ICcgKyB0eXBlLFxuICB9LFxuICBTY2FsYXJUeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFsnc2NhbGFyJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKSxcbiAgfSxcbiAgT2JqZWN0VHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIGJsb2NrKGZpZWxkcyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEZpZWxkRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCB0eXBlLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIG5hbWUgK1xuICAgICAgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpXG4gICAgICAgID8gd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJylcbiAgICAgICAgOiB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSkgK1xuICAgICAgJzogJyArXG4gICAgICB0eXBlICtcbiAgICAgIHdyYXAoJyAnLCBqb2luKGRpcmVjdGl2ZXMsICcgJykpLFxuICB9LFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oXG4gICAgICAgIFtuYW1lICsgJzogJyArIHR5cGUsIHdyYXAoJz0gJywgZGVmYXVsdFZhbHVlKSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJ2ludGVyZmFjZScsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB3cmFwKCdpbXBsZW1lbnRzICcsIGpvaW4oaW50ZXJmYWNlcywgJyAmICcpKSxcbiAgICAgICAgICBqb2luKGRpcmVjdGl2ZXMsICcgJyksXG4gICAgICAgICAgYmxvY2soZmllbGRzKSxcbiAgICAgICAgXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgVW5pb25UeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcywgdHlwZXMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihcbiAgICAgICAgWyd1bmlvbicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgd3JhcCgnPSAnLCBqb2luKHR5cGVzLCAnIHwgJykpXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzLCB2YWx1ZXMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihbJ2VudW0nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKHZhbHVlcyldLCAnICcpLFxuICB9LFxuICBFbnVtVmFsdWVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICsgam9pbihbbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKSxcbiAgfSxcbiAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oWydpbnB1dCcsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyksXG4gIH0sXG4gIERpcmVjdGl2ZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGFyZ3VtZW50czogYXJncywgcmVwZWF0YWJsZSwgbG9jYXRpb25zIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgICdkaXJlY3RpdmUgQCcgK1xuICAgICAgbmFtZSArXG4gICAgICAoaGFzTXVsdGlsaW5lSXRlbXMoYXJncylcbiAgICAgICAgPyB3cmFwKCcoXFxuJywgaW5kZW50KGpvaW4oYXJncywgJ1xcbicpKSwgJ1xcbiknKVxuICAgICAgICA6IHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpKSArXG4gICAgICAocmVwZWF0YWJsZSA/ICcgcmVwZWF0YWJsZScgOiAnJykgK1xuICAgICAgJyBvbiAnICtcbiAgICAgIGpvaW4obG9jYXRpb25zLCAnIHwgJyksXG4gIH0sXG4gIFNjaGVtYUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBkaXJlY3RpdmVzLCBvcGVyYXRpb25UeXBlcyB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgWydleHRlbmQgc2NoZW1hJywgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhvcGVyYXRpb25UeXBlcyldLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMgfSkgPT5cbiAgICAgIGpvaW4oWydleHRlbmQgc2NhbGFyJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKSxcbiAgfSxcbiAgT2JqZWN0VHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT5cbiAgICAgIGpvaW4oXG4gICAgICAgIFtcbiAgICAgICAgICAnZXh0ZW5kIHR5cGUnLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIGJsb2NrKGZpZWxkcyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEludGVyZmFjZVR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+XG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJ2V4dGVuZCBpbnRlcmZhY2UnLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIGJsb2NrKGZpZWxkcyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzLCB0eXBlcyB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICdleHRlbmQgdW5pb24nLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIHdyYXAoJz0gJywgam9pbih0eXBlcywgJyB8ICcpKSxcbiAgICAgICAgXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgRW51bVR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcywgdmFsdWVzIH0pID0+XG4gICAgICBqb2luKFsnZXh0ZW5kIGVudW0nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKHZhbHVlcyldLCAnICcpLFxuICB9LFxuICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+XG4gICAgICBqb2luKFsnZXh0ZW5kIGlucHV0JywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKSxcbiAgfSxcbn07XG4vKipcbiAqIEdpdmVuIG1heWJlQXJyYXksIHByaW50IGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBudWxsIG9yIGVtcHR5LCBvdGhlcndpc2VcbiAqIHByaW50IGFsbCBpdGVtcyB0b2dldGhlciBzZXBhcmF0ZWQgYnkgc2VwYXJhdG9yIGlmIHByb3ZpZGVkXG4gKi9cblxuZnVuY3Rpb24gam9pbihtYXliZUFycmF5LCBzZXBhcmF0b3IgPSAnJykge1xuICB2YXIgX21heWJlQXJyYXkkZmlsdGVyJGpvO1xuXG4gIHJldHVybiAoX21heWJlQXJyYXkkZmlsdGVyJGpvID1cbiAgICBtYXliZUFycmF5ID09PSBudWxsIHx8IG1heWJlQXJyYXkgPT09IHZvaWQgMFxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogbWF5YmVBcnJheS5maWx0ZXIoKHgpID0+IHgpLmpvaW4oc2VwYXJhdG9yKSkgIT09IG51bGwgJiZcbiAgICBfbWF5YmVBcnJheSRmaWx0ZXIkam8gIT09IHZvaWQgMFxuICAgID8gX21heWJlQXJyYXkkZmlsdGVyJGpvXG4gICAgOiAnJztcbn1cbi8qKlxuICogR2l2ZW4gYXJyYXksIHByaW50IGVhY2ggaXRlbSBvbiBpdHMgb3duIGxpbmUsIHdyYXBwZWQgaW4gYW4gaW5kZW50ZWQgYHsgfWAgYmxvY2suXG4gKi9cblxuZnVuY3Rpb24gYmxvY2soYXJyYXkpIHtcbiAgcmV0dXJuIHdyYXAoJ3tcXG4nLCBpbmRlbnQoam9pbihhcnJheSwgJ1xcbicpKSwgJ1xcbn0nKTtcbn1cbi8qKlxuICogSWYgbWF5YmVTdHJpbmcgaXMgbm90IG51bGwgb3IgZW1wdHksIHRoZW4gd3JhcCB3aXRoIHN0YXJ0IGFuZCBlbmQsIG90aGVyd2lzZSBwcmludCBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gd3JhcChzdGFydCwgbWF5YmVTdHJpbmcsIGVuZCA9ICcnKSB7XG4gIHJldHVybiBtYXliZVN0cmluZyAhPSBudWxsICYmIG1heWJlU3RyaW5nICE9PSAnJ1xuICAgID8gc3RhcnQgKyBtYXliZVN0cmluZyArIGVuZFxuICAgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgcmV0dXJuIHdyYXAoJyAgJywgc3RyLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKSk7XG59XG5cbmZ1bmN0aW9uIGhhc011bHRpbGluZUl0ZW1zKG1heWJlQXJyYXkpIHtcbiAgdmFyIF9tYXliZUFycmF5JHNvbWU7XG5cbiAgLy8gRklYTUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIyMDNcblxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gKF9tYXliZUFycmF5JHNvbWUgPVxuICAgIG1heWJlQXJyYXkgPT09IG51bGwgfHwgbWF5YmVBcnJheSA9PT0gdm9pZCAwXG4gICAgICA/IHZvaWQgMFxuICAgICAgOiBtYXliZUFycmF5LnNvbWUoKHN0cikgPT4gc3RyLmluY2x1ZGVzKCdcXG4nKSkpICE9PSBudWxsICYmXG4gICAgX21heWJlQXJyYXkkc29tZSAhPT0gdm9pZCAwXG4gICAgPyBfbWF5YmVBcnJheSRzb21lXG4gICAgOiBmYWxzZTtcbn1cbiIsICJleHBvcnQgY29uc3QgQUNDRVBUX0hFQURFUiA9IGBBY2NlcHRgXG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9IGBDb250ZW50LVR5cGVgXG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0pTT04gPSBgYXBwbGljYXRpb24vanNvbmBcbmV4cG9ydCBjb25zdCBDT05URU5UX1RZUEVfR1FMID0gYGFwcGxpY2F0aW9uL2dyYXBocWwtcmVzcG9uc2UranNvbmBcbmV4cG9ydCBjb25zdCBzdGF0dXNDb2RlcyA9IHtcbiAgc3VjY2VzczogMjAwLFxufVxuIiwgImltcG9ydCB7IEtpbmQgfSBmcm9tICdncmFwaHFsJ1xuaW1wb3J0IHsgQ09OVEVOVF9UWVBFX0dRTCwgQ09OVEVOVF9UWVBFX0pTT04gfSBmcm9tICcuLi8uLi9saWIvaHR0cC5qcydcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi8uLi9saWIvcHJlbHVkZS5qcydcbi8qKlxuICogUmVmYWN0b3JlZCBpbXBvcnRzIGZyb20gYGdyYXBocWxgIHRvIGJlIG1vcmUgc3BlY2lmaWMsIHRoaXMgaGVscHMgaW1wb3J0IG9ubHkgdGhlIHJlcXVpcmVkIGZpbGVzICgxMDBLaUIpXG4gKiBpbnN0ZWFkIG9mIHRoZSBlbnRpcmUgcGFja2FnZSAoZ3JlYXRlciB0aGFuIDUwMEtpQikgd2hlcmUgdHJlZS1zaGFraW5nIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmt1aHJ0L2dyYXBocWwtcmVxdWVzdC9wdWxsLzU0M1xuICovXG5pbXBvcnQgdHlwZSB7IE9wZXJhdGlvbkRlZmluaXRpb25Ob2RlIH0gZnJvbSAnZ3JhcGhxbCdcblxuLyoqXG4gKiBDbGVhbiBhIEdyYXBoUUwgZG9jdW1lbnQgdG8gc2VuZCBpdCB2aWEgYSBHRVQgcXVlcnlcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFuUXVlcnkgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4gc3RyLnJlcGxhY2UoLyhbXFxzLF18I1teXFxuXFxyXSspKy9nLCBgIGApLnRyaW0oKVxuXG5leHBvcnQgY29uc3QgaXNHcmFwaFFMQ29udGVudFR5cGUgPSAoY29udGVudFR5cGU6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb250ZW50VHlwZUxvd2VyID0gY29udGVudFR5cGUudG9Mb3dlckNhc2UoKVxuXG4gIHJldHVybiBjb250ZW50VHlwZUxvd2VyLmluY2x1ZGVzKENPTlRFTlRfVFlQRV9HUUwpIHx8IGNvbnRlbnRUeXBlTG93ZXIuaW5jbHVkZXMoQ09OVEVOVF9UWVBFX0pTT04pXG59XG5cbmV4cG9ydCB0eXBlIEdyYXBoUUxSZXF1ZXN0UmVzdWx0ID0gR3JhcGhRTFJlcXVlc3RSZXN1bHRCYXRjaCB8IEdyYXBoUUxSZXF1ZXN0UmVzdWx0U2luZ2xlXG5leHBvcnQgdHlwZSBHcmFwaFFMUmVxdWVzdFJlc3VsdEJhdGNoID0geyBfdGFnOiAnQmF0Y2gnOyBleGVjdXRpb25SZXN1bHRzOiBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0QmF0Y2ggfVxuZXhwb3J0IHR5cGUgR3JhcGhRTFJlcXVlc3RSZXN1bHRTaW5nbGUgPSB7IF90YWc6ICdTaW5nbGUnOyBleGVjdXRpb25SZXN1bHQ6IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGUgfVxuXG5leHBvcnQgdHlwZSBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0ID0gR3JhcGhRTEV4ZWN1dGlvblJlc3VsdFNpbmdsZSB8IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRCYXRjaFxuZXhwb3J0IHR5cGUgR3JhcGhRTEV4ZWN1dGlvblJlc3VsdEJhdGNoID0gR3JhcGhRTEV4ZWN1dGlvblJlc3VsdFNpbmdsZVtdXG5leHBvcnQgdHlwZSBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0U2luZ2xlID0ge1xuICBkYXRhOiBvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkXG4gIGVycm9yczogdW5kZWZpbmVkIHwgb2JqZWN0IHwgb2JqZWN0W11cbiAgZXh0ZW5zaW9ucz86IG9iamVjdFxufVxuXG5leHBvcnQgY29uc3QgcGFyc2VHcmFwaFFMRXhlY3V0aW9uUmVzdWx0ID0gKHJlc3VsdDogdW5rbm93bik6IEVycm9yIHwgR3JhcGhRTFJlcXVlc3RSZXN1bHQgPT4ge1xuICB0cnkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF90YWc6IGBCYXRjaGAsXG4gICAgICAgIGV4ZWN1dGlvblJlc3VsdHM6IHJlc3VsdC5tYXAocGFyc2VFeGVjdXRpb25SZXN1bHQpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdGFnOiBgU2luZ2xlYCxcbiAgICAgICAgZXhlY3V0aW9uUmVzdWx0OiBwYXJzZUV4ZWN1dGlvblJlc3VsdChyZXN1bHQpLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXhlY3V0aW9uIHJlc3VsdDogcmVzdWx0IGlzIG5vdCBvYmplY3Qgb3IgYXJyYXkuIFxcbkdvdDpcXG4ke1N0cmluZyhyZXN1bHQpfWApXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGUgYXMgRXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEV4YW1wbGUgcmVzdWx0OlxuICpcbiAqIGBgYFxuICoge1xuICogIFwiZGF0YVwiOiBudWxsLFxuICogIFwiZXJyb3JzXCI6IFt7XG4gKiAgICBcIm1lc3NhZ2VcIjogXCJjdXN0b20gZXJyb3JcIixcbiAqICAgIFwibG9jYXRpb25zXCI6IFt7IFwibGluZVwiOiAyLCBcImNvbHVtblwiOiAzIH1dLFxuICogICAgXCJwYXRoXCI6IFtcInBsYXllck5ld1wiXVxuICogIH1dXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRXhlY3V0aW9uUmVzdWx0ID0gKHJlc3VsdDogdW5rbm93bik6IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGUgPT4ge1xuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gYG9iamVjdGAgfHwgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4ZWN1dGlvbiByZXN1bHQ6IHJlc3VsdCBpcyBub3Qgb2JqZWN0YClcbiAgfVxuXG4gIGxldCBlcnJvcnMgPSB1bmRlZmluZWRcbiAgbGV0IGRhdGEgPSB1bmRlZmluZWRcbiAgbGV0IGV4dGVuc2lvbnMgPSB1bmRlZmluZWRcblxuICBpZiAoYGVycm9yc2AgaW4gcmVzdWx0KSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHJlc3VsdC5lcnJvcnMpICYmICFBcnJheS5pc0FycmF5KHJlc3VsdC5lcnJvcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXhlY3V0aW9uIHJlc3VsdDogZXJyb3JzIGlzIG5vdCBwbGFpbiBvYmplY3QgT1IgYXJyYXlgKSAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG4gICAgZXJyb3JzID0gcmVzdWx0LmVycm9yc1xuICB9XG5cbiAgLy8gdG9kbyBhZGQgdGVzdCBjb3ZlcmFnZSBmb3IgY2FzZSBvZiBudWxsLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmt1aHJ0L2dyYXBocWwtcmVxdWVzdC9pc3N1ZXMvNzM5XG4gIGlmIChgZGF0YWAgaW4gcmVzdWx0KSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHJlc3VsdC5kYXRhKSAmJiByZXN1bHQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4ZWN1dGlvbiByZXN1bHQ6IGRhdGEgaXMgbm90IHBsYWluIG9iamVjdGApIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIH1cbiAgICBkYXRhID0gcmVzdWx0LmRhdGFcbiAgfVxuXG4gIGlmIChgZXh0ZW5zaW9uc2AgaW4gcmVzdWx0KSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHJlc3VsdC5leHRlbnNpb25zKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4ZWN1dGlvbiByZXN1bHQ6IGV4dGVuc2lvbnMgaXMgbm90IHBsYWluIG9iamVjdGApIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGV4dGVuc2lvbnMgPSByZXN1bHQuZXh0ZW5zaW9uc1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGVycm9ycyxcbiAgICBleHRlbnNpb25zLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpc1JlcXVlc3RSZXN1bHRIYXZlRXJyb3JzID0gKHJlc3VsdDogR3JhcGhRTFJlcXVlc3RSZXN1bHQpID0+XG4gIHJlc3VsdC5fdGFnID09PSBgQmF0Y2hgXG4gICAgPyByZXN1bHQuZXhlY3V0aW9uUmVzdWx0cy5zb21lKGlzRXhlY3V0aW9uUmVzdWx0SGF2ZUVycm9ycylcbiAgICA6IGlzRXhlY3V0aW9uUmVzdWx0SGF2ZUVycm9ycyhyZXN1bHQuZXhlY3V0aW9uUmVzdWx0KVxuXG5leHBvcnQgY29uc3QgaXNFeGVjdXRpb25SZXN1bHRIYXZlRXJyb3JzID0gKHJlc3VsdDogR3JhcGhRTEV4ZWN1dGlvblJlc3VsdFNpbmdsZSkgPT5cbiAgQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSA/IHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCA6IEJvb2xlYW4ocmVzdWx0LmVycm9ycylcblxuZXhwb3J0IGNvbnN0IGlzT3BlcmF0aW9uRGVmaW5pdGlvbk5vZGUgPSAoZGVmaW5pdGlvbjogdW5rbm93bik6IGRlZmluaXRpb24gaXMgT3BlcmF0aW9uRGVmaW5pdGlvbk5vZGUgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkZWZpbml0aW9uID09PSBgb2JqZWN0YFxuICAgICYmIGRlZmluaXRpb24gIT09IG51bGxcbiAgICAmJiBga2luZGAgaW4gZGVmaW5pdGlvblxuICAgICYmIGRlZmluaXRpb24ua2luZCA9PT0gS2luZC5PUEVSQVRJT05fREVGSU5JVElPTlxuICApXG59XG4iLCAiaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi8uLi9saWIvcHJlbHVkZS5qcydcbmltcG9ydCB7IGlzT3BlcmF0aW9uRGVmaW5pdGlvbk5vZGUgfSBmcm9tICcuLi9saWIvZ3JhcGhxbC5qcydcbmltcG9ydCB0eXBlIHsgUmVxdWVzdERvY3VtZW50IH0gZnJvbSAnLi90eXBlcy5qcydcbi8qKlxuICogUmVmYWN0b3JlZCBpbXBvcnRzIGZyb20gYGdyYXBocWxgIHRvIGJlIG1vcmUgc3BlY2lmaWMsIHRoaXMgaGVscHMgaW1wb3J0IG9ubHkgdGhlIHJlcXVpcmVkIGZpbGVzICgxMDBLaUIpXG4gKiBpbnN0ZWFkIG9mIHRoZSBlbnRpcmUgcGFja2FnZSAoZ3JlYXRlciB0aGFuIDUwMEtpQikgd2hlcmUgdHJlZS1zaGFraW5nIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmt1aHJ0L2dyYXBocWwtcmVxdWVzdC9wdWxsLzU0M1xuICovXG5pbXBvcnQgeyB0eXBlIERvY3VtZW50Tm9kZSwgT3BlcmF0aW9uVHlwZU5vZGUgfSBmcm9tICdncmFwaHFsJ1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdncmFwaHFsJ1xuaW1wb3J0IHsgcHJpbnQgfSBmcm9tICdncmFwaHFsJ1xuXG4vKipcbiAqIGhlbHBlcnNcbiAqL1xuXG5jb25zdCBleHRyYWN0T3BlcmF0aW9uTmFtZSA9IChkb2N1bWVudDogRG9jdW1lbnROb2RlKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgbGV0IG9wZXJhdGlvbk5hbWUgPSB1bmRlZmluZWRcblxuICBjb25zdCBkZWZzID0gZG9jdW1lbnQuZGVmaW5pdGlvbnMuZmlsdGVyKGlzT3BlcmF0aW9uRGVmaW5pdGlvbk5vZGUpXG5cbiAgaWYgKGRlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgb3BlcmF0aW9uTmFtZSA9IGRlZnNbMF0hLm5hbWU/LnZhbHVlXG4gIH1cblxuICByZXR1cm4gb3BlcmF0aW9uTmFtZVxufVxuXG5jb25zdCBleHRyYWN0SXNNdXRhdGlvbiA9IChkb2N1bWVudDogRG9jdW1lbnROb2RlKTogYm9vbGVhbiA9PiB7XG4gIGxldCBpc011dGF0aW9uID0gZmFsc2VcblxuICBjb25zdCBkZWZzID0gZG9jdW1lbnQuZGVmaW5pdGlvbnMuZmlsdGVyKGlzT3BlcmF0aW9uRGVmaW5pdGlvbk5vZGUpXG5cbiAgaWYgKGRlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgaXNNdXRhdGlvbiA9IGRlZnNbMF0hLm9wZXJhdGlvbiA9PT0gT3BlcmF0aW9uVHlwZU5vZGUuTVVUQVRJT05cbiAgfVxuXG4gIHJldHVybiBpc011dGF0aW9uXG59XG5cbmV4cG9ydCBjb25zdCBhbmFseXplRG9jdW1lbnQgPSAoXG4gIGRvY3VtZW50OiBSZXF1ZXN0RG9jdW1lbnQsXG4gIGV4Y2x1ZGVPcGVyYXRpb25OYW1lPzogYm9vbGVhbixcbik6IHsgZXhwcmVzc2lvbjogc3RyaW5nOyBvcGVyYXRpb25OYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGlzTXV0YXRpb246IGJvb2xlYW4gfSA9PiB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSB0eXBlb2YgZG9jdW1lbnQgPT09IGBzdHJpbmdgID8gZG9jdW1lbnQgOiBwcmludChkb2N1bWVudClcblxuICBsZXQgaXNNdXRhdGlvbiA9IGZhbHNlXG4gIGxldCBvcGVyYXRpb25OYW1lID0gdW5kZWZpbmVkXG5cbiAgaWYgKGV4Y2x1ZGVPcGVyYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgaXNNdXRhdGlvbiwgb3BlcmF0aW9uTmFtZSB9XG4gIH1cblxuICBjb25zdCBkb2NOb2RlID0gdHJ5Q2F0Y2goKCkgPT4gKHR5cGVvZiBkb2N1bWVudCA9PT0gYHN0cmluZ2AgPyBwYXJzZShkb2N1bWVudCkgOiBkb2N1bWVudCkpXG4gIGlmIChkb2NOb2RlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCBpc011dGF0aW9uLCBvcGVyYXRpb25OYW1lIH1cbiAgfVxuXG4gIG9wZXJhdGlvbk5hbWUgPSBleHRyYWN0T3BlcmF0aW9uTmFtZShkb2NOb2RlKVxuICBpc011dGF0aW9uID0gZXh0cmFjdElzTXV0YXRpb24oZG9jTm9kZSlcblxuICByZXR1cm4geyBleHByZXNzaW9uLCBvcGVyYXRpb25OYW1lLCBpc011dGF0aW9uIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEpzb25TZXJpYWxpemVyIH0gZnJvbSAnLi90eXBlcy5qcydcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRKc29uU2VyaWFsaXplcjogSnNvblNlcmlhbGl6ZXIgPSBKU09OXG4iLCAiaW1wb3J0IHsgQUNDRVBUX0hFQURFUiwgQ09OVEVOVF9UWVBFX0dRTCwgQ09OVEVOVF9UWVBFX0hFQURFUiwgQ09OVEVOVF9UWVBFX0pTT04gfSBmcm9tICcuLi8uLi9saWIvaHR0cC5qcydcbmltcG9ydCB7IGNhc2VzRXhoYXVzdGVkLCB1cHBlcmNhc2UsIHppcCB9IGZyb20gJy4uLy4uL2xpYi9wcmVsdWRlLmpzJ1xuaW1wb3J0IHsgQ2xpZW50RXJyb3IgfSBmcm9tICcuLi9jbGFzc2VzL0NsaWVudEVycm9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0U2luZ2xlIH0gZnJvbSAnLi4vbGliL2dyYXBocWwuanMnXG5pbXBvcnQge1xuICBjbGVhblF1ZXJ5LFxuICBpc0dyYXBoUUxDb250ZW50VHlwZSxcbiAgaXNSZXF1ZXN0UmVzdWx0SGF2ZUVycm9ycyxcbiAgcGFyc2VHcmFwaFFMRXhlY3V0aW9uUmVzdWx0LFxufSBmcm9tICcuLi9saWIvZ3JhcGhxbC5qcydcbmltcG9ydCB7IGRlZmF1bHRKc29uU2VyaWFsaXplciB9IGZyb20gJy4vZGVmYXVsdEpzb25TZXJpYWxpemVyLmpzJ1xuaW1wb3J0IHR5cGUge1xuICBCYXRjaFZhcmlhYmxlcyxcbiAgRmV0Y2gsXG4gIEZldGNoT3B0aW9ucyxcbiAgR3JhcGhRTENsaWVudFJlc3BvbnNlLFxuICBIVFRQTWV0aG9kSW5wdXQsXG4gIEpzb25TZXJpYWxpemVyLFxuICBSZXF1ZXN0TWlkZGxld2FyZSxcbiAgVmFyaWFibGVzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5pbnRlcmZhY2UgSW5wdXQge1xuICB1cmw6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSBmb3IgcXVlcmllcy4gTm90ZSB0aGF0IG11dGF0aW9ucyBhcmUgQUxXQVlTIHNlbnQgYXMgUE9TVCByZXF1ZXN0cyAoW3BlciBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cC9ibG9iL21haW4vc3BlYy9HcmFwaFFMT3ZlckhUVFAubWQ/cmdoLWxpbmstZGF0ZT0yMDIyLTA2LTAyVDA5JTNBMzAlM0E1M1opKS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgJ1BPU1QnYFxuICAgKi9cbiAgbWV0aG9kPzogSFRUUE1ldGhvZElucHV0XG4gIGZldGNoPzogRmV0Y2hcbiAgZmV0Y2hPcHRpb25zOiBGZXRjaE9wdGlvbnNcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0XG4gIG1pZGRsZXdhcmU/OiBSZXF1ZXN0TWlkZGxld2FyZVxuICByZXF1ZXN0OlxuICAgIHwge1xuICAgICAgX3RhZzogJ1NpbmdsZSdcbiAgICAgIHZhcmlhYmxlcz86IFZhcmlhYmxlc1xuICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlzTXV0YXRpb246IGJvb2xlYW5cbiAgICAgICAgb3BlcmF0aW9uTmFtZT86IHN0cmluZ1xuICAgICAgfVxuICAgIH1cbiAgICB8IHtcbiAgICAgIF90YWc6ICdCYXRjaCdcbiAgICAgIHF1ZXJ5OiBzdHJpbmdbXVxuICAgICAgb3BlcmF0aW9uTmFtZT86IHVuZGVmaW5lZFxuICAgICAgaGFzTXV0YXRpb25zOiBib29sZWFuXG4gICAgICB2YXJpYWJsZXM/OiBCYXRjaFZhcmlhYmxlc1xuICAgIH1cbn1cblxuLy8gQHRzLWV4cGVjdC1lcnJvciB0b2RvXG5leHBvcnQgY29uc3QgcnVuUmVxdWVzdCA9IGFzeW5jIChpbnB1dDogSW5wdXQpOiBQcm9taXNlPENsaWVudEVycm9yIHwgR3JhcGhRTENsaWVudFJlc3BvbnNlPGFueT4+ID0+IHtcbiAgLy8gdG9kbyBtYWtlIGEgQ29uZmlnIHR5cGVcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIC4uLmlucHV0LFxuICAgIG1ldGhvZDogaW5wdXQucmVxdWVzdC5fdGFnID09PSBgU2luZ2xlYFxuICAgICAgPyBpbnB1dC5yZXF1ZXN0LmRvY3VtZW50LmlzTXV0YXRpb25cbiAgICAgICAgPyBgUE9TVGBcbiAgICAgICAgOiB1cHBlcmNhc2UoaW5wdXQubWV0aG9kID8/IGBwb3N0YClcbiAgICAgIDogaW5wdXQucmVxdWVzdC5oYXNNdXRhdGlvbnNcbiAgICAgID8gYFBPU1RgXG4gICAgICA6IHVwcGVyY2FzZShpbnB1dC5tZXRob2QgPz8gYHBvc3RgKSxcbiAgICBmZXRjaE9wdGlvbnM6IHtcbiAgICAgIC4uLmlucHV0LmZldGNoT3B0aW9ucyxcbiAgICAgIGVycm9yUG9saWN5OiBpbnB1dC5mZXRjaE9wdGlvbnMuZXJyb3JQb2xpY3kgPz8gYG5vbmVgLFxuICAgIH0sXG4gIH1cbiAgY29uc3QgZmV0Y2hlciA9IGNyZWF0ZUZldGNoZXIoY29uZmlnLm1ldGhvZClcbiAgY29uc3QgZmV0Y2hSZXNwb25zZSA9IGF3YWl0IGZldGNoZXIoY29uZmlnKVxuXG4gIGlmICghZmV0Y2hSZXNwb25zZS5vaykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50RXJyb3IoXG4gICAgICB7IHN0YXR1czogZmV0Y2hSZXNwb25zZS5zdGF0dXMsIGhlYWRlcnM6IGZldGNoUmVzcG9uc2UuaGVhZGVycyB9LFxuICAgICAge1xuICAgICAgICBxdWVyeTogaW5wdXQucmVxdWVzdC5fdGFnID09PSBgU2luZ2xlYCA/IGlucHV0LnJlcXVlc3QuZG9jdW1lbnQuZXhwcmVzc2lvbiA6IGlucHV0LnJlcXVlc3QucXVlcnksXG4gICAgICAgIHZhcmlhYmxlczogaW5wdXQucmVxdWVzdC52YXJpYWJsZXMsXG4gICAgICB9LFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUmVzdWx0RnJvbVJlc3BvbnNlKFxuICAgIGZldGNoUmVzcG9uc2UsXG4gICAgaW5wdXQuZmV0Y2hPcHRpb25zLmpzb25TZXJpYWxpemVyID8/IGRlZmF1bHRKc29uU2VyaWFsaXplcixcbiAgKVxuXG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmVzdWx0IC8vIHRvZG8gc29tZXRoaW5nIGJldHRlclxuXG4gIGNvbnN0IGNsaWVudFJlc3BvbnNlQmFzZSA9IHtcbiAgICBzdGF0dXM6IGZldGNoUmVzcG9uc2Uuc3RhdHVzLFxuICAgIGhlYWRlcnM6IGZldGNoUmVzcG9uc2UuaGVhZGVycyxcbiAgfVxuXG4gIGlmIChpc1JlcXVlc3RSZXN1bHRIYXZlRXJyb3JzKHJlc3VsdCkgJiYgY29uZmlnLmZldGNoT3B0aW9ucy5lcnJvclBvbGljeSA9PT0gYG5vbmVgKSB7XG4gICAgLy8gdG9kbyB0aGlzIGNsaWVudCByZXNwb25zZSBvbiBlcnJvciBpcyBub3QgY29uc2lzdGVudCB3aXRoIHRoZSBkYXRhIHR5cGUgZm9yIHN1Y2Nlc3NcbiAgICBjb25zdCBjbGllbnRSZXNwb25zZSA9IHJlc3VsdC5fdGFnID09PSBgQmF0Y2hgXG4gICAgICA/IHsgLi4ucmVzdWx0LmV4ZWN1dGlvblJlc3VsdHMsIC4uLmNsaWVudFJlc3BvbnNlQmFzZSB9XG4gICAgICA6IHtcbiAgICAgICAgLi4ucmVzdWx0LmV4ZWN1dGlvblJlc3VsdCxcbiAgICAgICAgLi4uY2xpZW50UmVzcG9uc2VCYXNlLFxuICAgICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdG9kb1xuICAgIHJldHVybiBuZXcgQ2xpZW50RXJyb3IoY2xpZW50UmVzcG9uc2UsIHtcbiAgICAgIHF1ZXJ5OiBpbnB1dC5yZXF1ZXN0Ll90YWcgPT09IGBTaW5nbGVgID8gaW5wdXQucmVxdWVzdC5kb2N1bWVudC5leHByZXNzaW9uIDogaW5wdXQucmVxdWVzdC5xdWVyeSxcbiAgICAgIHZhcmlhYmxlczogaW5wdXQucmVxdWVzdC52YXJpYWJsZXMsXG4gICAgfSlcbiAgfVxuICBzd2l0Y2ggKHJlc3VsdC5fdGFnKSB7XG4gICAgY2FzZSBgU2luZ2xlYDpcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdG9kb1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY2xpZW50UmVzcG9uc2VCYXNlLFxuICAgICAgICAuLi5leGVjdXRpb25SZXN1bHRDbGllbnRSZXNwb25zZUZpZWxkcyhjb25maWcpKHJlc3VsdC5leGVjdXRpb25SZXN1bHQpLFxuICAgICAgfVxuICAgIGNhc2UgYEJhdGNoYDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNsaWVudFJlc3BvbnNlQmFzZSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmV4ZWN1dGlvblJlc3VsdHMubWFwKGV4ZWN1dGlvblJlc3VsdENsaWVudFJlc3BvbnNlRmllbGRzKGNvbmZpZykpLFxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlc0V4aGF1c3RlZChyZXN1bHQpXG4gIH1cbn1cblxuY29uc3QgZXhlY3V0aW9uUmVzdWx0Q2xpZW50UmVzcG9uc2VGaWVsZHMgPSAoJHBhcmFtczogSW5wdXQpID0+IChleGVjdXRpb25SZXN1bHQ6IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb25zOiBleGVjdXRpb25SZXN1bHQuZXh0ZW5zaW9ucyxcbiAgICBkYXRhOiBleGVjdXRpb25SZXN1bHQuZGF0YSxcbiAgICBlcnJvcnM6ICRwYXJhbXMuZmV0Y2hPcHRpb25zLmVycm9yUG9saWN5ID09PSBgYWxsYCA/IGV4ZWN1dGlvblJlc3VsdC5lcnJvcnMgOiB1bmRlZmluZWQsXG4gIH1cbn1cblxuY29uc3QgcGFyc2VSZXN1bHRGcm9tUmVzcG9uc2UgPSBhc3luYyAocmVzcG9uc2U6IFJlc3BvbnNlLCBqc29uU2VyaWFsaXplcjogSnNvblNlcmlhbGl6ZXIpID0+IHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT05URU5UX1RZUEVfSEVBREVSKVxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gIGlmIChjb250ZW50VHlwZSAmJiBpc0dyYXBoUUxDb250ZW50VHlwZShjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcGFyc2VHcmFwaFFMRXhlY3V0aW9uUmVzdWx0KGpzb25TZXJpYWxpemVyLnBhcnNlKHRleHQpKVxuICB9IGVsc2Uge1xuICAgIC8vIHRvZG8gd2hhdCBpcyB0aGlzIGdvb2QgZm9yLi4uPyBTZWVtcyB2ZXJ5IHJhbmRvbS91bmRlZmluZWRcbiAgICByZXR1cm4gcGFyc2VHcmFwaFFMRXhlY3V0aW9uUmVzdWx0KHRleHQpXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRmV0Y2hlciA9IChtZXRob2Q6ICdHRVQnIHwgJ1BPU1QnKSA9PiBhc3luYyAocGFyYW1zOiBJbnB1dCkgPT4ge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocGFyYW1zLmhlYWRlcnMpXG4gIGxldCBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyB8IG51bGwgPSBudWxsXG4gIGxldCBib2R5ID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFoZWFkZXJzLmhhcyhBQ0NFUFRfSEVBREVSKSkge1xuICAgIGhlYWRlcnMuc2V0KEFDQ0VQVF9IRUFERVIsIFtDT05URU5UX1RZUEVfR1FMLCBDT05URU5UX1RZUEVfSlNPTl0uam9pbihgLCBgKSlcbiAgfVxuXG4gIGlmIChtZXRob2QgPT09IGBQT1NUYCkge1xuICAgIGNvbnN0ICRqc29uU2VyaWFsaXplciA9IHBhcmFtcy5mZXRjaE9wdGlvbnMuanNvblNlcmlhbGl6ZXIgPz8gZGVmYXVsdEpzb25TZXJpYWxpemVyXG4gICAgYm9keSA9ICRqc29uU2VyaWFsaXplci5zdHJpbmdpZnkoYnVpbGRCb2R5KHBhcmFtcykpXG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSBgc3RyaW5nYCAmJiAhaGVhZGVycy5oYXMoQ09OVEVOVF9UWVBFX0hFQURFUikpIHtcbiAgICAgIGhlYWRlcnMuc2V0KENPTlRFTlRfVFlQRV9IRUFERVIsIENPTlRFTlRfVFlQRV9KU09OKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBidWlsZFF1ZXJ5UGFyYW1zKHBhcmFtcylcbiAgfVxuXG4gIGNvbnN0IGluaXQ6IFJlcXVlc3RJbml0ID0geyBtZXRob2QsIGhlYWRlcnMsIGJvZHksIC4uLnBhcmFtcy5mZXRjaE9wdGlvbnMgfVxuXG4gIGxldCB1cmwgPSBuZXcgVVJMKHBhcmFtcy51cmwpXG4gIGxldCBpbml0UmVzb2x2ZWQgPSBpbml0XG5cbiAgaWYgKHBhcmFtcy5taWRkbGV3YXJlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgcGFyYW1zLm1pZGRsZXdhcmUoe1xuICAgICAgICAuLi5pbml0LFxuICAgICAgICB1cmw6IHBhcmFtcy51cmwsXG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IHBhcmFtcy5yZXF1ZXN0Ll90YWcgPT09IGBTaW5nbGVgID8gcGFyYW1zLnJlcXVlc3QuZG9jdW1lbnQub3BlcmF0aW9uTmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFyaWFibGVzOiBwYXJhbXMucmVxdWVzdC52YXJpYWJsZXMsXG4gICAgICB9KSxcbiAgICApXG4gICAgY29uc3QgeyB1cmw6IHVybE5ldywgLi4uaW5pdE5ldyB9ID0gcmVzdWx0XG4gICAgdXJsID0gbmV3IFVSTCh1cmxOZXcpXG4gICAgaW5pdFJlc29sdmVkID0gaW5pdE5ld1xuICB9XG5cbiAgaWYgKHNlYXJjaFBhcmFtcykge1xuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0ICRmZXRjaCA9IHBhcmFtcy5mZXRjaCA/PyBmZXRjaFxuICByZXR1cm4gYXdhaXQgJGZldGNoKHVybCwgaW5pdFJlc29sdmVkKVxufVxuXG5jb25zdCBidWlsZEJvZHkgPSAocGFyYW1zOiBJbnB1dCkgPT4ge1xuICBzd2l0Y2ggKHBhcmFtcy5yZXF1ZXN0Ll90YWcpIHtcbiAgICBjYXNlIGBTaW5nbGVgOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnk6IHBhcmFtcy5yZXF1ZXN0LmRvY3VtZW50LmV4cHJlc3Npb24sXG4gICAgICAgIHZhcmlhYmxlczogcGFyYW1zLnJlcXVlc3QudmFyaWFibGVzLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiBwYXJhbXMucmVxdWVzdC5kb2N1bWVudC5vcGVyYXRpb25OYW1lLFxuICAgICAgfVxuICAgIGNhc2UgYEJhdGNoYDpcbiAgICAgIHJldHVybiB6aXAocGFyYW1zLnJlcXVlc3QucXVlcnksIHBhcmFtcy5yZXF1ZXN0LnZhcmlhYmxlcyA/PyBbXSkubWFwKChbcXVlcnksIHZhcmlhYmxlc10pID0+ICh7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICB2YXJpYWJsZXMsXG4gICAgICB9KSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgY2FzZXNFeGhhdXN0ZWQocGFyYW1zLnJlcXVlc3QpXG4gIH1cbn1cblxuY29uc3QgYnVpbGRRdWVyeVBhcmFtcyA9IChwYXJhbXM6IElucHV0KTogVVJMU2VhcmNoUGFyYW1zID0+IHtcbiAgY29uc3QgJGpzb25TZXJpYWxpemVyID0gcGFyYW1zLmZldGNoT3B0aW9ucy5qc29uU2VyaWFsaXplciA/PyBkZWZhdWx0SnNvblNlcmlhbGl6ZXJcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIHN3aXRjaCAocGFyYW1zLnJlcXVlc3QuX3RhZykge1xuICAgIGNhc2UgYFNpbmdsZWA6IHtcbiAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYHF1ZXJ5YCwgY2xlYW5RdWVyeShwYXJhbXMucmVxdWVzdC5kb2N1bWVudC5leHByZXNzaW9uKSlcbiAgICAgIGlmIChwYXJhbXMucmVxdWVzdC52YXJpYWJsZXMpIHtcbiAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgdmFyaWFibGVzYCwgJGpzb25TZXJpYWxpemVyLnN0cmluZ2lmeShwYXJhbXMucmVxdWVzdC52YXJpYWJsZXMpKVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yZXF1ZXN0LmRvY3VtZW50Lm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgb3BlcmF0aW9uTmFtZWAsIHBhcmFtcy5yZXF1ZXN0LmRvY3VtZW50Lm9wZXJhdGlvbk5hbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoUGFyYW1zXG4gICAgfVxuICAgIGNhc2UgYEJhdGNoYDoge1xuICAgICAgY29uc3QgdmFyaWFibGVzU2VyaWFsaXplZCA9IHBhcmFtcy5yZXF1ZXN0LnZhcmlhYmxlcz8ubWFwKCh2KSA9PiAkanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KHYpKSA/PyBbXVxuICAgICAgY29uc3QgcXVlcmllc0NsZWFuZWQgPSBwYXJhbXMucmVxdWVzdC5xdWVyeS5tYXAoY2xlYW5RdWVyeSlcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB6aXAocXVlcmllc0NsZWFuZWQsIHZhcmlhYmxlc1NlcmlhbGl6ZWQpLm1hcCgoW3F1ZXJ5LCB2YXJpYWJsZXNdKSA9PiAoe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSkpXG4gICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGBxdWVyeWAsICRqc29uU2VyaWFsaXplci5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgICByZXR1cm4gc2VhcmNoUGFyYW1zXG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBjYXNlc0V4aGF1c3RlZChwYXJhbXMucmVxdWVzdClcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVHlwZWREb2N1bWVudE5vZGUgfSBmcm9tICdAZ3JhcGhxbC10eXBlZC1kb2N1bWVudC1ub2RlL2NvcmUnXG5pbXBvcnQgeyBjYWxsT3JJZGVudGl0eSwgSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vbGliL3ByZWx1ZGUuanMnXG5pbXBvcnQgdHlwZSB7IEJhdGNoUmVxdWVzdERvY3VtZW50LCBCYXRjaFJlcXVlc3RzT3B0aW9ucywgQmF0Y2hSZXN1bHQgfSBmcm9tICcuLi9mdW5jdGlvbnMvYmF0Y2hSZXF1ZXN0cy5qcydcbmltcG9ydCB7IHBhcnNlQmF0Y2hSZXF1ZXN0QXJncyB9IGZyb20gJy4uL2Z1bmN0aW9ucy9iYXRjaFJlcXVlc3RzLmpzJ1xuaW1wb3J0IHsgcGFyc2VSYXdSZXF1ZXN0QXJncyB9IGZyb20gJy4uL2Z1bmN0aW9ucy9yYXdSZXF1ZXN0LmpzJ1xuaW1wb3J0IHsgcGFyc2VSZXF1ZXN0QXJncyB9IGZyb20gJy4uL2Z1bmN0aW9ucy9yZXF1ZXN0LmpzJ1xuaW1wb3J0IHsgYW5hbHl6ZURvY3VtZW50IH0gZnJvbSAnLi4vaGVscGVycy9hbmFseXplRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBydW5SZXF1ZXN0IH0gZnJvbSAnLi4vaGVscGVycy9ydW5SZXF1ZXN0LmpzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0RG9jdW1lbnQsIFJlcXVlc3RPcHRpb25zLCBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3MgfSBmcm9tICcuLi9oZWxwZXJzL3R5cGVzLmpzJ1xuaW1wb3J0IHtcbiAgdHlwZSBHcmFwaFFMQ2xpZW50UmVzcG9uc2UsXG4gIHR5cGUgUmF3UmVxdWVzdE9wdGlvbnMsXG4gIHR5cGUgUmVxdWVzdENvbmZpZyxcbiAgdHlwZSBWYXJpYWJsZXMsXG59IGZyb20gJy4uL2hlbHBlcnMvdHlwZXMuanMnXG5cbi8qKlxuICogR3JhcGhRTCBDbGllbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaFFMQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB1cmw6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVxdWVzdENvbmZpZzogUmVxdWVzdENvbmZpZyA9IHt9LFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBHcmFwaFFMIHF1ZXJ5IHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICByYXdSZXF1ZXN0OiBSYXdSZXF1ZXN0TWV0aG9kID0gYXN5bmMgPFxuICAgIFQsXG4gICAgJFZhcmlhYmxlcyBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcyxcbiAgPihcbiAgICAuLi5hcmdzOiBSYXdSZXF1ZXN0TWV0aG9kQXJnczwkVmFyaWFibGVzPlxuICApOiBQcm9taXNlPEdyYXBoUUxDbGllbnRSZXNwb25zZTxUPj4gPT4ge1xuICAgIGNvbnN0IFtxdWVyeU9yT3B0aW9ucywgdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVyc10gPSBhcmdzXG4gICAgY29uc3QgcmF3UmVxdWVzdE9wdGlvbnMgPSBwYXJzZVJhd1JlcXVlc3RBcmdzPCRWYXJpYWJsZXM+KFxuICAgICAgcXVlcnlPck9wdGlvbnMsXG4gICAgICB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVycyxcbiAgICApXG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICAgIG1ldGhvZCA9IGBQT1NUYCxcbiAgICAgIHJlcXVlc3RNaWRkbGV3YXJlLFxuICAgICAgcmVzcG9uc2VNaWRkbGV3YXJlLFxuICAgICAgZXhjbHVkZU9wZXJhdGlvbk5hbWUsXG4gICAgICAuLi5mZXRjaE9wdGlvbnNcbiAgICB9ID0gdGhpcy5yZXF1ZXN0Q29uZmlnXG4gICAgY29uc3QgeyB1cmwgfSA9IHRoaXNcbiAgICBpZiAocmF3UmVxdWVzdE9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZldGNoT3B0aW9ucy5zaWduYWwgPSByYXdSZXF1ZXN0T3B0aW9ucy5zaWduYWxcbiAgICB9XG5cbiAgICBjb25zdCBkb2N1bWVudCA9IGFuYWx5emVEb2N1bWVudChcbiAgICAgIHJhd1JlcXVlc3RPcHRpb25zLnF1ZXJ5LFxuICAgICAgZXhjbHVkZU9wZXJhdGlvbk5hbWUsXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBydW5SZXF1ZXN0KHtcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgX3RhZzogYFNpbmdsZWAsXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB2YXJpYWJsZXM6IHJhd1JlcXVlc3RPcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLkhlYWRlcnNJbml0VG9QbGFpbk9iamVjdChjYWxsT3JJZGVudGl0eShoZWFkZXJzKSksXG4gICAgICAgIC4uLkhlYWRlcnNJbml0VG9QbGFpbk9iamVjdChyYXdSZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0SGVhZGVycyksXG4gICAgICB9LFxuICAgICAgZmV0Y2gsXG4gICAgICBtZXRob2QsXG4gICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICBtaWRkbGV3YXJlOiByZXF1ZXN0TWlkZGxld2FyZSxcbiAgICB9KVxuXG4gICAgaWYgKHJlc3BvbnNlTWlkZGxld2FyZSkge1xuICAgICAgYXdhaXQgcmVzcG9uc2VNaWRkbGV3YXJlKHJlc3BvbnNlLCB7XG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IGRvY3VtZW50Lm9wZXJhdGlvbk5hbWUsXG4gICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3BvbnNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIEdyYXBoUUwgZG9jdW1lbnQgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIC8vIGRwcmludC1pZ25vcmVcbiAgYXN5bmMgcmVxdWVzdDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihkb2N1bWVudDogUmVxdWVzdERvY3VtZW50IHwgVHlwZWREb2N1bWVudE5vZGU8VCwgVj4sIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj4pOiBQcm9taXNlPFQ+XG4gIGFzeW5jIHJlcXVlc3Q8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4ob3B0aW9uczogUmVxdWVzdE9wdGlvbnM8ViwgVD4pOiBQcm9taXNlPFQ+XG4gIGFzeW5jIHJlcXVlc3Q8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gICAgZG9jdW1lbnRPck9wdGlvbnM6XG4gICAgICB8IFJlcXVlc3REb2N1bWVudFxuICAgICAgfCBUeXBlZERvY3VtZW50Tm9kZTxULCBWPlxuICAgICAgfCBSZXF1ZXN0T3B0aW9uczxWPixcbiAgICAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+XG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IFt2YXJpYWJsZXMsIHJlcXVlc3RIZWFkZXJzXSA9IHZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzXG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBwYXJzZVJlcXVlc3RBcmdzKFxuICAgICAgZG9jdW1lbnRPck9wdGlvbnMsXG4gICAgICB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVycyxcbiAgICApXG5cbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLFxuICAgICAgbWV0aG9kID0gYFBPU1RgLFxuICAgICAgcmVxdWVzdE1pZGRsZXdhcmUsXG4gICAgICByZXNwb25zZU1pZGRsZXdhcmUsXG4gICAgICBleGNsdWRlT3BlcmF0aW9uTmFtZSxcbiAgICAgIC4uLmZldGNoT3B0aW9uc1xuICAgIH0gPSB0aGlzLnJlcXVlc3RDb25maWdcbiAgICBjb25zdCB7IHVybCB9ID0gdGhpc1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmV0Y2hPcHRpb25zLnNpZ25hbCA9IHJlcXVlc3RPcHRpb25zLnNpZ25hbFxuICAgIH1cblxuICAgIGNvbnN0IGFuYWx5emVkRG9jdW1lbnQgPSBhbmFseXplRG9jdW1lbnQoXG4gICAgICByZXF1ZXN0T3B0aW9ucy5kb2N1bWVudCxcbiAgICAgIGV4Y2x1ZGVPcGVyYXRpb25OYW1lLFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnVuUmVxdWVzdCh7XG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIF90YWc6IGBTaW5nbGVgLFxuICAgICAgICBkb2N1bWVudDogYW5hbHl6ZWREb2N1bWVudCxcbiAgICAgICAgdmFyaWFibGVzOiByZXF1ZXN0T3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QoY2FsbE9ySWRlbnRpdHkoaGVhZGVycykpLFxuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QocmVxdWVzdE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpLFxuICAgICAgfSxcbiAgICAgIGZldGNoLFxuICAgICAgbWV0aG9kLFxuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgbWlkZGxld2FyZTogcmVxdWVzdE1pZGRsZXdhcmUsXG4gICAgfSlcblxuICAgIGlmIChyZXNwb25zZU1pZGRsZXdhcmUpIHtcbiAgICAgIGF3YWl0IHJlc3BvbnNlTWlkZGxld2FyZShyZXNwb25zZSwge1xuICAgICAgICBvcGVyYXRpb25OYW1lOiBhbmFseXplZERvY3VtZW50Lm9wZXJhdGlvbk5hbWUsXG4gICAgICAgIHZhcmlhYmxlczogcmVxdWVzdE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgcmVzcG9uc2VcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgR3JhcGhRTCBkb2N1bWVudHMgaW4gYmF0Y2ggdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIGFzeW5jIGJhdGNoUmVxdWVzdHM8XG4gICAgJEJhdGNoUmVzdWx0IGV4dGVuZHMgQmF0Y2hSZXN1bHQsXG4gICAgJFZhcmlhYmxlcyBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcyxcbiAgPihcbiAgICBkb2N1bWVudHM6IEJhdGNoUmVxdWVzdERvY3VtZW50PCRWYXJpYWJsZXM+W10sXG4gICAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdCxcbiAgKTogUHJvbWlzZTwkQmF0Y2hSZXN1bHQ+XG4gIGFzeW5jIGJhdGNoUmVxdWVzdHM8XG4gICAgJEJhdGNoUmVzdWx0IGV4dGVuZHMgQmF0Y2hSZXN1bHQsXG4gICAgJFZhcmlhYmxlcyBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcyxcbiAgPihvcHRpb25zOiBCYXRjaFJlcXVlc3RzT3B0aW9uczwkVmFyaWFibGVzPik6IFByb21pc2U8JEJhdGNoUmVzdWx0PlxuICBhc3luYyBiYXRjaFJlcXVlc3RzPFxuICAgICRCYXRjaFJlc3VsdCBleHRlbmRzIEJhdGNoUmVzdWx0LFxuICAgICRWYXJpYWJsZXMgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXMsXG4gID4oXG4gICAgZG9jdW1lbnRzT3JPcHRpb25zOlxuICAgICAgfCBCYXRjaFJlcXVlc3REb2N1bWVudDwkVmFyaWFibGVzPltdXG4gICAgICB8IEJhdGNoUmVxdWVzdHNPcHRpb25zPCRWYXJpYWJsZXM+LFxuICAgIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXQsXG4gICk6IFByb21pc2U8JEJhdGNoUmVzdWx0PiB7XG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0T3B0aW9ucyA9IHBhcnNlQmF0Y2hSZXF1ZXN0QXJnczwkVmFyaWFibGVzPihcbiAgICAgIGRvY3VtZW50c09yT3B0aW9ucyxcbiAgICAgIHJlcXVlc3RIZWFkZXJzLFxuICAgIClcbiAgICBjb25zdCB7IGhlYWRlcnMsIGV4Y2x1ZGVPcGVyYXRpb25OYW1lLCAuLi5mZXRjaE9wdGlvbnMgfSA9IHRoaXMucmVxdWVzdENvbmZpZ1xuXG4gICAgaWYgKGJhdGNoUmVxdWVzdE9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZldGNoT3B0aW9ucy5zaWduYWwgPSBiYXRjaFJlcXVlc3RPcHRpb25zLnNpZ25hbFxuICAgIH1cblxuICAgIGNvbnN0IGFuYWx5emVkRG9jdW1lbnRzID0gYmF0Y2hSZXF1ZXN0T3B0aW9ucy5kb2N1bWVudHMubWFwKFxuICAgICAgKHsgZG9jdW1lbnQgfSkgPT4gYW5hbHl6ZURvY3VtZW50KGRvY3VtZW50LCBleGNsdWRlT3BlcmF0aW9uTmFtZSksXG4gICAgKVxuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gYW5hbHl6ZWREb2N1bWVudHMubWFwKCh7IGV4cHJlc3Npb24gfSkgPT4gZXhwcmVzc2lvbilcbiAgICBjb25zdCBoYXNNdXRhdGlvbnMgPSBhbmFseXplZERvY3VtZW50cy5zb21lKCh7IGlzTXV0YXRpb24gfSkgPT4gaXNNdXRhdGlvbilcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBiYXRjaFJlcXVlc3RPcHRpb25zLmRvY3VtZW50cy5tYXAoXG4gICAgICAoeyB2YXJpYWJsZXMgfSkgPT4gdmFyaWFibGVzLFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnVuUmVxdWVzdCh7XG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBfdGFnOiBgQmF0Y2hgLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHF1ZXJ5OiBleHByZXNzaW9ucyxcbiAgICAgICAgaGFzTXV0YXRpb25zLFxuICAgICAgICB2YXJpYWJsZXMsXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QoY2FsbE9ySWRlbnRpdHkoaGVhZGVycykpLFxuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QoYmF0Y2hSZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0SGVhZGVycyksXG4gICAgICB9LFxuICAgICAgZmV0Y2g6IHRoaXMucmVxdWVzdENvbmZpZy5mZXRjaCA/PyBnbG9iYWxUaGlzLmZldGNoLFxuICAgICAgbWV0aG9kOiB0aGlzLnJlcXVlc3RDb25maWcubWV0aG9kIHx8IGBQT1NUYCxcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgIG1pZGRsZXdhcmU6IHRoaXMucmVxdWVzdENvbmZpZy5yZXF1ZXN0TWlkZGxld2FyZSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdENvbmZpZy5yZXNwb25zZU1pZGRsZXdhcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVxdWVzdENvbmZpZy5yZXNwb25zZU1pZGRsZXdhcmUocmVzcG9uc2UsIHtcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyByZXNwb25zZVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gIH1cblxuICBzZXRIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnNJbml0KTogdGhpcyB7XG4gICAgdGhpcy5yZXF1ZXN0Q29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBoZWFkZXIgdG8gdGhlIGNsaWVudC4gQWxsIHN1YnNlcXVlbnQgcmVxdWVzdHMgd2lsbCBoYXZlIHRoaXMgaGVhZGVyLlxuICAgKi9cbiAgc2V0SGVhZGVyKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgeyBoZWFkZXJzIH0gPSB0aGlzLnJlcXVlc3RDb25maWdcblxuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAvLyB0b2RvIHdoYXQgaWYgaGVhZGVycyBpcyBpbiBuZXN0ZWQgYXJyYXkgZm9ybS4uLiA/XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRvZG9cbiAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVxdWVzdENvbmZpZy5oZWFkZXJzID0geyBba2V5XTogdmFsdWUgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBjbGllbnQgZW5kcG9pbnQuIEFsbCBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgc2VuZCB0byB0aGlzIGVuZHBvaW50LlxuICAgKi9cbiAgc2V0RW5kcG9pbnQodmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsID0gdmFsdWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmludGVyZmFjZSBSYXdSZXF1ZXN0TWV0aG9kIHtcbiAgPFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgdmFyaWFibGVzPzogVixcbiAgICByZXF1ZXN0SGVhZGVycz86IEhlYWRlcnNJbml0LFxuICApOiBQcm9taXNlPEdyYXBoUUxDbGllbnRSZXNwb25zZTxUPj5cbiAgPFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KG9wdGlvbnM6IFJhd1JlcXVlc3RPcHRpb25zPFY+KTogUHJvbWlzZTxcbiAgICBHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD5cbiAgPlxufVxuXG50eXBlIFJhd1JlcXVlc3RNZXRob2RBcmdzPFYgZXh0ZW5kcyBWYXJpYWJsZXM+ID1cbiAgfCBbcXVlcnk6IHN0cmluZywgdmFyaWFibGVzPzogViwgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdF1cbiAgfCBbUmF3UmVxdWVzdE9wdGlvbnM8Vj5dXG4iLCAiaW1wb3J0IHR5cGUgeyBUeXBlZERvY3VtZW50Tm9kZSB9IGZyb20gJ0BncmFwaHFsLXR5cGVkLWRvY3VtZW50LW5vZGUvY29yZSdcbmltcG9ydCB7IEdyYXBoUUxDbGllbnQgfSBmcm9tICcuLi9jbGFzc2VzL0dyYXBoUUxDbGllbnQuanMnXG5pbXBvcnQgdHlwZSB7IFJlcXVlc3REb2N1bWVudCwgUmVxdWVzdE9wdGlvbnMsIFZhcmlhYmxlcywgVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzIH0gZnJvbSAnLi4vaGVscGVycy90eXBlcy5qcydcblxuLyoqXG4gKiBTZW5kIGEgR3JhcGhRTCBEb2N1bWVudCB0byB0aGUgR3JhcGhRTCBzZXJ2ZXIgZm9yIGV4ZWN1dGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiAvLyBZb3UgY2FuIHBhc3MgYSByYXcgc3RyaW5nXG4gKlxuICogYXdhaXQgcmVxdWVzdCgnaHR0cHM6Ly9mb28uYmFyL2dyYXBocWwnLCBgXG4gKiAgIHtcbiAqICAgICBxdWVyeSB7XG4gKiAgICAgICB1c2Vyc1xuICogICAgIH1cbiAqICAgfVxuICogYClcbiAqXG4gKiAvLyBZb3UgY2FuIGFsc28gcGFzcyBhIEdyYXBoUUwgRG9jdW1lbnROb2RlLiBDb252ZW5pZW50IGlmIHlvdVxuICogLy8gYXJlIHVzaW5nIGdyYXBocWwtdGFnIHBhY2thZ2UuXG4gKlxuICogaW1wb3J0IGdxbCBmcm9tICdncmFwaHFsLXRhZydcbiAqXG4gKiBhd2FpdCByZXF1ZXN0KCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIGdxbGAuLi5gKVxuICpcbiAqIC8vIElmIHlvdSBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IHVzaW5nIERvY3VtZW50Tm9kZSBidXQganVzdFxuICogLy8gd2FudCB0aGUgdG9vbGluZyBzdXBwb3J0IGZvciBncWwgdGVtcGxhdGUgdGFnIGxpa2UgSURFIHN5bnRheFxuICogLy8gY29sb3JpbmcgYW5kIHByZXR0aWVyIGF1dG9mb3JtYXQgdGhlbiBub3RlIHlvdSBjYW4gdXNlIHRoZVxuICogLy8gcGFzc3Rocm91Z2ggZ3FsIHRhZyBzaGlwcGVkIHdpdGggZ3JhcGhxbC1yZXF1ZXN0IHRvIHNhdmUgYSBiaXRcbiAqIC8vIG9mIHBlcmZvcm1hbmNlIGFuZCBub3QgaGF2ZSB0byBpbnN0YWxsIGFub3RoZXIgZGVwIGludG8geW91ciBwcm9qZWN0LlxuICpcbiAqIGltcG9ydCB7IGdxbCB9IGZyb20gJ2dyYXBocWwtcmVxdWVzdCdcbiAqXG4gKiBhd2FpdCByZXF1ZXN0KCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIGdxbGAuLi5gKVxuICogYGBgXG4gKi9cbi8vIFJFTUFSS1M6IEluIG9yZGVyIHRvIGhhdmUgYXV0b2NvbXBsZXRlIGZvciBvcHRpb25zIHdvcmsgbWFrZSBpdCB0aGUgZmlyc3Qgb3ZlcmxvYWQuIElmIG5vdFxuLy8gdGhlbiBhdXRvY29tcGxldGUgd2lsbCBpbnN0ZWFkIHNob3cgdGhlIHZhcmlvdXMgbWV0aG9kcyBmb3IgYSBzdHJpbmcsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cbi8vIGRwcmludC1pZ25vcmVcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1ZXN0PFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KG9wdGlvbnM6IFJlcXVlc3RFeHRlbmRlZE9wdGlvbnM8ViwgVD4pOiBQcm9taXNlPFQ+XG4vLyBkcHJpbnQtaWdub3JlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPih1cmw6IHN0cmluZywgZG9jdW1lbnQ6IFJlcXVlc3REb2N1bWVudCB8IFR5cGVkRG9jdW1lbnROb2RlPFQsIFY+LCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+KTogUHJvbWlzZTxUPlxuLy8gZHByaW50LWlnbm9yZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPih1cmxPck9wdGlvbnM6IHN0cmluZyB8IFJlcXVlc3RFeHRlbmRlZE9wdGlvbnM8ViwgVD4sIGRvY3VtZW50PzogUmVxdWVzdERvY3VtZW50IHwgVHlwZWREb2N1bWVudE5vZGU8VCwgVj4sIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBwYXJzZVJlcXVlc3RFeHRlbmRlZEFyZ3M8Vj4odXJsT3JPcHRpb25zLCBkb2N1bWVudCwgLi4udmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnMpXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KHJlcXVlc3RPcHRpb25zLnVybClcbiAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0PFQsIFY+KHtcbiAgICAuLi5yZXF1ZXN0T3B0aW9ucyxcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVxdWVzdEFyZ3MgPSA8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gIGRvY3VtZW50T3JPcHRpb25zOiBSZXF1ZXN0RG9jdW1lbnQgfCBSZXF1ZXN0T3B0aW9uczxWPixcbiAgdmFyaWFibGVzPzogVixcbiAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdCxcbik6IFJlcXVlc3RPcHRpb25zPFY+ID0+IHtcbiAgcmV0dXJuIChkb2N1bWVudE9yT3B0aW9ucyBhcyBSZXF1ZXN0T3B0aW9uczxWPikuZG9jdW1lbnRcbiAgICA/IChkb2N1bWVudE9yT3B0aW9ucyBhcyBSZXF1ZXN0T3B0aW9uczxWPilcbiAgICA6ICh7XG4gICAgICBkb2N1bWVudDogZG9jdW1lbnRPck9wdGlvbnMgYXMgUmVxdWVzdERvY3VtZW50LFxuICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVyczogcmVxdWVzdEhlYWRlcnMsXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9IGFzIHVua25vd24gYXMgUmVxdWVzdE9wdGlvbnM8Vj4pXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RFeHRlbmRlZE9wdGlvbnM8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcywgVCA9IHVua25vd24+ID0ge1xuICB1cmw6IHN0cmluZ1xufSAmIFJlcXVlc3RPcHRpb25zPFYsIFQ+XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJlcXVlc3RFeHRlbmRlZEFyZ3MgPSA8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oXG4gIHVybE9yT3B0aW9uczogc3RyaW5nIHwgUmVxdWVzdEV4dGVuZGVkT3B0aW9uczxWPixcbiAgZG9jdW1lbnQ/OiBSZXF1ZXN0RG9jdW1lbnQsXG4gIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj5cbik6IFJlcXVlc3RFeHRlbmRlZE9wdGlvbnM8Vj4gPT4ge1xuICBjb25zdCBbdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVyc10gPSB2YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc1xuICByZXR1cm4gdHlwZW9mIHVybE9yT3B0aW9ucyA9PT0gYHN0cmluZ2BcbiAgICA/ICh7XG4gICAgICB1cmw6IHVybE9yT3B0aW9ucyxcbiAgICAgIGRvY3VtZW50OiBkb2N1bWVudCBhcyBSZXF1ZXN0RG9jdW1lbnQsXG4gICAgICB2YXJpYWJsZXMsXG4gICAgICByZXF1ZXN0SGVhZGVycyxcbiAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+KVxuICAgIDogdXJsT3JPcHRpb25zXG59XG4iLCAiLyoqXG4gKiBDb252ZW5pZW5jZSBwYXNzdGhyb3VnaCB0ZW1wbGF0ZSB0YWcgdG8gZ2V0IHRoZSBiZW5lZml0cyBvZiB0b29saW5nIGZvciB0aGUgZ3FsIHRlbXBsYXRlIHRhZy4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseSBwYXJzZSB0aGUgaW5wdXQgaW50byBhIEdyYXBoUUwgRG9jdW1lbnROb2RlIGxpa2UgZ3JhcGhxbC10YWcgcGFja2FnZSBkb2VzLiBJdCBqdXN0IHJldHVybnMgdGhlIHN0cmluZyB3aXRoIGFueSB2YXJpYWJsZXMgZ2l2ZW4gaW50ZXJwb2xhdGVkLiBDYW4gc2F2ZSB5b3UgYSBiaXQgb2YgcGVyZm9ybWFuY2UgYW5kIGhhdmluZyB0byBpbnN0YWxsIGFub3RoZXIgcGFja2FnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBpbXBvcnQgeyBncWwgfSBmcm9tICdncmFwaHFsLXJlcXVlc3QnXG4gKlxuICogYXdhaXQgcmVxdWVzdCgnaHR0cHM6Ly9mb28uYmFyL2dyYXBocWwnLCBncWxgLi4uYClcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogU2V2ZXJhbCB0b29scyBpbiB0aGUgTm9kZSBHcmFwaFFMIGVjb3N5c3RlbSBhcmUgaGFyZGNvZGVkIHRvIHNwZWNpYWxseSB0cmVhdCBhbnkgdGVtcGxhdGUgdGFnIG5hbWVkIFwiZ3FsXCIuIEZvciBleGFtcGxlIHNlZSB0aGlzIHByZXR0aWVyIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvaXNzdWVzLzQzNjAuIFVzaW5nIHRoaXMgdGVtcGxhdGUgdGFnIGhhcyBubyBydW50aW1lIGVmZmVjdCBiZXlvbmQgdmFyaWFibGUgaW50ZXJwb2xhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdxbCA9IChjaHVua3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi52YXJpYWJsZXM6IHVua25vd25bXSk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBjaHVua3MucmVkdWNlKFxuICAgIChhY2MsIGNodW5rLCBpbmRleCkgPT4gYCR7YWNjfSR7Y2h1bmt9JHtpbmRleCBpbiB2YXJpYWJsZXMgPyBTdHJpbmcodmFyaWFibGVzW2luZGV4XSkgOiBgYH1gLFxuICAgIGBgLFxuICApXG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDhDQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLE1BQ0UsTUFBUTtBQUFBLE1BQ1IsU0FBVztBQUFBLE1BQ1gsYUFBZTtBQUFBLE1BQ2YsTUFBUTtBQUFBLE1BQ1IsT0FBUztBQUFBLE1BQ1QsU0FBVztBQUFBLFFBQ1QsS0FBSztBQUFBLFVBQ0gsT0FBUztBQUFBLFVBQ1QsU0FBVztBQUFBLFVBQ1gsU0FBVztBQUFBLFFBQ2I7QUFBQSxRQUNBLFlBQVk7QUFBQSxRQUNaLGVBQWU7QUFBQSxRQUNmLHFCQUFxQjtBQUFBLFFBQ3JCLHdCQUF3QjtBQUFBLFFBQ3hCLHFCQUFxQjtBQUFBLFFBQ3JCLHdCQUF3QjtB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QUN0QjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUE7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUE7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUE7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7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QUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLGFBQUssZUFBZSxXQUFXLEtBQUs7QUFDcEMsWUFBSSx1QkFBTyxnQ0FBTztBQUFBLE1BQ3RCLENBQUM7QUFBQSxJQUNULENBQUM7QUFBQSxFQUNUO0FBQUEsRUFFQSxlQUFlLE9BQWU7QUFDMUIsVUFBTSxZQUFhLEtBQUssT0FBTyxJQUFJLE1BQU0sUUFBZ0I7QUFDekQsVUFBTSxVQUFlLFVBQUssV0FBVyxNQUFNO0FBQzNDLFVBQU0sYUFBYSxnQkFBZ0I7QUFBQTtBQUNuQyxJQUFHLGlCQUFjLFNBQVMsVUFBVTtBQUFBLEVBQ3hDO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtb2R1bGUiLCAiZnMiLCAicGF0aCIsICJjcnlwdG8iLCAicGFyc2UiLCAicmVxdWVzdCIsICJwYXRoIiwgIk9wZXJhdGlvblR5cGVOb2RlIiwgIkRpcmVjdGl2ZUxvY2F0aW9uIiwgIktpbmQiLCAiaW5kZW50IiwgIlRva2VuS2luZCIsICJpbnN0YW5jZU9mIiwgInBhdGgiLCAiZmV0Y2giLCAidmFyaWFibGVzIl0KfQo=
