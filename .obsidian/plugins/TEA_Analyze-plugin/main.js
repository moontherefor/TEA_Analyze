/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.7",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs2 = require("fs");
    var path2 = require("path");
    var os = require("os");
    var crypto2 = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse3(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs2.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
      }
      if (fs2.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path2.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path3 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs2.readFileSync(path3, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path3} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse3,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TextProcessingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var dotenv = __toESM(require_main());

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError = class extends Error {
  constructor(response, request2) {
    const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request2
    })}`;
    super(message);
    __publicField(this, "response");
    __publicField(this, "request");
    Object.setPrototypeOf(this, ClientError.prototype);
    this.response = response;
    this.request = request2;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b, _c;
    return (_c = (_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) != null ? _c : `GraphQL Error (Code: ${String(response.status)})`;
  }
};

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase();
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
var zip = (a, b) => a.map((k, i) => [k, b[i]]);
var HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== void 0) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
};
var HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v, k) => {
    o[k] = v;
  });
  return o;
};
var tryCatch = (fn) => {
  try {
    const result = fn();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
};
var errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
};
var isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
};
var casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
};
var isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path: path2, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  const document = parser.parseDocument();
  Object.defineProperty(document, "tokenCount", {
    enumerable: false,
    value: parser.tokenCount
  });
  return document;
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path2 = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path2.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path2, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path2.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path2.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`;
var CONTENT_TYPE_HEADER = `Content-Type`;
var CONTENT_TYPE_JSON = `application/json`;
var CONTENT_TYPE_GQL = `application/graphql-response+json`;

// node_modules/graphql-request/build/legacy/lib/graphql.js
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
};
var parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e) {
    return e;
  }
};
var parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors = void 0;
  let data = void 0;
  let extensions = void 0;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors,
    extensions
  };
};
var isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult);
var isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors);
var isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === Kind.OPERATION_DEFINITION;
};

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var extractOperationName = (document) => {
  var _a;
  let operationName = void 0;
  const defs = document.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = (_a = defs[0].name) == null ? void 0 : _a.value;
  }
  return operationName;
};
var extractIsMutation = (document) => {
  let isMutation = false;
  const defs = document.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === OperationTypeNode.MUTATION;
  }
  return isMutation;
};
var analyzeDocument = (document, excludeOperationName) => {
  const expression = typeof document === `string` ? document : print(document);
  let isMutation = false;
  let operationName = void 0;
  if (excludeOperationName) {
    return { expression, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document === `string` ? parse(document) : document);
  if (docNode instanceof Error) {
    return { expression, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression, operationName, isMutation };
};

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  var _a, _b, _c, _d;
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase((_a = input.method) != null ? _a : `post`) : input.request.hasMutations ? `POST` : uppercase((_b = input.method) != null ? _b : `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: (_c = input.fetchOptions.errorPolicy) != null ? _c : `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, (_d = input.fetchOptions.jsonSerializer) != null ? _d : defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
};
var executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : void 0
  };
};
var parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
};
var createFetcher = (method) => async (params) => {
  var _a, _b;
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = void 0;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = (_a = params.fetchOptions.jsonSerializer) != null ? _a : defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : void 0,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = (_b = params.fetch) != null ? _b : fetch;
  return await $fetch(url, initResolved);
};
var buildBody = (params) => {
  var _a;
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, (_a = params.request.variables) != null ? _a : []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
};
var buildQueryParams = (params) => {
  var _a, _b, _c;
  const $jsonSerializer = (_a = params.fetchOptions.jsonSerializer) != null ? _a : defaultJsonSerializer;
  const searchParams = new URLSearchParams();
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = (_c = (_b = params.request.variables) == null ? void 0 : _b.map((v) => $jsonSerializer.stringify(v))) != null ? _c : [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    __publicField(this, "rawRequest", async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const document = analyzeDocument(rawRequestOptions.query, excludeOperationName);
      const response = await runRequest({
        url,
        request: {
          _tag: `Single`,
          document,
          variables: rawRequestOptions.variables
        },
        headers: {
          ...HeadersInitToPlainObject(callOrIdentity(headers)),
          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
        },
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      });
      if (responseMiddleware) {
        await responseMiddleware(response, {
          operationName: document.operationName,
          variables,
          url: this.url
        });
      }
      if (response instanceof Error) {
        throw response;
      }
      return response;
    });
    this.url = url;
    this.requestConfig = requestConfig;
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    var _a;
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document }) => analyzeDocument(document, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression }) => expression);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: void 0,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: (_a = this.requestConfig.fetch) != null ? _a : globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: void 0,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};

// node_modules/graphql-request/build/legacy/functions/request.js
async function request(urlOrOptions, document, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRequestExtendedArgs = (urlOrOptions, document, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return typeof urlOrOptions === `string` ? {
    url: urlOrOptions,
    document,
    variables,
    requestHeaders,
    signal: void 0
  } : urlOrOptions;
};

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// main.ts
var DEFAULT_SETTINGS = {
  repo: "moontherefor/obsidian_sync_test",
  branch: "main"
};
var TextProcessingPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TextProcessingPluginSettingTab(this.app, this));
    this.addCommand({
      id: "convert-article-headings",
      name: "\u6CD5\u898F\u6574\u7406",
      callback: () => this.convertArticleHeadings()
    });
    this.addCommand({
      id: "clean-table",
      name: "\u689D\u6587\u5C0D\u7167\u8868\u6574\u7406",
      callback: () => this.cleanTable()
    });
    this.addCommand({
      id: "split-document",
      name: "\u6559\u6AA2\u8003\u984C\u62C6\u5206",
      callback: () => this.splitDocument()
    });
    this.addCommand({
      id: "pull-vault-from-github",
      name: "\u5F9E GitHub \u62C9\u53D6 Vault",
      callback: () => this.pullVaultFromGitHub()
    });
    this.addCommand({
      id: "push-current-file-to-github",
      name: "\u63A8\u9001\u7576\u524D\u6A94\u6848\u5230 GitHub",
      callback: () => this.pushCurrentFileToGitHub()
    });
    this.addCommand({
      id: "push-vault-to-github",
      name: "\u63A8\u9001 Vault \u5230 GitHub",
      callback: () => this.pushVaultToGitHub()
    });
    this.addCommand({
      id: "sync-vault-with-github",
      name: "\u540C\u6B65 Vault \u8207 GitHub",
      callback: () => this.syncVaultWithGitHub()
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        menu.addItem((item) => {
          item.setTitle("\u6CD5\u898F\u6574\u7406").setIcon("heading").onClick(() => {
            this.convertArticleHeadings();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u689D\u6587\u5C0D\u7167\u8868\u6574\u7406").setIcon("heading").onClick(() => {
            this.cleanTable();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u6559\u6AA2\u8003\u984C\u62C6\u5206").setIcon("scissors").onClick(() => {
            this.splitDocument();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u540C\u6B65 Vault \u8207 GitHub").setIcon("sync").onClick(() => {
            this.syncVaultWithGitHub();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u63A8\u9001\u7576\u524D\u6A94\u6848\u5230 GitHub").setIcon("cloud-upload").onClick(() => {
            this.pushCurrentFileToGitHub();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u63A8\u9001 Vault \u5230 GitHub").setIcon("cloud-upload").onClick(() => {
            this.pushVaultToGitHub();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u5F9E GitHub \u62C9\u53D6 Vault").setIcon("cloud-download").onClick(() => {
            this.pullVaultFromGitHub();
          });
        });
      })
    );
    this.ensureEnvFileIsIgnored();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * 確保 .env 文件被 .gitignore 忽略
   */
  async ensureEnvFileIsIgnored() {
    const gitignorePath = `/.gitignore`;
    const envFileEntry = ".env\n*.ini\n";
    try {
      const gitignoreFile = await this.app.vault.adapter.read(gitignorePath);
      if (!gitignoreFile.includes(".env")) {
        await this.app.vault.adapter.append(gitignorePath, ".env\n");
      }
      if (!gitignoreFile.includes("*.ini")) {
        await this.app.vault.adapter.append(gitignorePath, "*.ini\n");
      }
    } catch (error) {
      await this.app.vault.adapter.write(gitignorePath, envFileEntry);
    }
  }
  /**
   * 推送整個 Vault 到 GitHub
   */
  async pushVaultToGitHub() {
    await this.ensureEnvFileIsIgnored();
    const token = await this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const files = this.app.vault.getFiles().filter((file) => !file.path.endsWith(".ini"));
    const totalFiles = files.length;
    let successCount = 0;
    let failureCount = 0;
    const batchSize = 10;
    const progressNotice = new import_obsidian.Notice(`\u63A8\u9001\u9032\u5EA6: 0/${totalFiles}`, 0);
    for (let i = 0; i < totalFiles; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      for (const file of batch) {
        const filePath = file.path;
        const content = await this.app.vault.read(file);
        const message = `Update ${filePath}`;
        const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}`;
        const headers = {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        };
        console.log(`Pushing file: ${filePath}`);
        try {
          const response = await fetch(url, { headers });
          const data = await response.json();
          const sha = data.sha;
          const localSha = crypto.createHash("sha1").update(Buffer.from(content)).digest("hex");
          if (sha !== localSha) {
            const body = {
              message,
              content: Buffer.from(content).toString("base64"),
              // 使用 Buffer 進行 base64 編碼
              branch,
              sha
            };
            const pushResponse = await fetch(url, {
              method: "PUT",
              headers,
              body: JSON.stringify(body)
            });
            if (pushResponse.ok) {
              successCount++;
            } else {
              const errorData = await pushResponse.json();
              console.error(`Error pushing file ${filePath} to GitHub: ${errorData.message}`);
              failureCount++;
            }
          } else {
            successCount++;
          }
        } catch (error) {
          console.error(`Error pushing file ${filePath} to GitHub:`, error);
          failureCount++;
        }
        progressNotice.setMessage(`\u63A8\u9001\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
      }
    }
    progressNotice.hide();
    new import_obsidian.Notice(`\u63A8\u9001\u5B8C\u6210: \u6210\u529F ${successCount} \u500B\u6587\u4EF6, \u5931\u6557 ${failureCount} \u500B\u6587\u4EF6`);
  }
  /**
   * 推送當前編輯的單一檔案到 GitHub
   */
  async pushCurrentFileToGitHub() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("\u672A\u627E\u5230\u7576\u524D\u7DE8\u8F2F\u7684\u6A94\u6848");
      return;
    }
    const token = await this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const file = activeView.file;
    const filePath = file.path;
    const content = await this.app.vault.read(file);
    const message = `Update ${filePath}`;
    const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}`;
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
    console.log(`Pushing current file: ${filePath}`);
    try {
      const response = await fetch(url, { headers });
      const data = await response.json();
      const sha = data.sha;
      const localSha = crypto.createHash("sha1").update(Buffer.from(content)).digest("hex");
      if (sha !== localSha) {
        const body = {
          message,
          content: Buffer.from(content).toString("base64"),
          // 使用 Buffer 進行 base64 編碼
          branch,
          sha
        };
        const pushResponse = await fetch(url, {
          method: "PUT",
          headers,
          body: JSON.stringify(body)
        });
        if (pushResponse.ok) {
          new import_obsidian.Notice(`\u6A94\u6848 ${filePath} \u63A8\u9001\u6210\u529F`);
        } else {
          const errorData = await pushResponse.json();
          console.error(`Error pushing file ${filePath} to GitHub: ${errorData.message}`);
          new import_obsidian.Notice(`\u6A94\u6848 ${filePath} \u63A8\u9001\u5931\u6557`);
        }
      } else {
        new import_obsidian.Notice(`\u6A94\u6848 ${filePath} \u7121\u9700\u66F4\u65B0`);
      }
    } catch (error) {
      console.error(`Error pushing file ${filePath} to GitHub:`, error);
      new import_obsidian.Notice(`\u6A94\u6848 ${filePath} \u63A8\u9001\u5931\u6557`);
    }
  }
  /**
   * 從 GitHub 拉取整個 Vault
   */
  async pullVaultFromGitHub() {
    const token = await this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const endpoint = "https://api.github.com/graphql";
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
    const query = gql`
            query($owner: String!, $repo: String!, $branch: String!) {
                repository(owner: $owner, name: $repo) {
                    object(expression: $branch) {
                        ... on Commit {
                            tree {
                                entries {
                                    name
                                    type
                                    oid
                                    object {
                                        ... on Tree {
                                            entries {
                                                name
                                                type
                                                oid
                                                object {
                                                    ... on Blob {
                                                        text
                                                    }
                                                    ... on Tree {
                                                        entries {
                                                            name
                                                            type
                                                            oid
                                                            object {
                                                                ... on Blob {
                                                                    text
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        `;
    const [owner, repoName] = repo.split("/");
    const variables = {
      owner,
      repo: repoName,
      branch
    };
    try {
      const response = await request(endpoint, query, variables, headers);
      const files = this.flattenTree(response.repository.object.tree.entries);
      const totalFiles = files.length;
      let successCount = 0;
      let failureCount = 0;
      const progressNotice = new import_obsidian.Notice(`\u62C9\u53D6\u9032\u5EA6: 0/${totalFiles}`, 0);
      const pullPromises = files.map(async (file) => {
        var _a;
        const filePath = file.path;
        const content = (_a = file.object) == null ? void 0 : _a.text;
        console.log(`Pulling file: ${filePath}`);
        try {
          if (await this.app.vault.adapter.exists(filePath)) {
            const localContent = await this.app.vault.adapter.read(filePath);
            const localSha = crypto.createHash("sha1").update(Buffer.from(localContent)).digest("hex");
            if (localSha === file.oid) {
              successCount++;
              progressNotice.setMessage(`\u62C9\u53D6\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
              return;
            }
          }
          const dirPath = (0, import_obsidian.normalizePath)(path.dirname(filePath));
          await this.app.vault.adapter.mkdir(dirPath, { recursive: true });
          if (content !== void 0) {
            await this.app.vault.adapter.write(filePath, content);
            successCount++;
          } else {
            console.error(`Content for file ${filePath} is undefined`);
            failureCount++;
          }
        } catch (error) {
          console.error(`Error pulling file ${filePath} from GitHub:`, error);
          failureCount++;
        }
        progressNotice.setMessage(`\u62C9\u53D6\u9032\u5EA6: ${successCount + failureCount}/${totalFiles}`);
      });
      await Promise.all(pullPromises);
      progressNotice.hide();
      new import_obsidian.Notice(`\u62C9\u53D6\u5B8C\u6210: \u6210\u529F ${successCount} \u500B\u6587\u4EF6, \u5931\u6557 ${failureCount} \u500B\u6587\u4EF6`);
    } catch (error) {
      console.error(`Error pulling Vault from GitHub:`, error);
      new import_obsidian.Notice(`\u5F9E GitHub \u62C9\u53D6 Vault \u6642\u767C\u751F\u932F\u8AA4`);
    }
  }
  /**
   * 將樹狀結構展平為文件列表
   */
  flattenTree(entries, parentPath = "") {
    var _a;
    let files = [];
    console.log("Processing entries:", entries);
    if (!Array.isArray(entries)) {
      console.warn("flattenTree received invalid entries:", entries);
      return files;
    }
    for (const entry of entries) {
      console.log(`Checking entry: ${entry.name}`);
      const entryPath = parentPath ? `${parentPath}/${entry.name}` : entry.name;
      if (entry.name === "\u611F\u89BA\u5DEE\u7570.md") {
        console.log(`Found \u611F\u89BA\u5DEE\u7570.md at ${entryPath}`);
      }
      if (entry.type === "blob" && ((_a = entry.object) == null ? void 0 : _a.text)) {
        files.push({ ...entry, path: entryPath });
      } else if (entry.type === "tree" && entry.object) {
        files = files.concat(this.flattenTree(entry.object.entries, entryPath));
      }
    }
    return files;
  }
  /**
   * 同步 Vault 與 GitHub
   */
  async syncVaultWithGitHub() {
    const token = await this.getTokenFromEnv();
    if (!token) {
      new import_obsidian.Notice("GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u672A\u8A2D\u7F6E");
      return;
    }
    const repo = this.settings.repo;
    const branch = this.settings.branch;
    const newBranch = `sync-branch-${Date.now()}`;
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
    try {
      const branchUrl = `https://api.github.com/repos/${repo}/git/ref/heads/${branch}`;
      const branchResponse = await fetch(branchUrl, { headers });
      if (!branchResponse.ok) {
        throw new Error(`\u7121\u6CD5\u7372\u53D6\u4E3B\u5206\u652F\u8CC7\u8A0A: ${branchResponse.statusText}`);
      }
      const branchData = await branchResponse.json();
      const baseSha = branchData.object.sha;
      const createBranchUrl = `https://api.github.com/repos/${repo}/git/refs`;
      const createBranchBody = {
        ref: `refs/heads/${newBranch}`,
        sha: baseSha
      };
      const createBranchResponse = await fetch(createBranchUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(createBranchBody)
      });
      if (!createBranchResponse.ok) {
        throw new Error(`\u7121\u6CD5\u5275\u5EFA\u65B0\u5206\u652F: ${createBranchResponse.statusText}`);
      }
      const files = this.app.vault.getFiles().filter((file) => !file.path.endsWith(".ini"));
      for (const file of files) {
        const filePath = file.path;
        const content = await this.app.vault.read(file);
        const fileUrl = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}`;
        let sha = null;
        try {
          const response = await fetch(fileUrl, { headers });
          if (response.ok) {
            const data = await response.json();
            sha = data.sha;
          }
        } catch (error) {
          console.warn(`File ${filePath} does not exist in the repository. It will be created.`);
        }
        const fileBody = {
          message: `Update ${filePath}`,
          content: Buffer.from(content).toString("base64"),
          branch: newBranch,
          ...sha && { sha }
          // 如果有 SHA 值，則添加到請求中
        };
        const fileResponse = await fetch(fileUrl, {
          method: "PUT",
          headers,
          body: JSON.stringify(fileBody)
        });
        if (!fileResponse.ok) {
          const errorData = await fileResponse.json();
          console.error(`Error pushing file ${filePath}: ${errorData.message}`);
        }
      }
      new import_obsidian.Notice(`\u5206\u652F ${newBranch} \u5DF2\u63A8\u9001\u5230 GitHub\uFF0CGitHub Actions \u6B63\u5728\u8655\u7406\u5408\u4F75\u3002`);
    } catch (error) {
      console.error(`Error syncing Vault with GitHub:`, error);
      new import_obsidian.Notice(`\u540C\u6B65 Vault \u8207 GitHub \u6642\u767C\u751F\u932F\u8AA4`);
    }
  }
  /**
   * 合併本地和遠程的 Markdown 文件內容
   */
  mergeMarkdownContents(localContent, remoteContent) {
    if (localContent.trim() === remoteContent.trim()) {
      return localContent;
    }
    const mergedContent = `${localContent}

---

${remoteContent}`;
    return mergedContent;
  }
  async getTokenFromEnv() {
    const envPath = (0, import_obsidian.normalizePath)(`/.env`);
    if (this.app.vault.adapter.exists(envPath)) {
      const envContent = await this.app.vault.adapter.read(envPath);
      const envConfig = dotenv.parse(envContent);
      return envConfig.GITHUB_TOKEN || null;
    }
    return null;
  }
  /**
   * 取得當前選取文字，並利用傳入的處理函式處理後替換原文字
   */
  processSelectedText(processor) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      const processedText = processor(selectedText);
      editor.replaceSelection(processedText);
    }
  }
  /**
   * 將文件中的條款轉換成標題
   */
  convertArticleHeadings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const content = editor.getValue();
      const updatedContent = content.replace(/^第\s*[零一二三四五六七八九十百千萬]+\s*編/gm, (match) => `# ${match}`).replace(/^第\s*[零一二三四五六七八九十百千萬]+\s*章/gm, (match) => `## ${match}`).replace(/^第\s*[零一二三四五六七八九十百千萬]+\s*節/gm, (match) => `### ${match}`).replace(/^第\s*[零一二三四五六七八九十百千萬]+\s*款/gm, (match) => `#### ${match}`).replace(/^第\s*[零一二三四五六七八九十百千萬]+\s*目/gm, (match) => `##### ${match}`).replace(/^第\s*\d+\s*條/gm, (match) => `###### ${match}`).replace(/^資料來源：全國法規資料庫/gm, (match) => `# ${match}`);
      editor.setValue(updatedContent);
    }
  }
  /**
   * 拆分文件
   */
  async splitDocument() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      try {
        this.cleanDocument();
        const editor = activeView.editor;
        const content = editor.getValue();
        const folderPathPre = this.app.vault.getAbstractFileByPath(activeView.file.path).path;
        const folderPath = folderPathPre.replace(/.md$/, "");
        const currentFileName = activeView.file.basename;
        const folderName = folderPath.split("/").pop();
        await this.app.vault.createFolder(folderPath);
        const sections = content.split(/(?=^\d+\.)/gm);
        let updatedContent = content;
        const fileNames = /* @__PURE__ */ new Set();
        const prefix = `---
tags:
  - \u8003\u984C
  - \u984C\u76EE
  - \u672A\u5B8C
Sourse:
Relate: 
aliases:
---
`;
        for (let i = 0; i < sections.length; i++) {
          const section = sections[i];
          const sectionTitle = (_a = section.match(/^\d+\./)) == null ? void 0 : _a[0];
          if (sectionTitle) {
            let cleanTitle = sectionTitle.replace(/\.$/, "").trim();
            let newFileName = `${folderPath}/${folderName}-\u7B2C1\u5927\u984C\u7B2C${cleanTitle}\u984C.md`;
            let counter = 2;
            while (fileNames.has(newFileName)) {
              newFileName = `${folderPath}/${folderName}-\u7B2C${counter}\u5927\u984C\u7B2C${cleanTitle}\u984C.md`;
              counter++;
            }
            fileNames.add(newFileName);
            await this.app.vault.create(newFileName, prefix + section);
            updatedContent = updatedContent.replace(section, `## ![[${folderName}-\u7B2C${counter - 1}\u5927\u984C\u7B2C${cleanTitle}\u984C]]
`);
          }
        }
        editor.setValue(updatedContent);
      } catch (error) {
        console.error("Error splitting document:", error);
        if (error instanceof TypeError) {
          new import_obsidian.Notice("\u62C6\u5206\u6587\u4EF6\u6642\u767C\u751F\u985E\u578B\u932F\u8AA4\uFF0C\u8ACB\u6AA2\u67E5\u63A7\u5236\u53F0\u4EE5\u7372\u53D6\u8A73\u7D30\u8CC7\u8A0A\u3002");
        } else if (error instanceof ReferenceError) {
          new import_obsidian.Notice("\u62C6\u5206\u6587\u4EF6\u6642\u767C\u751F\u5F15\u7528\u932F\u8AA4\uFF0C\u8ACB\u6AA2\u67E5\u63A7\u5236\u53F0\u4EE5\u7372\u53D6\u8A73\u7D30\u8CC7\u8A0A\u3002");
        }
      }
    }
  }
  /**
   * 整理文件
   * - 如果一行中只有1個數字而沒有其他文字，刪除這一行
   * - 如果一行以"n."開始，去除"n."到下一個"？"間的所有換行
   */
  cleanDocument() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      let content = editor.getValue();
      content = content.replace(/^\d+\s*$/gm, "");
      content = content.replace(/(\d+\.[^？]*？)/gm, (match, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/(「[^」]*」)/gm, (_, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/(（[^）]*）)/gm, (_, p1) => p1.replace(/\n/g, ""));
      content = content.replace(/\([^)]*\)/gm, (match) => match.replace(/\n/g, ""));
      editor.setValue(content);
    }
  }
  // 整理條文對照表
  cleanTable() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      let content = editor.getValue();
      let yamlHeader = "";
      const yamlMatch = content.match(/^---\n[\s\S]*?\n---\n/);
      if (yamlMatch) {
        yamlHeader = yamlMatch[0];
        content = content.slice(yamlHeader.length);
      }
      content = content.replace(/\*\*/g, "==").replace(/\(/g, "\uFF08").replace(/\)/g, "\uFF09").replace(/<br>/g, " ").replace(/[  \t]+/g, " ");
      content = content.split("\n").filter((line) => !/^[\|\-\s]*$/.test(line)).join("\n");
      content = content.replace(/\| +/g, "|");
      const lines = content.split("\n");
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].startsWith("|") && !/\|第[零一二三四五六七八九十百千萬億兆]+\s*條.*$/.test(lines[i])) {
          const previousCells = lines[i - 1].split("|");
          const currentCells = lines[i].split("|");
          for (let j = 0; j < currentCells.length; j++) {
            if (currentCells[j].trim() !== "") {
              previousCells[j] = (previousCells[j] || "") + currentCells[j];
            }
          }
          lines[i - 1] = previousCells.join("|");
          lines.splice(i, 1);
          i--;
        }
      }
      content = lines.join("\n");
      content = content.replace(/(?<![a-zA-Z0-9_.,])[  \t]+|[  \t]+(?![a-zA-Z0-9_.,])|^[ \t]+|[ \t]+$/gm, "");
      content = content.split("\n").map((line) => {
        if (line.startsWith("|")) {
          const parts = line.split("|");
          if (parts.length > 3) {
            const firstPart = parts.slice(0, 3).join("|");
            let secondPart = parts.slice(3).join("|").replace(/\|\s*$/, "");
            secondPart = secondPart.replace(/(\d+)\./g, "\n		$1. ");
            secondPart = secondPart.replace(/([零一二三四五六七八九十百千萬億兆]+)、/g, (match, p1) => `
${this.convertChineseNumberToArabic(p1)}. `);
            secondPart = secondPart.replace(/（([零一二三四五六七八九十百千萬億兆]+)）/g, (match, p1) => `
	${this.convertChineseNumberToArabic(p1)}. `);
            return `
|\u4FEE\u6B63\u5F8C|\u4FEE\u6B63\u524D|
|---|---|
${firstPart}|
\u8AAA\u660E\uFF1A${secondPart}`;
          }
        }
        return line;
      }).join("\n");
      content = content.replace(/,(?=[a-zA-Z])/g, ", ").replace(/([a-z])([A-Z])/g, "$1 $2");
      content = content.replace(
        /\|修正後\|修正前\|\n\|---\|---\|\n\|(==)*第(==)*([零一二三四五六七八九十百千萬億兆]+)(==)*條(==)*/g,
        (_, equalsBeforeArticle, equalsBeforeNumber, chineseNumber, equalsAfterNumber, equalsAfterArticle) => {
          return `###### \u7B2C${chineseNumber}\u689D
|\u4FEE\u6B63\u5F8C|\u4FEE\u6B63\u524D|
|---|---|
|${equalsBeforeArticle || ""}\u7B2C${equalsBeforeNumber || ""}${chineseNumber}${equalsAfterNumber || ""}\u689D${equalsAfterArticle || ""}`;
        }
      );
      content = yamlHeader + content;
      editor.setValue(content);
    }
  }
  /**
   * 將中文數字轉換為阿拉伯數字
   */
  convertChineseNumberToArabic(chineseNumber) {
    const chineseDigits = "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D";
    const chineseUnits = "\u5341\u767E\u5343\u5343\u842C\u5104\u5146";
    let result = 0;
    let unit = 1;
    let temp = 0;
    for (let i = chineseNumber.length - 1; i >= 0; i--) {
      const char = chineseNumber[i];
      const digit = chineseDigits.indexOf(char);
      if (digit !== -1) {
        temp += digit * unit;
      } else {
        const unitIndex = chineseUnits.indexOf(char);
        if (unitIndex !== -1) {
          unit = Math.pow(10, unitIndex + 1);
          result += temp * unit;
          temp = 0;
        }
      }
    }
    result += temp;
    return result;
  }
};
var TextProcessingPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Text Processing Plugin Settings" });
    let tokenInput;
    let repoInput;
    let branchInput;
    new import_obsidian.Setting(containerEl).setName("GitHub Personal Access Token").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u3002\u4F60\u53EF\u4EE5\u5728 GitHub \u7684\u8A2D\u5B9A\u4E2D\u751F\u6210\u4E00\u500B\u65B0\u7684\u500B\u4EBA\u8A2A\u554F\u4EE4\u724C\u3002").addText((text) => {
      tokenInput = text.inputEl;
      text.setPlaceholder("Enter your token");
    });
    new import_obsidian.Setting(containerEl).setName("GitHub Repository").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u5132\u5B58\u5EAB\u540D\u7A31\uFF08\u4F8B\u5982\uFF1Ausername/repo\uFF09\u3002").addText((text) => {
      repoInput = text.inputEl;
      text.setPlaceholder("Enter your repository");
      text.setValue(this.plugin.settings.repo);
    });
    new import_obsidian.Setting(containerEl).setName("GitHub Branch").setDesc("\u8ACB\u8F38\u5165\u4F60\u7684 GitHub \u5206\u652F\u540D\u7A31\u3002").addText((text) => {
      branchInput = text.inputEl;
      text.setPlaceholder("Enter your branch");
      text.setValue(this.plugin.settings.branch);
    });
    new import_obsidian.Setting(containerEl).addButton((button) => {
      button.setButtonText("\u5132\u5B58\u8A2D\u5B9A").setCta().onClick(async () => {
        this.plugin.settings.repo = repoInput.value;
        this.plugin.settings.branch = branchInput.value;
        await this.plugin.saveSettings();
        this.saveTokenToEnv(tokenInput.value);
        new import_obsidian.Notice("\u8A2D\u5B9A\u5DF2\u5132\u5B58");
      });
    });
  }
  saveTokenToEnv(token) {
    const vaultPath = this.plugin.app.vault.adapter.basePath;
    const envPath = path.join(vaultPath, ".env");
    const envContent = `GITHUB_TOKEN=${token}
`;
    fs.writeFileSync(envPath, envContent);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RvdGVudi9wYWNrYWdlLmpzb24iLCAibm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9jbGFzc2VzL0NsaWVudEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xpYi9wcmVsdWRlLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9mdW5jdGlvbnMvYmF0Y2hSZXF1ZXN0cy50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvZnVuY3Rpb25zL3Jhd1JlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9kZXZBc3NlcnQubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvaXNPYmplY3RMaWtlLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2ludmFyaWFudC5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvbG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50TG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL0dyYXBoUUxFcnJvci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvZXJyb3Ivc3ludGF4RXJyb3IubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvZGlyZWN0aXZlTG9jYXRpb24ubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2tpbmRzLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9jaGFyYWN0ZXJDbGFzc2VzLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9ibG9ja1N0cmluZy5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvdG9rZW5LaW5kLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9sZXhlci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvanN1dGlscy9pbnNwZWN0Lm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3RhbmNlT2YubWpzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3NvdXJjZS5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcGFyc2VyLm1qcyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9wcmludFN0cmluZy5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvdmlzaXRvci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlci5tanMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGliL2h0dHAudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGVnYWN5L2xpYi9ncmFwaHFsLnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9oZWxwZXJzL2FuYWx5emVEb2N1bWVudC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvaGVscGVycy9kZWZhdWx0SnNvblNlcmlhbGl6ZXIudHMiLCAibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9zcmMvbGVnYWN5L2hlbHBlcnMvcnVuUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvY2xhc3Nlcy9HcmFwaFFMQ2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3Qvc3JjL2xlZ2FjeS9mdW5jdGlvbnMvcmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L3NyYy9sZWdhY3kvZnVuY3Rpb25zL2dxbC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsie1xuICBcIm5hbWVcIjogXCJkb3RlbnZcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMTYuNC43XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJMb2FkcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52IGZpbGVcIixcbiAgXCJtYWluXCI6IFwibGliL21haW4uanNcIixcbiAgXCJ0eXBlc1wiOiBcImxpYi9tYWluLmQudHNcIixcbiAgXCJleHBvcnRzXCI6IHtcbiAgICBcIi5cIjoge1xuICAgICAgXCJ0eXBlc1wiOiBcIi4vbGliL21haW4uZC50c1wiLFxuICAgICAgXCJyZXF1aXJlXCI6IFwiLi9saWIvbWFpbi5qc1wiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiLi9saWIvbWFpbi5qc1wiXG4gICAgfSxcbiAgICBcIi4vY29uZmlnXCI6IFwiLi9jb25maWcuanNcIixcbiAgICBcIi4vY29uZmlnLmpzXCI6IFwiLi9jb25maWcuanNcIixcbiAgICBcIi4vbGliL2Vudi1vcHRpb25zXCI6IFwiLi9saWIvZW52LW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2Vudi1vcHRpb25zLmpzXCI6IFwiLi9saWIvZW52LW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2NsaS1vcHRpb25zXCI6IFwiLi9saWIvY2xpLW9wdGlvbnMuanNcIixcbiAgICBcIi4vbGliL2NsaS1vcHRpb25zLmpzXCI6IFwiLi9saWIvY2xpLW9wdGlvbnMuanNcIixcbiAgICBcIi4vcGFja2FnZS5qc29uXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZHRzLWNoZWNrXCI6IFwidHNjIC0tcHJvamVjdCB0ZXN0cy90eXBlcy90c2NvbmZpZy5qc29uXCIsXG4gICAgXCJsaW50XCI6IFwic3RhbmRhcmRcIixcbiAgICBcInByZXRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biBkdHMtY2hlY2tcIixcbiAgICBcInRlc3RcIjogXCJ0YXAgcnVuIC0tYWxsb3ctZW1wdHktY292ZXJhZ2UgLS1kaXNhYmxlLWNvdmVyYWdlIC0tdGltZW91dD02MDAwMFwiLFxuICAgIFwidGVzdDpjb3ZlcmFnZVwiOiBcInRhcCBydW4gLS1zaG93LWZ1bGwtY292ZXJhZ2UgLS10aW1lb3V0PTYwMDAwIC0tY292ZXJhZ2UtcmVwb3J0PWxjb3ZcIixcbiAgICBcInByZXJlbGVhc2VcIjogXCJucG0gdGVzdFwiLFxuICAgIFwicmVsZWFzZVwiOiBcInN0YW5kYXJkLXZlcnNpb25cIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9tb3Rkb3RsYS9kb3RlbnYuZ2l0XCJcbiAgfSxcbiAgXCJmdW5kaW5nXCI6IFwiaHR0cHM6Ly9kb3RlbnZ4LmNvbVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImRvdGVudlwiLFxuICAgIFwiZW52XCIsXG4gICAgXCIuZW52XCIsXG4gICAgXCJlbnZpcm9ubWVudFwiLFxuICAgIFwidmFyaWFibGVzXCIsXG4gICAgXCJjb25maWdcIixcbiAgICBcInNldHRpbmdzXCJcbiAgXSxcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcImxpY2Vuc2VcIjogXCJCU0QtMi1DbGF1c2VcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMTguMTEuM1wiLFxuICAgIFwiZGVjYWNoZVwiOiBcIl40LjYuMlwiLFxuICAgIFwic2lub25cIjogXCJeMTQuMC4xXCIsXG4gICAgXCJzdGFuZGFyZFwiOiBcIl4xNy4wLjBcIixcbiAgICBcInN0YW5kYXJkLXZlcnNpb25cIjogXCJeOS41LjBcIixcbiAgICBcInRhcFwiOiBcIl4xOS4yLjBcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeNC44LjRcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MTJcIlxuICB9LFxuICBcImJyb3dzZXJcIjoge1xuICAgIFwiZnNcIjogZmFsc2VcbiAgfVxufVxuIiwgImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuXG5jb25zdCB2ZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvblxuXG5jb25zdCBMSU5FID0gLyg/Ol58XilcXHMqKD86ZXhwb3J0XFxzKyk/KFtcXHcuLV0rKSg/Olxccyo9XFxzKj98Olxccys/KShcXHMqJyg/OlxcXFwnfFteJ10pKid8XFxzKlwiKD86XFxcXFwifFteXCJdKSpcInxcXHMqYCg/OlxcXFxgfFteYF0pKmB8W14jXFxyXFxuXSspP1xccyooPzojLiopPyg/OiR8JCkvbWdcblxuLy8gUGFyc2Ugc3JjIGludG8gYW4gT2JqZWN0XG5mdW5jdGlvbiBwYXJzZSAoc3JjKSB7XG4gIGNvbnN0IG9iaiA9IHt9XG5cbiAgLy8gQ29udmVydCBidWZmZXIgdG8gc3RyaW5nXG4gIGxldCBsaW5lcyA9IHNyYy50b1N0cmluZygpXG5cbiAgLy8gQ29udmVydCBsaW5lIGJyZWFrcyB0byBzYW1lIGZvcm1hdFxuICBsaW5lcyA9IGxpbmVzLnJlcGxhY2UoL1xcclxcbj8vbWcsICdcXG4nKVxuXG4gIGxldCBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gTElORS5leGVjKGxpbmVzKSkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdXG5cbiAgICAvLyBEZWZhdWx0IHVuZGVmaW5lZCBvciBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgIGxldCB2YWx1ZSA9IChtYXRjaFsyXSB8fCAnJylcblxuICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIC8vIENoZWNrIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBjb25zdCBtYXliZVF1b3RlID0gdmFsdWVbMF1cblxuICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgJyQyJylcblxuICAgIC8vIEV4cGFuZCBuZXdsaW5lcyBpZiBkb3VibGUgcXVvdGVkXG4gICAgaWYgKG1heWJlUXVvdGUgPT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxyL2csICdcXHInKVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBvYmplY3RcbiAgICBvYmpba2V5XSA9IHZhbHVlXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIF9wYXJzZVZhdWx0IChvcHRpb25zKSB7XG4gIGNvbnN0IHZhdWx0UGF0aCA9IF92YXVsdFBhdGgob3B0aW9ucylcblxuICAvLyBQYXJzZSAuZW52LnZhdWx0XG4gIGNvbnN0IHJlc3VsdCA9IERvdGVudk1vZHVsZS5jb25maWdEb3RlbnYoeyBwYXRoOiB2YXVsdFBhdGggfSlcbiAgaWYgKCFyZXN1bHQucGFyc2VkKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBNSVNTSU5HX0RBVEE6IENhbm5vdCBwYXJzZSAke3ZhdWx0UGF0aH0gZm9yIGFuIHVua25vd24gcmVhc29uYClcbiAgICBlcnIuY29kZSA9ICdNSVNTSU5HX0RBVEEnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBoYW5kbGUgc2NlbmFyaW8gZm9yIGNvbW1hIHNlcGFyYXRlZCBrZXlzIC0gZm9yIHVzZSB3aXRoIGtleSByb3RhdGlvblxuICAvLyBleGFtcGxlOiBET1RFTlZfS0VZPVwiZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZCxkb3RlbnY6Ly86a2V5Xzc4OTBAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kXCJcbiAgY29uc3Qga2V5cyA9IF9kb3RlbnZLZXkob3B0aW9ucykuc3BsaXQoJywnKVxuICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXG4gIGxldCBkZWNyeXB0ZWRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZnVsbCBrZXlcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0udHJpbSgpXG5cbiAgICAgIC8vIEdldCBpbnN0cnVjdGlvbnMgZm9yIGRlY3J5cHRcbiAgICAgIGNvbnN0IGF0dHJzID0gX2luc3RydWN0aW9ucyhyZXN1bHQsIGtleSlcblxuICAgICAgLy8gRGVjcnlwdFxuICAgICAgZGVjcnlwdGVkID0gRG90ZW52TW9kdWxlLmRlY3J5cHQoYXR0cnMuY2lwaGVydGV4dCwgYXR0cnMua2V5KVxuXG4gICAgICBicmVha1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBsYXN0IGtleVxuICAgICAgaWYgKGkgKyAxID49IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgLy8gdHJ5IG5leHQga2V5XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgZGVjcnlwdGVkIC5lbnYgc3RyaW5nXG4gIHJldHVybiBEb3RlbnZNb2R1bGUucGFyc2UoZGVjcnlwdGVkKVxufVxuXG5mdW5jdGlvbiBfbG9nIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW0lORk9dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfd2FybiAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtXQVJOXSAke21lc3NhZ2V9YClcbn1cblxuZnVuY3Rpb24gX2RlYnVnIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW0RFQlVHXSAke21lc3NhZ2V9YClcbn1cblxuZnVuY3Rpb24gX2RvdGVudktleSAob3B0aW9ucykge1xuICAvLyBwcmlvcml0aXplIGRldmVsb3BlciBkaXJlY3RseSBzZXR0aW5nIG9wdGlvbnMuRE9URU5WX0tFWVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLkRPVEVOVl9LRVkgJiYgb3B0aW9ucy5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ET1RFTlZfS0VZXG4gIH1cblxuICAvLyBzZWNvbmRhcnkgaW5mcmEgYWxyZWFkeSBjb250YWlucyBhIERPVEVOVl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgaWYgKHByb2Nlc3MuZW52LkRPVEVOVl9LRVkgJiYgcHJvY2Vzcy5lbnYuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIHRvIGVtcHR5IHN0cmluZ1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gX2luc3RydWN0aW9ucyAocmVzdWx0LCBkb3RlbnZLZXkpIHtcbiAgLy8gUGFyc2UgRE9URU5WX0tFWS4gRm9ybWF0IGlzIGEgVVJJXG4gIGxldCB1cmlcbiAgdHJ5IHtcbiAgICB1cmkgPSBuZXcgVVJMKGRvdGVudktleSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1VSTCcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBXcm9uZyBmb3JtYXQuIE11c3QgYmUgaW4gdmFsaWQgdXJpIGZvcm1hdCBsaWtlIGRvdGVudjovLzprZXlfMTIzNEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PWRldmVsb3BtZW50JylcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRocm93IGVycm9yXG4gIH1cblxuICAvLyBHZXQgZGVjcnlwdCBrZXlcbiAgY29uc3Qga2V5ID0gdXJpLnBhc3N3b3JkXG4gIGlmICgha2V5KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3Npbmcga2V5IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBlbnZpcm9ubWVudFxuICBjb25zdCBlbnZpcm9ubWVudCA9IHVyaS5zZWFyY2hQYXJhbXMuZ2V0KCdlbnZpcm9ubWVudCcpXG4gIGlmICghZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBlbnZpcm9ubWVudCBwYXJ0JylcbiAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBHZXQgY2lwaGVydGV4dCBwYXlsb2FkXG4gIGNvbnN0IGVudmlyb25tZW50S2V5ID0gYERPVEVOVl9WQVVMVF8ke2Vudmlyb25tZW50LnRvVXBwZXJDYXNlKCl9YFxuICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVzdWx0LnBhcnNlZFtlbnZpcm9ubWVudEtleV0gLy8gRE9URU5WX1ZBVUxUX1BST0RVQ1RJT05cbiAgaWYgKCFjaXBoZXJ0ZXh0KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UOiBDYW5ub3QgbG9jYXRlIGVudmlyb25tZW50ICR7ZW52aXJvbm1lbnRLZXl9IGluIHlvdXIgLmVudi52YXVsdCBmaWxlLmApXG4gICAgZXJyLmNvZGUgPSAnTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVCdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIHJldHVybiB7IGNpcGhlcnRleHQsIGtleSB9XG59XG5cbmZ1bmN0aW9uIF92YXVsdFBhdGggKG9wdGlvbnMpIHtcbiAgbGV0IHBvc3NpYmxlVmF1bHRQYXRoID0gbnVsbFxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aCkpIHtcbiAgICAgIGZvciAoY29uc3QgZmlsZXBhdGggb2Ygb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xuICAgICAgICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gZmlsZXBhdGguZW5kc1dpdGgoJy52YXVsdCcpID8gZmlsZXBhdGggOiBgJHtmaWxlcGF0aH0udmF1bHRgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBvcHRpb25zLnBhdGguZW5kc1dpdGgoJy52YXVsdCcpID8gb3B0aW9ucy5wYXRoIDogYCR7b3B0aW9ucy5wYXRofS52YXVsdGBcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zc2libGVWYXVsdFBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYudmF1bHQnKVxuICB9XG5cbiAgaWYgKGZzLmV4aXN0c1N5bmMocG9zc2libGVWYXVsdFBhdGgpKSB7XG4gICAgcmV0dXJuIHBvc3NpYmxlVmF1bHRQYXRoXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZUhvbWUgKGVudlBhdGgpIHtcbiAgcmV0dXJuIGVudlBhdGhbMF0gPT09ICd+JyA/IHBhdGguam9pbihvcy5ob21lZGlyKCksIGVudlBhdGguc2xpY2UoMSkpIDogZW52UGF0aFxufVxuXG5mdW5jdGlvbiBfY29uZmlnVmF1bHQgKG9wdGlvbnMpIHtcbiAgX2xvZygnTG9hZGluZyBlbnYgZnJvbSBlbmNyeXB0ZWQgLmVudi52YXVsdCcpXG5cbiAgY29uc3QgcGFyc2VkID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0KG9wdGlvbnMpXG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHsgcGFyc2VkIH1cbn1cblxuZnVuY3Rpb24gY29uZmlnRG90ZW52IChvcHRpb25zKSB7XG4gIGNvbnN0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxuICBsZXQgZW5jb2RpbmcgPSAndXRmOCdcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nXG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBfZGVidWcoJ05vIGVuY29kaW5nIGlzIHNwZWNpZmllZC4gVVRGLTggaXMgdXNlZCBieSBkZWZhdWx0JylcbiAgICB9XG4gIH1cblxuICBsZXQgb3B0aW9uUGF0aHMgPSBbZG90ZW52UGF0aF0gLy8gZGVmYXVsdCwgbG9vayBmb3IgLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aCldXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvblBhdGhzID0gW10gLy8gcmVzZXQgZGVmYXVsdFxuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgb3B0aW9uUGF0aHMucHVzaChfcmVzb2x2ZUhvbWUoZmlsZXBhdGgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSBwYXJzZWQgZGF0YSBpbiBhIHRlbXBvcmFyeSBvYmplY3QgKGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gaXQpLiAgT25jZSB3ZSBoYXZlIHRoZSBmaW5hbFxuICAvLyBwYXJzZWQgZGF0YSwgd2Ugd2lsbCBjb21iaW5lIGl0IHdpdGggcHJvY2Vzcy5lbnYgKG9yIG9wdGlvbnMucHJvY2Vzc0VudiBpZiBwcm92aWRlZCkuXG4gIGxldCBsYXN0RXJyb3JcbiAgY29uc3QgcGFyc2VkQWxsID0ge31cbiAgZm9yIChjb25zdCBwYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNwZWNpZnlpbmcgYW4gZW5jb2RpbmcgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYnVmZmVyXG4gICAgICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGgsIHsgZW5jb2RpbmcgfSkpXG5cbiAgICAgIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwYXJzZWRBbGwsIHBhcnNlZCwgb3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke3BhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgICBsYXN0RXJyb3IgPSBlXG4gICAgfVxuICB9XG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWRBbGwsIG9wdGlvbnMpXG5cbiAgaWYgKGxhc3RFcnJvcikge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsLCBlcnJvcjogbGFzdEVycm9yIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGVzIHByb2Nlc3MuZW52IGZyb20gLmVudiBmaWxlXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgLy8gZmFsbGJhY2sgdG8gb3JpZ2luYWwgZG90ZW52IGlmIERPVEVOVl9LRVkgaXMgbm90IHNldFxuICBpZiAoX2RvdGVudktleShvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIGRvdGVudktleSBleGlzdHMgYnV0IC5lbnYudmF1bHQgZmlsZSBkb2VzIG5vdCBleGlzdFxuICBpZiAoIXZhdWx0UGF0aCkge1xuICAgIF93YXJuKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3ZhdWx0UGF0aH0uIERpZCB5b3UgZm9yZ2V0IHRvIGJ1aWxkIGl0P2ApXG5cbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oa2V5U3RyLnNsaWNlKC02NCksICdoZXgnKVxuICBsZXQgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCwgJ2Jhc2U2NCcpXG5cbiAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDEyKVxuICBjb25zdCBhdXRoVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtMTYpXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDEyLCAtMTYpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxuICAgIGFlc2djbS5zZXRBdXRoVGFnKGF1dGhUYWcpXG4gICAgcmV0dXJuIGAke2Flc2djbS51cGRhdGUoY2lwaGVydGV4dCl9JHthZXNnY20uZmluYWwoKX1gXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNSYW5nZSA9IGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvclxuICAgIGNvbnN0IGludmFsaWRLZXlMZW5ndGggPSBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBrZXkgbGVuZ3RoJ1xuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xuXG4gICAgaWYgKGlzUmFuZ2UgfHwgaW52YWxpZEtleUxlbmd0aCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKScpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignREVDUllQVElPTl9GQUlMRUQ6IFBsZWFzZSBjaGVjayB5b3VyIERPVEVOVl9LRVknKVxuICAgICAgZXJyLmNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGUgcHJvY2Vzcy5lbnYgd2l0aCBwYXJzZWQgdmFsdWVzXG5mdW5jdGlvbiBwb3B1bGF0ZSAocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcbiAgY29uc3Qgb3ZlcnJpZGUgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSlcblxuICBpZiAodHlwZW9mIHBhcnNlZCAhPT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ09CSkVDVF9SRVFVSVJFRDogUGxlYXNlIGNoZWNrIHRoZSBwcm9jZXNzRW52IGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBwb3B1bGF0ZScpXG4gICAgZXJyLmNvZGUgPSAnT0JKRUNUX1JFUVVJUkVEJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gU2V0IHByb2Nlc3MuZW52XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZCkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3NFbnYsIGtleSkpIHtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBEb3RlbnZNb2R1bGUgPSB7XG4gIGNvbmZpZ0RvdGVudixcbiAgX2NvbmZpZ1ZhdWx0LFxuICBfcGFyc2VWYXVsdCxcbiAgY29uZmlnLFxuICBkZWNyeXB0LFxuICBwYXJzZSxcbiAgcG9wdWxhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uZmlnRG90ZW52ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudlxubW9kdWxlLmV4cG9ydHMuX2NvbmZpZ1ZhdWx0ID0gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdFxubW9kdWxlLmV4cG9ydHMuX3BhcnNlVmF1bHQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHRcbm1vZHVsZS5leHBvcnRzLmNvbmZpZyA9IERvdGVudk1vZHVsZS5jb25maWdcbm1vZHVsZS5leHBvcnRzLmRlY3J5cHQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBEb3RlbnZNb2R1bGUucGFyc2Vcbm1vZHVsZS5leHBvcnRzLnBvcHVsYXRlID0gRG90ZW52TW9kdWxlLnBvcHVsYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gRG90ZW52TW9kdWxlXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTWVudSwgVEZpbGUsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgQXBwLCBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgKiBhcyBkb3RlbnYgZnJvbSAnZG90ZW52JztcclxuaW1wb3J0IHsgcmVxdWVzdCwgZ3FsIH0gZnJvbSAnZ3JhcGhxbC1yZXF1ZXN0JztcclxuXHJcbmludGVyZmFjZSBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzIHtcclxuICAgIHJlcG86IHN0cmluZztcclxuICAgIGJyYW5jaDogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzID0ge1xyXG4gICAgcmVwbzogJ21vb250aGVyZWZvci9vYnNpZGlhbl9zeW5jX3Rlc3QnLFxyXG4gICAgYnJhbmNoOiAnbWFpbidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRQcm9jZXNzaW5nUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICAgIHNldHRpbmdzOiBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdzO1xyXG5cclxuICAgIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFRleHRQcm9jZXNzaW5nUGx1Z2luU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgICAgICAvLyBcdThBM0JcdTUxOEFcdTU0N0RcdTRFRTRcdUZGMDhDb21tYW5kIFBhbGV0dGUgXHU4MjA3XHU1RkVCXHU2Mzc3XHU5Mzc1XHU5MEZEXHU1M0VGXHU0RjdGXHU3NTI4XHVGRjA5XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgICAgICAgaWQ6ICdjb252ZXJ0LWFydGljbGUtaGVhZGluZ3MnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2Q0Q1XHU4OThGXHU2NTc0XHU3NDA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY29udmVydEFydGljbGVIZWFkaW5ncygpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnY2xlYW4tdGFibGUnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2ODlEXHU2NTg3XHU1QzBEXHU3MTY3XHU4ODY4XHU2NTc0XHU3NDA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY2xlYW5UYWJsZSgpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAnc3BsaXQtZG9jdW1lbnQnLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU2NTU5XHU2QUEyXHU4MDAzXHU5ODRDXHU2MkM2XHU1MjA2JyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuc3BsaXREb2N1bWVudCgpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgICAgICAgIGlkOiAncHVsbC12YXVsdC1mcm9tLWdpdGh1YicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdcdTVGOUUgR2l0SHViIFx1NjJDOVx1NTNENiBWYXVsdCcsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnB1bGxWYXVsdEZyb21HaXRIdWIoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3B1c2gtY3VycmVudC1maWxlLXRvLWdpdGh1YicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdcdTYzQThcdTkwMDFcdTc1NzZcdTUyNERcdTZBOTRcdTY4NDhcdTUyMzAgR2l0SHViJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHVzaEN1cnJlbnRGaWxlVG9HaXRIdWIoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3B1c2gtdmF1bHQtdG8tZ2l0aHViJyxcclxuICAgICAgICAgICAgbmFtZTogJ1x1NjNBOFx1OTAwMSBWYXVsdCBcdTUyMzAgR2l0SHViJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHVzaFZhdWx0VG9HaXRIdWIoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3N5bmMtdmF1bHQtd2l0aC1naXRodWInLFxyXG4gICAgICAgICAgICBuYW1lOiAnXHU1NDBDXHU2QjY1IFZhdWx0IFx1ODIwNyBHaXRIdWInLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5zeW5jVmF1bHRXaXRoR2l0SHViKClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gXHU1NzI4XHU3REU4XHU4RjJGXHU1NjY4XHU3Njg0XHU1M0YzXHU5Mzc1XHU5MDc4XHU1NUFFXHU0RTJEXHU2NUIwXHU1ODlFXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2VkaXRvci1tZW51JywgKG1lbnU6IE1lbnUsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFx1NTJBMFx1NTE2NVx1MzAwQ1x1OEY0OVx1NjNEQlx1Njg5RFx1NkIzRVx1NzBCQVx1NkExOVx1OTg0Q1x1MzAwRFx1OTA3OFx1OTgwNVxyXG4gICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ1x1NkNENVx1ODk4Rlx1NjU3NFx1NzQwNicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdoZWFkaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0QXJ0aWNsZUhlYWRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBcdTUyQTBcdTUxNjVcdTMwMENcdTY1NzRcdTc0MDZcdTY4OURcdTY1ODdcdTVDMERcdTcxNjdcdTg4NjhcdTMwMERcdTkwNzhcdTk4MDVcclxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdcdTY4OURcdTY1ODdcdTVDMERcdTcxNjdcdTg4NjhcdTY1NzRcdTc0MDYnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignaGVhZGluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5UYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gXHU1MkEwXHU1MTY1XHUzMDBDXHU2MkM2XHU1MjA2XHU2NTg3XHU0RUY2XHUzMDBEXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnXHU2NTU5XHU2QUEyXHU4MDAzXHU5ODRDXHU2MkM2XHU1MjA2JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ3NjaXNzb3JzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdERvY3VtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBcdTUyQTBcdTUxNjVcdTMwMENcdTU0MENcdTZCNjUgVmF1bHQgXHU4MjA3IEdpdEh1Ylx1MzAwRFx1OTA3OFx1OTgwNVxyXG4gICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ1x1NTQwQ1x1NkI2NSBWYXVsdCBcdTgyMDcgR2l0SHViJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ3N5bmMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNWYXVsdFdpdGhHaXRIdWIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFx1NTJBMFx1NTE2NVx1MzAwQ1x1NjNBOFx1OTAwMVx1NzU3Nlx1NTI0RFx1NkE5NFx1Njg0OFx1NTIzMCBHaXRIdWJcdTMwMERcdTkwNzhcdTk4MDVcclxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdcdTYzQThcdTkwMDFcdTc1NzZcdTUyNERcdTZBOTRcdTY4NDhcdTUyMzAgR2l0SHViJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2Nsb3VkLXVwbG9hZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaEN1cnJlbnRGaWxlVG9HaXRIdWIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFx1NTJBMFx1NTE2NVx1MzAwQ1x1NjNBOFx1OTAwMSBWYXVsdCBcdTUyMzAgR2l0SHViXHUzMDBEXHU5MDc4XHU5ODA1XHJcbiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnXHU2M0E4XHU5MDAxIFZhdWx0IFx1NTIzMCBHaXRIdWInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignY2xvdWQtdXBsb2FkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoVmF1bHRUb0dpdEh1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gXHU1MkEwXHU1MTY1XHUzMDBDXHU1RjlFIEdpdEh1YiBcdTYyQzlcdTUzRDYgVmF1bHRcdTMwMERcdTkwNzhcdTk4MDVcclxuICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdcdTVGOUUgR2l0SHViIFx1NjJDOVx1NTNENiBWYXVsdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdjbG91ZC1kb3dubG9hZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVsbFZhdWx0RnJvbUdpdEh1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFx1NzhCQVx1NEZERCAuZW52IFx1NjU4N1x1NEVGNlx1ODhBQiAuZ2l0aWdub3JlIFx1NUZGRFx1NzU2NVxyXG4gICAgICAgIHRoaXMuZW5zdXJlRW52RmlsZUlzSWdub3JlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NzhCQVx1NEZERCAuZW52IFx1NjU4N1x1NEVGNlx1ODhBQiAuZ2l0aWdub3JlIFx1NUZGRFx1NzU2NVxyXG4gICAgICovXHJcbiAgICBhc3luYyBlbnN1cmVFbnZGaWxlSXNJZ25vcmVkKCkge1xyXG4gICAgICAgIGNvbnN0IGdpdGlnbm9yZVBhdGggPSBgLy5naXRpZ25vcmVgO1xyXG4gICAgICAgIGNvbnN0IGVudkZpbGVFbnRyeSA9ICcuZW52XFxuKi5pbmlcXG4nO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBnaXRpZ25vcmVGaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKGdpdGlnbm9yZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoIWdpdGlnbm9yZUZpbGUuaW5jbHVkZXMoJy5lbnYnKSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5hcHBlbmQoZ2l0aWdub3JlUGF0aCwgJy5lbnZcXG4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWdpdGlnbm9yZUZpbGUuaW5jbHVkZXMoJyouaW5pJykpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYXBwZW5kKGdpdGlnbm9yZVBhdGgsICcqLmluaVxcbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci53cml0ZShnaXRpZ25vcmVQYXRoLCBlbnZGaWxlRW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NjNBOFx1OTAwMVx1NjU3NFx1NTAwQiBWYXVsdCBcdTUyMzAgR2l0SHViXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHB1c2hWYXVsdFRvR2l0SHViKCkge1xyXG4gICAgICAgIC8vIFx1NzhCQVx1OEE4RCAuZW52IFx1NjU4N1x1NEVGNlx1ODhBQiBnaXQgaWdub3JlXHJcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVFbnZGaWxlSXNJZ25vcmVkKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5nZXRUb2tlbkZyb21FbnYoKTsgLy8gXHU1RjlFIC5lbnYgXHU2NTg3XHU0RUY2XHU0RTJEXHU4QjgwXHU1M0Q2XHU0RUU0XHU3MjRDXHJcbiAgICAgICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdHaXRIdWIgXHU1MDBCXHU0RUJBXHU4QTJBXHU1NTRGXHU0RUU0XHU3MjRDXHU2NzJBXHU4QTJEXHU3RjZFJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcG8gPSB0aGlzLnNldHRpbmdzLnJlcG87XHJcbiAgICAgICAgY29uc3QgYnJhbmNoID0gdGhpcy5zZXR0aW5ncy5icmFuY2g7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKS5maWx0ZXIoZmlsZSA9PiAhZmlsZS5wYXRoLmVuZHNXaXRoKCcuaW5pJykpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsRmlsZXMgPSBmaWxlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hTaXplID0gMTA7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2dyZXNzTm90aWNlID0gbmV3IE5vdGljZShgXHU2M0E4XHU5MDAxXHU5MDMyXHU1RUE2OiAwLyR7dG90YWxGaWxlc31gLCAwKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEZpbGVzOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IGZpbGVzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVcGRhdGUgJHtmaWxlUGF0aH1gO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7cmVwb30vY29udGVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoZmlsZVBhdGgpfWA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHVzaGluZyBmaWxlOiAke2ZpbGVQYXRofWApOyAvLyBMb2cgdGhlIGZpbGUgYmVpbmcgcHVzaGVkXHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcdTczNzJcdTUzRDZcdTY1ODdcdTRFRjZcdTc2ODQgU0hBIFx1NTAzQ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IGhlYWRlcnMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGEgPSBkYXRhLnNoYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHU4QTA4XHU3Qjk3XHU2NzJDXHU1NzMwXHU2NTg3XHU0RUY2XHU3Njg0IFNIQSBcdTUwM0NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNoYSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5mcm9tKGNvbnRlbnQpKS5kaWdlc3QoJ2hleCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcdTU5ODJcdTY3OUMgU0hBIFx1NTAzQ1x1NEUwRFx1NTQwQ1x1RkYwQ1x1NTI0N1x1NjNBOFx1OTAwMVx1NjU4N1x1NEVGNlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGEgIT09IGxvY2FsU2hhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogQnVmZmVyLmZyb20oY29udGVudCkudG9TdHJpbmcoJ2Jhc2U2NCcpLCAvLyBcdTRGN0ZcdTc1MjggQnVmZmVyIFx1OTAzMlx1ODg0QyBiYXNlNjQgXHU3REU4XHU3OEJDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFuY2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXNoUmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcHVzaFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHB1c2hpbmcgZmlsZSAke2ZpbGVQYXRofSB0byBHaXRIdWI6ICR7ZXJyb3JEYXRhLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrOyAvLyBcdTU5ODJcdTY3OUNcdTY1ODdcdTRFRjZcdTZDOTJcdTY3MDlcdThCOEFcdTY2RjRcdUZGMENcdTRFNUZcdThBMDhcdTcwQkFcdTYyMTBcdTUyOUZcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHB1c2hpbmcgZmlsZSAke2ZpbGVQYXRofSB0byBHaXRIdWI6YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyZXNzTm90aWNlLnNldE1lc3NhZ2UoYFx1NjNBOFx1OTAwMVx1OTAzMlx1NUVBNjogJHtzdWNjZXNzQ291bnQgKyBmYWlsdXJlQ291bnR9LyR7dG90YWxGaWxlc31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvZ3Jlc3NOb3RpY2UuaGlkZSgpO1xyXG4gICAgICAgIG5ldyBOb3RpY2UoYFx1NjNBOFx1OTAwMVx1NUI4Q1x1NjIxMDogXHU2MjEwXHU1MjlGICR7c3VjY2Vzc0NvdW50fSBcdTUwMEJcdTY1ODdcdTRFRjYsIFx1NTkzMVx1NjU1NyAke2ZhaWx1cmVDb3VudH0gXHU1MDBCXHU2NTg3XHU0RUY2YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTYzQThcdTkwMDFcdTc1NzZcdTUyNERcdTdERThcdThGMkZcdTc2ODRcdTU1QUVcdTRFMDBcdTZBOTRcdTY4NDhcdTUyMzAgR2l0SHViXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHB1c2hDdXJyZW50RmlsZVRvR2l0SHViKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xyXG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdcdTY3MkFcdTYyN0VcdTUyMzBcdTc1NzZcdTUyNERcdTdERThcdThGMkZcdTc2ODRcdTZBOTRcdTY4NDgnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuRnJvbUVudigpOyAvLyBcdTVGOUUgLmVudiBcdTY1ODdcdTRFRjZcdTRFMkRcdThCODBcdTUzRDZcdTRFRTRcdTcyNENcclxuICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0dpdEh1YiBcdTUwMEJcdTRFQkFcdThBMkFcdTU1NEZcdTRFRTRcdTcyNENcdTY3MkFcdThBMkRcdTdGNkUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVwbyA9IHRoaXMuc2V0dGluZ3MucmVwbztcclxuICAgICAgICBjb25zdCBicmFuY2ggPSB0aGlzLnNldHRpbmdzLmJyYW5jaDtcclxuICAgICAgICBjb25zdCBmaWxlID0gYWN0aXZlVmlldy5maWxlO1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVXBkYXRlICR7ZmlsZVBhdGh9YDtcclxuXHJcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtyZXBvfS9jb250ZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlUGF0aCl9YDtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFB1c2hpbmcgY3VycmVudCBmaWxlOiAke2ZpbGVQYXRofWApOyAvLyBMb2cgdGhlIGZpbGUgYmVpbmcgcHVzaGVkXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFx1NzM3Mlx1NTNENlx1NjU4N1x1NEVGNlx1NzY4NCBTSEEgXHU1MDNDXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IGhlYWRlcnMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYSA9IGRhdGEuc2hhO1xyXG5cclxuICAgICAgICAgICAgLy8gXHU4QTA4XHU3Qjk3XHU2NzJDXHU1NzMwXHU2NTg3XHU0RUY2XHU3Njg0IFNIQSBcdTUwM0NcclxuICAgICAgICAgICAgY29uc3QgbG9jYWxTaGEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShCdWZmZXIuZnJvbShjb250ZW50KSkuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFx1NTk4Mlx1Njc5QyBTSEEgXHU1MDNDXHU0RTBEXHU1NDBDXHVGRjBDXHU1MjQ3XHU2M0E4XHU5MDAxXHU2NTg3XHU0RUY2XHJcbiAgICAgICAgICAgIGlmIChzaGEgIT09IGxvY2FsU2hhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogQnVmZmVyLmZyb20oY29udGVudCkudG9TdHJpbmcoJ2Jhc2U2NCcpLCAvLyBcdTRGN0ZcdTc1MjggQnVmZmVyIFx1OTAzMlx1ODg0QyBiYXNlNjQgXHU3REU4XHU3OEJDXHJcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwdXNoUmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBcdTZBOTRcdTY4NDggJHtmaWxlUGF0aH0gXHU2M0E4XHU5MDAxXHU2MjEwXHU1MjlGYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHB1c2hSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHVzaGluZyBmaWxlICR7ZmlsZVBhdGh9IHRvIEdpdEh1YjogJHtlcnJvckRhdGEubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBcdTZBOTRcdTY4NDggJHtmaWxlUGF0aH0gXHU2M0E4XHU5MDAxXHU1OTMxXHU2NTU3YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBcdTZBOTRcdTY4NDggJHtmaWxlUGF0aH0gXHU3MTIxXHU5NzAwXHU2NkY0XHU2NUIwYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwdXNoaW5nIGZpbGUgJHtmaWxlUGF0aH0gdG8gR2l0SHViOmAsIGVycm9yKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgXHU2QTk0XHU2ODQ4ICR7ZmlsZVBhdGh9IFx1NjNBOFx1OTAwMVx1NTkzMVx1NjU1N2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NUY5RSBHaXRIdWIgXHU2MkM5XHU1M0Q2XHU2NTc0XHU1MDBCIFZhdWx0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHB1bGxWYXVsdEZyb21HaXRIdWIoKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuRnJvbUVudigpOyAvLyBcdTVGOUUgLmVudiBcdTY1ODdcdTRFRjZcdTRFMkRcdThCODBcdTUzRDZcdTRFRTRcdTcyNENcclxuICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0dpdEh1YiBcdTUwMEJcdTRFQkFcdThBMkFcdTU1NEZcdTRFRTRcdTcyNENcdTY3MkFcdThBMkRcdTdGNkUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVwbyA9IHRoaXMuc2V0dGluZ3MucmVwbztcclxuICAgICAgICBjb25zdCBicmFuY2ggPSB0aGlzLnNldHRpbmdzLmJyYW5jaDtcclxuXHJcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9ncmFwaHFsJztcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBncWxgXHJcbiAgICAgICAgICAgIHF1ZXJ5KCRvd25lcjogU3RyaW5nISwgJHJlcG86IFN0cmluZyEsICRicmFuY2g6IFN0cmluZyEpIHtcclxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkob3duZXI6ICRvd25lciwgbmFtZTogJHJlcG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QoZXhwcmVzc2lvbjogJGJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4gb24gQ29tbWl0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2lkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gb24gVHJlZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiBvbiBCbG9iIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gb24gVHJlZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiBvbiBCbG9iIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgO1xyXG5cclxuICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9OYW1lXSA9IHJlcG8uc3BsaXQoJy8nKTtcclxuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XHJcbiAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICByZXBvOiByZXBvTmFtZSxcclxuICAgICAgICAgICAgYnJhbmNoXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGVuZHBvaW50LCBxdWVyeSwgdmFyaWFibGVzLCBoZWFkZXJzKSBhcyBhbnk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5mbGF0dGVuVHJlZSgocmVzcG9uc2UucmVwb3NpdG9yeS5vYmplY3QgYXMgYW55KS50cmVlLmVudHJpZXMpO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbEZpbGVzID0gZmlsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcclxuICAgICAgICAgICAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzc05vdGljZSA9IG5ldyBOb3RpY2UoYFx1NjJDOVx1NTNENlx1OTAzMlx1NUVBNjogMC8ke3RvdGFsRmlsZXN9YCwgMCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwdWxsUHJvbWlzZXMgPSBmaWxlcy5tYXAoYXN5bmMgKGZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGUub2JqZWN0Py50ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQdWxsaW5nIGZpbGU6ICR7ZmlsZVBhdGh9YCk7IC8vIExvZyB0aGUgZmlsZSBiZWluZyBwdWxsZWRcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKGZpbGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTaGEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShCdWZmZXIuZnJvbShsb2NhbENvbnRlbnQpKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTaGEgPT09IGZpbGUub2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTm90aWNlLnNldE1lc3NhZ2UoYFx1NjJDOVx1NTNENlx1OTAzMlx1NUVBNjogJHtzdWNjZXNzQ291bnQgKyBmYWlsdXJlQ291bnR9LyR7dG90YWxGaWxlc31gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5ta2RpcihkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKGZpbGVQYXRoLCBjb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ29udGVudCBmb3IgZmlsZSAke2ZpbGVQYXRofSBpcyB1bmRlZmluZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwdWxsaW5nIGZpbGUgJHtmaWxlUGF0aH0gZnJvbSBHaXRIdWI6YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb3RpY2Uuc2V0TWVzc2FnZShgXHU2MkM5XHU1M0Q2XHU5MDMyXHU1RUE2OiAke3N1Y2Nlc3NDb3VudCArIGZhaWx1cmVDb3VudH0vJHt0b3RhbEZpbGVzfWApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHB1bGxQcm9taXNlcyk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmVzc05vdGljZS5oaWRlKCk7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFx1NjJDOVx1NTNENlx1NUI4Q1x1NjIxMDogXHU2MjEwXHU1MjlGICR7c3VjY2Vzc0NvdW50fSBcdTUwMEJcdTY1ODdcdTRFRjYsIFx1NTkzMVx1NjU1NyAke2ZhaWx1cmVDb3VudH0gXHU1MDBCXHU2NTg3XHU0RUY2YCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHVsbGluZyBWYXVsdCBmcm9tIEdpdEh1YjpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFx1NUY5RSBHaXRIdWIgXHU2MkM5XHU1M0Q2IFZhdWx0IFx1NjY0Mlx1NzY3Q1x1NzUxRlx1OTMyRlx1OEFBNGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NUMwN1x1NkEzOVx1NzJDMFx1N0Q1MFx1NjlDQlx1NUM1NVx1NUU3M1x1NzBCQVx1NjU4N1x1NEVGNlx1NTIxN1x1ODg2OFxyXG4gICAgICovXHJcbiAgICBmbGF0dGVuVHJlZShlbnRyaWVzOiBhbnlbXSwgcGFyZW50UGF0aDogc3RyaW5nID0gJycpOiBhbnlbXSB7XHJcbiAgICAgICAgbGV0IGZpbGVzOiBhbnlbXSA9IFtdO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBlbnRyaWVzOlwiLCBlbnRyaWVzKTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZmxhdHRlblRyZWUgcmVjZWl2ZWQgaW52YWxpZCBlbnRyaWVzOlwiLCBlbnRyaWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYENoZWNraW5nIGVudHJ5OiAke2VudHJ5Lm5hbWV9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5UGF0aCA9IHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS8ke2VudHJ5Lm5hbWV9YCA6IGVudHJ5Lm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5uYW1lID09PSBcIlx1NjExRlx1ODlCQVx1NURFRVx1NzU3MC5tZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgXHU2MTFGXHU4OUJBXHU1REVFXHU3NTcwLm1kIGF0ICR7ZW50cnlQYXRofWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnYmxvYicgJiYgZW50cnkub2JqZWN0Py50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHsgLi4uZW50cnksIHBhdGg6IGVudHJ5UGF0aCB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS50eXBlID09PSAndHJlZScgJiYgZW50cnkub2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdCh0aGlzLmZsYXR0ZW5UcmVlKGVudHJ5Lm9iamVjdC5lbnRyaWVzLCBlbnRyeVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsZXM7XHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NTQwQ1x1NkI2NSBWYXVsdCBcdTgyMDcgR2l0SHViXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHN5bmNWYXVsdFdpdGhHaXRIdWIoKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuRnJvbUVudigpOyAvLyBcdTVGOUUgLmVudiBcdTY1ODdcdTRFRjZcdTRFMkRcdThCODBcdTUzRDZcdTRFRTRcdTcyNENcclxuICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0dpdEh1YiBcdTUwMEJcdTRFQkFcdThBMkFcdTU1NEZcdTRFRTRcdTcyNENcdTY3MkFcdThBMkRcdTdGNkUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVwbyA9IHRoaXMuc2V0dGluZ3MucmVwbztcclxuICAgICAgICBjb25zdCBicmFuY2ggPSB0aGlzLnNldHRpbmdzLmJyYW5jaDtcclxuICAgICAgICBjb25zdCBuZXdCcmFuY2ggPSBgc3luYy1icmFuY2gtJHtEYXRlLm5vdygpfWA7IC8vIFx1NTI3NVx1NUVGQVx1NTUyRlx1NEUwMFx1NzY4NFx1NTIwNlx1NjUyRlx1NTQwRFx1N0EzMVxyXG5cclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gMS4gXHU3MzcyXHU1M0Q2XHU0RTNCXHU1MjA2XHU2NTJGXHU3Njg0XHU2NzAwXHU2NUIwXHU2M0QwXHU0RUE0IFNIQVxyXG4gICAgICAgICAgICBjb25zdCBicmFuY2hVcmwgPSBgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy8ke3JlcG99L2dpdC9yZWYvaGVhZHMvJHticmFuY2h9YDtcclxuICAgICAgICAgICAgY29uc3QgYnJhbmNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChicmFuY2hVcmwsIHsgaGVhZGVycyB9KTtcclxuICAgICAgICAgICAgaWYgKCFicmFuY2hSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcdTcxMjFcdTZDRDVcdTczNzJcdTUzRDZcdTRFM0JcdTUyMDZcdTY1MkZcdThDQzdcdThBMEE6ICR7YnJhbmNoUmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBicmFuY2hEYXRhID0gYXdhaXQgYnJhbmNoUmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlU2hhID0gYnJhbmNoRGF0YS5vYmplY3Quc2hhO1xyXG5cclxuICAgICAgICAgICAgLy8gMi4gXHU1Mjc1XHU1RUZBXHU2NUIwXHU1MjA2XHU2NTJGXHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJyYW5jaFVybCA9IGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7cmVwb30vZ2l0L3JlZnNgO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCcmFuY2hCb2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVmOiBgcmVmcy9oZWFkcy8ke25ld0JyYW5jaH1gLFxyXG4gICAgICAgICAgICAgICAgc2hhOiBiYXNlU2hhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJyYW5jaFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY3JlYXRlQnJhbmNoVXJsLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjcmVhdGVCcmFuY2hCb2R5KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjcmVhdGVCcmFuY2hSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcdTcxMjFcdTZDRDVcdTUyNzVcdTVFRkFcdTY1QjBcdTUyMDZcdTY1MkY6ICR7Y3JlYXRlQnJhbmNoUmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMy4gXHU2M0E4XHU5MDAxXHU2NTg3XHU0RUY2XHU1MjMwXHU2NUIwXHU1MjA2XHU2NTJGXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKS5maWx0ZXIoZmlsZSA9PiAhZmlsZS5wYXRoLmVuZHNXaXRoKCcuaW5pJykpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlVXJsID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtyZXBvfS9jb250ZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlUGF0aCl9YDtcclxuICAgICAgICAgICAgICAgIGxldCBzaGEgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHU2QUEyXHU2N0U1XHU2NTg3XHU0RUY2XHU2NjJGXHU1NDI2XHU1REYyXHU1QjU4XHU1NzI4XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlVXJsLCB7IGhlYWRlcnMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYSA9IGRhdGEuc2hhOyAvLyBcdTczNzJcdTUzRDZcdTY1ODdcdTRFRjZcdTc2ODQgU0hBIFx1NTAzQ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaWxlICR7ZmlsZVBhdGh9IGRvZXMgbm90IGV4aXN0IGluIHRoZSByZXBvc2l0b3J5LiBJdCB3aWxsIGJlIGNyZWF0ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gXHU2OUNCXHU1RUZBXHU4QUNCXHU2QzQyXHU3Njg0IGJvZHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVCb2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVcGRhdGUgJHtmaWxlUGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEJ1ZmZlci5mcm9tKGNvbnRlbnQpLnRvU3RyaW5nKCdiYXNlNjQnKSxcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IG5ld0JyYW5jaCxcclxuICAgICAgICAgICAgICAgICAgICAuLi4oc2hhICYmIHsgc2hhIH0pIC8vIFx1NTk4Mlx1Njc5Q1x1NjcwOSBTSEEgXHU1MDNDXHVGRjBDXHU1MjQ3XHU2REZCXHU1MkEwXHU1MjMwXHU4QUNCXHU2QzQyXHU0RTJEXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFx1NjNBOFx1OTAwMVx1NjU4N1x1NEVGNlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmlsZVVybCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmaWxlQm9keSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZmlsZVJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgZmlsZVJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwdXNoaW5nIGZpbGUgJHtmaWxlUGF0aH06ICR7ZXJyb3JEYXRhLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDQuIFx1OTAxQVx1NzdFNVx1NzUyOFx1NjIzNlxyXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBcdTUyMDZcdTY1MkYgJHtuZXdCcmFuY2h9IFx1NURGMlx1NjNBOFx1OTAwMVx1NTIzMCBHaXRIdWJcdUZGMENHaXRIdWIgQWN0aW9ucyBcdTZCNjNcdTU3MjhcdTg2NTVcdTc0MDZcdTU0MDhcdTRGNzVcdTMwMDJgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzeW5jaW5nIFZhdWx0IHdpdGggR2l0SHViOmAsIGVycm9yKTtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgXHU1NDBDXHU2QjY1IFZhdWx0IFx1ODIwNyBHaXRIdWIgXHU2NjQyXHU3NjdDXHU3NTFGXHU5MzJGXHU4QUE0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHU1NDA4XHU0Rjc1XHU2NzJDXHU1NzMwXHU1NDhDXHU5MDYwXHU3QTBCXHU3Njg0IE1hcmtkb3duIFx1NjU4N1x1NEVGNlx1NTE2N1x1NUJCOVxyXG4gICAgICovXHJcbiAgICBtZXJnZU1hcmtkb3duQ29udGVudHMobG9jYWxDb250ZW50OiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgLy8gXHU1OTgyXHU2NzlDXHU2NzJDXHU1NzMwXHU1NDhDXHU5MDYwXHU3QTBCXHU1MTY3XHU1QkI5XHU3NkY4XHU1NDBDXHVGRjBDXHU3NkY0XHU2M0E1XHU4RkQ0XHU1NkRFXHU2NzJDXHU1NzMwXHU1MTY3XHU1QkI5XHJcbiAgICAgICAgaWYgKGxvY2FsQ29udGVudC50cmltKCkgPT09IHJlbW90ZUNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbENvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBcdTU5ODJcdTY3OUNcdTUxNjdcdTVCQjlcdTRFMERcdTU0MENcdUZGMENcdTVDMDdcdTRFMERcdTRFMDBcdTgxRjRcdTc2ODRcdTkwRThcdTUyMDZcdTRFRTVcdTUyMDZcdTk2OTRcdTdCMjZcdTZERkJcdTUyQTBcdTUyMzBcdTY1ODdcdTRFRjZcdTY3MkJcdTVDM0VcclxuICAgICAgICBjb25zdCBtZXJnZWRDb250ZW50ID0gYCR7bG9jYWxDb250ZW50fVxcblxcbi0tLVxcblxcbiR7cmVtb3RlQ29udGVudH1gO1xyXG4gICAgICAgIHJldHVybiBtZXJnZWRDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdldFRva2VuRnJvbUVudigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCBlbnZQYXRoID0gbm9ybWFsaXplUGF0aChgLy5lbnZgKTtcclxuICAgICAgICBpZiAodGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoZW52UGF0aCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW52Q29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChlbnZQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgZW52Q29uZmlnID0gZG90ZW52LnBhcnNlKGVudkNvbnRlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW52Q29uZmlnLkdJVEhVQl9UT0tFTiB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFx1NTNENlx1NUY5N1x1NzU3Nlx1NTI0RFx1OTA3OFx1NTNENlx1NjU4N1x1NUI1N1x1RkYwQ1x1NEUyNlx1NTIyOVx1NzUyOFx1NTBCM1x1NTE2NVx1NzY4NFx1ODY1NVx1NzQwNlx1NTFGRFx1NUYwRlx1ODY1NVx1NzQwNlx1NUY4Q1x1NjZGRlx1NjNEQlx1NTM5Rlx1NjU4N1x1NUI1N1xyXG4gICAgICovXHJcbiAgICBwcm9jZXNzU2VsZWN0ZWRUZXh0KHByb2Nlc3NvcjogKHRleHQ6IHN0cmluZykgPT4gc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZVZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9IHByb2Nlc3NvcihzZWxlY3RlZFRleHQpO1xyXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihwcm9jZXNzZWRUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTVDMDdcdTY1ODdcdTRFRjZcdTRFMkRcdTc2ODRcdTY4OURcdTZCM0VcdThGNDlcdTYzREJcdTYyMTBcdTZBMTlcdTk4NENcclxuICAgICAqL1xyXG4gICAgY29udmVydEFydGljbGVIZWFkaW5ncygpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgICAgICBpZiAoYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVkaXRvci5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKltcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNdK1xccypcdTdERTgvZ20sIG1hdGNoID0+IGAjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKltcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNdK1xccypcdTdBRTAvZ20sIG1hdGNoID0+IGAjIyAke21hdGNofWApXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlx1N0IyQ1xccypbXHU5NkY2XHU0RTAwXHU0RThDXHU0RTA5XHU1NkRCXHU0RTk0XHU1MTZEXHU0RTAzXHU1MTZCXHU0RTVEXHU1MzQxXHU3NjdFXHU1MzQzXHU4NDJDXStcXHMqXHU3QkMwL2dtLCBtYXRjaCA9PiBgIyMjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKltcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNdK1xccypcdTZCM0UvZ20sIG1hdGNoID0+IGAjIyMjICR7bWF0Y2h9YClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXHU3QjJDXFxzKltcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNdK1xccypcdTc2RUUvZ20sIG1hdGNoID0+IGAjIyMjIyAke21hdGNofWApXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlx1N0IyQ1xccypcXGQrXFxzKlx1Njg5RC9nbSwgbWF0Y2ggPT4gYCMjIyMjIyAke21hdGNofWApXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlx1OENDN1x1NjU5OVx1NEY4Nlx1NkU5MFx1RkYxQVx1NTE2OFx1NTcwQlx1NkNENVx1ODk4Rlx1OENDN1x1NjU5OVx1NUVBQi9nbSwgbWF0Y2ggPT4gYCMgJHttYXRjaH1gKTtcclxuICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKHVwZGF0ZWRDb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTYyQzZcdTUyMDZcdTY1ODdcdTRFRjZcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc3BsaXREb2N1bWVudCgpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgICAgICBpZiAoYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gXHU1MTQ4XHU1N0Y3XHU4ODRDXHU0RTAwXHU2QjIxIGNsZWFuRG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5Eb2N1bWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVkaXRvci5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyUGF0aFByZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhY3RpdmVWaWV3LmZpbGUucGF0aCkucGF0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSBmb2xkZXJQYXRoUHJlLnJlcGxhY2UoLy5tZCQvLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZU5hbWUgPSBhY3RpdmVWaWV3LmZpbGUuYmFzZW5hbWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb2xkZXJOYW1lID0gZm9sZGVyUGF0aC5zcGxpdCgnLycpLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFx1NjVCMFx1NTg5RVx1OENDN1x1NjU5OVx1NTkzRVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGZvbGRlclBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gY29udGVudC5zcGxpdCgvKD89XlxcZCtcXC4pL2dtKTtcclxuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGAtLS1cXG50YWdzOlxcbiAgLSBcdTgwMDNcdTk4NENcXG4gIC0gXHU5ODRDXHU3NkVFXFxuICAtIFx1NjcyQVx1NUI4Q1xcblNvdXJzZTpcXG5SZWxhdGU6IFxcbmFsaWFzZXM6XFxuLS0tXFxuYDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHNlY3Rpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25UaXRsZSA9IHNlY3Rpb24ubWF0Y2goL15cXGQrXFwuLyk/LlswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25UaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2xlYW5UaXRsZSA9IHNlY3Rpb25UaXRsZS5yZXBsYWNlKC9cXC4kLywgJycpLnRyaW0oKTsgLy8gXHU1M0JCXHU5NjY0XHU3RDUwXHU1QzNFXHU3Njg0IC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGVOYW1lID0gYCR7Zm9sZGVyUGF0aH0vJHtmb2xkZXJOYW1lfS1cdTdCMkMxXHU1OTI3XHU5ODRDXHU3QjJDJHtjbGVhblRpdGxlfVx1OTg0Qy5tZGA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChmaWxlTmFtZXMuaGFzKG5ld0ZpbGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZU5hbWUgPSBgJHtmb2xkZXJQYXRofS8ke2ZvbGRlck5hbWV9LVx1N0IyQyR7Y291bnRlcn1cdTU5MjdcdTk4NENcdTdCMkMke2NsZWFuVGl0bGV9XHU5ODRDLm1kYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVzLmFkZChuZXdGaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShuZXdGaWxlTmFtZSwgcHJlZml4ICsgc2VjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gdXBkYXRlZENvbnRlbnQucmVwbGFjZShzZWN0aW9uLCBgIyMgIVtbJHtmb2xkZXJOYW1lfS1cdTdCMkMke2NvdW50ZXIgLSAxfVx1NTkyN1x1OTg0Q1x1N0IyQyR7Y2xlYW5UaXRsZX1cdTk4NENdXVxcbmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUodXBkYXRlZENvbnRlbnQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3BsaXR0aW5nIGRvY3VtZW50OicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1NjJDNlx1NTIwNlx1NjU4N1x1NEVGNlx1NjY0Mlx1NzY3Q1x1NzUxRlx1OTg1RVx1NTc4Qlx1OTMyRlx1OEFBNFx1RkYwQ1x1OEFDQlx1NkFBMlx1NjdFNVx1NjNBN1x1NTIzNlx1NTNGMFx1NEVFNVx1NzM3Mlx1NTNENlx1OEE3M1x1N0QzMFx1OENDN1x1OEEwQVx1MzAwMicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnXHU2MkM2XHU1MjA2XHU2NTg3XHU0RUY2XHU2NjQyXHU3NjdDXHU3NTFGXHU1RjE1XHU3NTI4XHU5MzJGXHU4QUE0XHVGRjBDXHU4QUNCXHU2QUEyXHU2N0U1XHU2M0E3XHU1MjM2XHU1M0YwXHU0RUU1XHU3MzcyXHU1M0Q2XHU4QTczXHU3RDMwXHU4Q0M3XHU4QTBBXHUzMDAyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdTY1NzRcdTc0MDZcdTY1ODdcdTRFRjZcclxuICAgICAqIC0gXHU1OTgyXHU2NzlDXHU0RTAwXHU4ODRDXHU0RTJEXHU1M0VBXHU2NzA5MVx1NTAwQlx1NjU3OFx1NUI1N1x1ODAwQ1x1NkM5Mlx1NjcwOVx1NTE3Nlx1NEVENlx1NjU4N1x1NUI1N1x1RkYwQ1x1NTIyQVx1OTY2NFx1OTAxOVx1NEUwMFx1ODg0Q1xyXG4gICAgICogLSBcdTU5ODJcdTY3OUNcdTRFMDBcdTg4NENcdTRFRTVcIm4uXCJcdTk1OEJcdTU5Q0JcdUZGMENcdTUzQkJcdTk2NjRcIm4uXCJcdTUyMzBcdTRFMEJcdTRFMDBcdTUwMEJcIlx1RkYxRlwiXHU5NTkzXHU3Njg0XHU2MjQwXHU2NzA5XHU2M0RCXHU4ODRDXHJcbiAgICAgKi9cclxuICAgIGNsZWFuRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZVZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBcdTUyMkFcdTk2NjRcdTUzRUFcdTY3MDlcdTRFMDBcdTUwMEJcdTY1NzhcdTVCNTdcdTc2ODRcdTg4NENcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxcZCtcXHMqJC9nbSwgJycpO1xyXG5cclxuICAgICAgICAgICAgLy8gXHU1M0JCXHU5NjY0XHU0RUU1XCJuLlwiXHU5NThCXHU1OUNCXHU1MjMwXHU0RTBCXHU0RTAwXHU1MDBCXCJcdUZGMUZcIlx1OTU5M1x1NzY4NFx1NjI0MFx1NjcwOVx1NjNEQlx1ODg0Q1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oXFxkK1xcLlteXHVGRjFGXSpcdUZGMUYpL2dtLCAobWF0Y2gsIHAxKSA9PiBwMS5yZXBsYWNlKC9cXG4vZywgJycpKTtcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKFx1MzAwQ1teXHUzMDBEXSpcdTMwMEQpL2dtLCAoXywgcDEpID0+IHAxLnJlcGxhY2UoL1xcbi9nLCAnJykpO1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oXHVGRjA4W15cdUZGMDldKlx1RkYwOSkvZ20sIChfLCBwMSkgPT4gcDEucmVwbGFjZSgvXFxuL2csICcnKSk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcKFteKV0qXFwpL2dtLCBtYXRjaCA9PiBtYXRjaC5yZXBsYWNlKC9cXG4vZywgJycpKTtcclxuXHJcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gXHU2NTc0XHU3NDA2XHU2ODlEXHU2NTg3XHU1QzBEXHU3MTY3XHU4ODY4XHJcbiAgICBjbGVhblRhYmxlKCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xyXG4gICAgICAgIGlmIChhY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGVkaXRvci5nZXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gXHU2QUEyXHU2N0U1XHU2QTk0XHU2ODQ4XHU2NzAwXHU1MjREXHU5NzYyXHU2NjJGXHU1NDI2XHU2NzA5XHU0RUU1IC0tLSBcdTY4NDZcdThENzdcdTRGODZcdTc2ODQgWUFNTCBcdTUzNDBcdTU3REZcclxuICAgICAgICAgICAgbGV0IHlhbWxIZWFkZXIgPSAnJztcclxuICAgICAgICAgICAgY29uc3QgeWFtbE1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbltcXHNcXFNdKj9cXG4tLS1cXG4vKTtcclxuICAgICAgICAgICAgaWYgKHlhbWxNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgeWFtbEhlYWRlciA9IHlhbWxNYXRjaFswXTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKHlhbWxIZWFkZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMS4gXHU2NkZGXHU2M0RCXHU1QjU3XHU3QjI2XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcKlxcKi9nLCAnPT0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCgvZywgJ1x1RkYwOCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKS9nLCAnXHVGRjA5JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGJyPi9nLCAnICcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXHUwMEEwXFx0XSsvZywgJyAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDIuIFx1OTA0RFx1NkI3N1x1NkJDRlx1NEUwMFx1ODg0Q1x1RkYwQ1x1NTNCQlx1OTY2NFx1NTNFQVx1NTQyQlx1NjcwOXxcdTMwMDEtXHU2MjE2XHU3QTdBXHU3NjdEXHU3Njg0XHU4ODRDXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiAhL15bXFx8XFwtXFxzXSokLy50ZXN0KGxpbmUpKS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDMuIFx1NzlGQlx1OTY2NCB8IFx1NUY4Q1x1NzY4NFx1NTkxQVx1NTAwQlx1N0E3QVx1NzY3RFxyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXHwgKy9nLCAnfCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gNC4gXHU5MDREXHU2Qjc3XHU2QkNGXHU0RTAwXHU4ODRDXHVGRjBDXHU3NTc2XHU0RTAwXHU4ODRDXHU0RUU1fFx1OTU4Qlx1NTlDQlx1ODAwQ3xcdTVGOENcdTk3NjJcdTRFMERcdTY2MkZcdTdCMkNcdTRFMkRcdTY1ODdcdTY1NzhcdTVCNTdcdTY4OURcdTY2NDJcdUZGMENcdTVDMDdcdTkwMTlcdTRFMDBcdTg4NENcdTc2ODRcdTUxNjdcdTVCQjlcdTRGNzVcdTUxNjVcdTRFMEFcdTRFMDBcdTg4NENcclxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLnN0YXJ0c1dpdGgoJ3wnKSAmJiAhL1xcfFx1N0IyQ1tcdTk2RjZcdTRFMDBcdTRFOENcdTRFMDlcdTU2REJcdTRFOTRcdTUxNkRcdTRFMDNcdTUxNkJcdTRFNURcdTUzNDFcdTc2N0VcdTUzNDNcdTg0MkNcdTUxMDRcdTUxNDZdK1xccypcdTY4OUQuKiQvLnRlc3QobGluZXNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDZWxscyA9IGxpbmVzW2kgLSAxXS5zcGxpdCgnfCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDZWxscyA9IGxpbmVzW2ldLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyZW50Q2VsbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsc1tqXS50cmltKCkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NlbGxzW2pdID0gKHByZXZpb3VzQ2VsbHNbal0gfHwgJycpICsgY3VycmVudENlbGxzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2kgLSAxXSA9IHByZXZpb3VzQ2VsbHMuam9pbignfCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBsaW5lcy5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDUuIFx1NTNCQlx1OTY2NFx1NTkxQVx1OTkxOFx1N0E3QVx1NjgzQ1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oPzwhW2EtekEtWjAtOV8uLF0pWyBcdTAwQTBcXHRdK3xbIFx1MDBBMFxcdF0rKD8hW2EtekEtWjAtOV8uLF0pfF5bIFxcdF0rfFsgXFx0XSskL2dtLCAnJylcclxuXHJcbiAgICAgICAgICAgIC8vIDYuIFx1NzBCQVx1NEVFNXxcdTk1OEJcdTk4MkRcdTc2ODRcdTZCQ0ZcdTRFMDBcdTg4NENcdTUyQTBcdTRFMEFcdTUyNERcdTU4OUNcdUZGMENcdTRFMjZcdTU3MjhcdTdCMkNcdTRFMDlcdTUwMEJ8XHU1RjhDXHU2NUI5XHU2M0RCXHU4ODRDXHU1RjhDXHU1MkEwXHU0RTBBXCJcdThBQUFcdTY2MEVcdUZGMUFcXG5cIlx1RkYwQ1x1NTNCQlx1OTY2NFx1ODg0Q1x1NUMzRVx1NzY4NHxcdTUzQ0FcdTUxNzZcdTVGOENcdTc2ODRcdTdBN0FcdTc2N0RcclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ3wnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnfCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzLnNsaWNlKDAsIDMpLmpvaW4oJ3wnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlY29uZFBhcnQgPSBwYXJ0cy5zbGljZSgzKS5qb2luKCd8JykucmVwbGFjZSgvXFx8XFxzKiQvLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQYXJ0ID0gc2Vjb25kUGFydC5yZXBsYWNlKC8oXFxkKylcXC4vZywgXCJcXG5cdFx0JDEuIFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx1NUMwN1wiXHU0RTJEXHU2NTg3XHU2NTc4XHU1QjU3XHUzMDAxXCJcdTY2RkZcdTYzREJcdTYyMTBcdTVDMERcdTYxQzlcdTc2ODRcIm4uIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFBhcnQgPSBzZWNvbmRQYXJ0LnJlcGxhY2UoLyhbXHU5NkY2XHU0RTAwXHU0RThDXHU0RTA5XHU1NkRCXHU0RTk0XHU1MTZEXHU0RTAzXHU1MTZCXHU0RTVEXHU1MzQxXHU3NjdFXHU1MzQzXHU4NDJDXHU1MTA0XHU1MTQ2XSspXHUzMDAxL2csIChtYXRjaCwgcDEpID0+IGBcXG4ke3RoaXMuY29udmVydENoaW5lc2VOdW1iZXJUb0FyYWJpYyhwMSl9LiBgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFx1NUMwN1wiXHVGRjA4XHU0RTJEXHU2NTg3XHU2NTc4XHU1QjU3XHVGRjA5XCJcdTY2RkZcdTYzREJcdTYyMTBcdTVDMERcdTYxQzlcdTc2ODRcIiBuLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFBhcnQgPSBzZWNvbmRQYXJ0LnJlcGxhY2UoL1x1RkYwOChbXHU5NkY2XHU0RTAwXHU0RThDXHU0RTA5XHU1NkRCXHU0RTk0XHU1MTZEXHU0RTAzXHU1MTZCXHU0RTVEXHU1MzQxXHU3NjdFXHU1MzQzXHU4NDJDXHU1MTA0XHU1MTQ2XSspXHVGRjA5L2csIChtYXRjaCwgcDEpID0+IGBcXG5cdCR7dGhpcy5jb252ZXJ0Q2hpbmVzZU51bWJlclRvQXJhYmljKHAxKX0uIGApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXG58XHU0RkVFXHU2QjYzXHU1RjhDfFx1NEZFRVx1NkI2M1x1NTI0RHxcXG58LS0tfC0tLXxcXG4ke2ZpcnN0UGFydH18XFxuXHU4QUFBXHU2NjBFXHVGRjFBJHtzZWNvbmRQYXJ0fWA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgLy8gNy4gXHU3QTdBXHU2ODNDXHU0RkVFXHU2QjYzXHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLywoPz1bYS16QS1aXSkvZywgXCIsIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxICQyXCIpO1xyXG5cclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFx8XHU0RkVFXHU2QjYzXHU1RjhDXFx8XHU0RkVFXHU2QjYzXHU1MjREXFx8XFxuXFx8LS0tXFx8LS0tXFx8XFxuXFx8KD09KSpcdTdCMkMoPT0pKihbXHU5NkY2XHU0RTAwXHU0RThDXHU0RTA5XHU1NkRCXHU0RTk0XHU1MTZEXHU0RTAzXHU1MTZCXHU0RTVEXHU1MzQxXHU3NjdFXHU1MzQzXHU4NDJDXHU1MTA0XHU1MTQ2XSspKD09KSpcdTY4OUQoPT0pKi9nLFxyXG4gICAgICAgICAgICAoXywgZXF1YWxzQmVmb3JlQXJ0aWNsZSwgZXF1YWxzQmVmb3JlTnVtYmVyLCBjaGluZXNlTnVtYmVyLCBlcXVhbHNBZnRlck51bWJlciwgZXF1YWxzQWZ0ZXJBcnRpY2xlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCMjIyMjIyBcdTdCMkMke2NoaW5lc2VOdW1iZXJ9XHU2ODlEXFxufFx1NEZFRVx1NkI2M1x1NUY4Q3xcdTRGRUVcdTZCNjNcdTUyNER8XFxufC0tLXwtLS18XFxufCR7ZXF1YWxzQmVmb3JlQXJ0aWNsZSB8fCAnJ31cdTdCMkMke2VxdWFsc0JlZm9yZU51bWJlciB8fCAnJ30ke2NoaW5lc2VOdW1iZXJ9JHtlcXVhbHNBZnRlck51bWJlciB8fCAnJ31cdTY4OUQke2VxdWFsc0FmdGVyQXJ0aWNsZSB8fCAnJ31gO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFx1NUMwNyBZQU1MIFx1NTM0MFx1NTdERlx1NTJBMFx1NTZERVx1NTNCQlxyXG4gICAgICAgICAgICBjb250ZW50ID0geWFtbEhlYWRlciArIGNvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUoY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHU1QzA3XHU0RTJEXHU2NTg3XHU2NTc4XHU1QjU3XHU4RjQ5XHU2M0RCXHU3MEJBXHU5NjNGXHU2MkM5XHU0RjJGXHU2NTc4XHU1QjU3XHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRDaGluZXNlTnVtYmVyVG9BcmFiaWMoY2hpbmVzZU51bWJlcjogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBjaGluZXNlRGlnaXRzID0gJ1x1OTZGNlx1NEUwMFx1NEU4Q1x1NEUwOVx1NTZEQlx1NEU5NFx1NTE2RFx1NEUwM1x1NTE2Qlx1NEU1RCc7XHJcbiAgICAgICAgY29uc3QgY2hpbmVzZVVuaXRzID0gJ1x1NTM0MVx1NzY3RVx1NTM0M1x1NTM0M1x1ODQyQ1x1NTEwNFx1NTE0Nic7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICAgICAgbGV0IHVuaXQgPSAxO1xyXG4gICAgICAgIGxldCB0ZW1wID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaW5lc2VOdW1iZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoaW5lc2VOdW1iZXJbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gY2hpbmVzZURpZ2l0cy5pbmRleE9mKGNoYXIpO1xyXG4gICAgICAgICAgICBpZiAoZGlnaXQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wICs9IGRpZ2l0ICogdW5pdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXRJbmRleCA9IGNoaW5lc2VVbml0cy5pbmRleE9mKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bml0ID0gTWF0aC5wb3coMTAsIHVuaXRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZW1wICogdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gdGVtcDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBUZXh0UHJvY2Vzc2luZ1BsdWdpblNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICAgIHBsdWdpbjogVGV4dFByb2Nlc3NpbmdQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVGV4dFByb2Nlc3NpbmdQbHVnaW4pIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdUZXh0IFByb2Nlc3NpbmcgUGx1Z2luIFNldHRpbmdzJyB9KTtcclxuXHJcbiAgICAgICAgbGV0IHRva2VuSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHJlcG9JbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgYnJhbmNoSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnR2l0SHViIFBlcnNvbmFsIEFjY2VzcyBUb2tlbicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdcdThBQ0JcdThGMzhcdTUxNjVcdTRGNjBcdTc2ODQgR2l0SHViIFx1NTAwQlx1NEVCQVx1OEEyQVx1NTU0Rlx1NEVFNFx1NzI0Q1x1MzAwMlx1NEY2MFx1NTNFRlx1NEVFNVx1NTcyOCBHaXRIdWIgXHU3Njg0XHU4QTJEXHU1QjlBXHU0RTJEXHU3NTFGXHU2MjEwXHU0RTAwXHU1MDBCXHU2NUIwXHU3Njg0XHU1MDBCXHU0RUJBXHU4QTJBXHU1NTRGXHU0RUU0XHU3MjRDXHUzMDAyJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbklucHV0ID0gdGV4dC5pbnB1dEVsO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciB0b2tlbicpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdHaXRIdWIgUmVwb3NpdG9yeScpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdcdThBQ0JcdThGMzhcdTUxNjVcdTRGNjBcdTc2ODQgR2l0SHViIFx1NTEzMlx1NUI1OFx1NUVBQlx1NTQwRFx1N0EzMVx1RkYwOFx1NEY4Qlx1NTk4Mlx1RkYxQXVzZXJuYW1lL3JlcG9cdUZGMDlcdTMwMDInKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcG9JbnB1dCA9IHRleHQuaW5wdXRFbDtcclxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgcmVwb3NpdG9yeScpO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnR2l0SHViIEJyYW5jaCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdcdThBQ0JcdThGMzhcdTUxNjVcdTRGNjBcdTc2ODQgR2l0SHViIFx1NTIwNlx1NjUyRlx1NTQwRFx1N0EzMVx1MzAwMicpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgYnJhbmNoSW5wdXQgPSB0ZXh0LmlucHV0RWw7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIGJyYW5jaCcpO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdcdTUxMzJcdTVCNThcdThBMkRcdTVCOUEnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbyA9IHJlcG9JbnB1dC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gYnJhbmNoSW5wdXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVUb2tlblRvRW52KHRva2VuSW5wdXQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdcdThBMkRcdTVCOUFcdTVERjJcdTUxMzJcdTVCNTgnKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2F2ZVRva2VuVG9FbnYodG9rZW46IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHZhdWx0UGF0aCA9ICh0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlciBhcyBhbnkpLmJhc2VQYXRoO1xyXG4gICAgICAgIGNvbnN0IGVudlBhdGggPSBwYXRoLmpvaW4odmF1bHRQYXRoLCAnLmVudicpO1xyXG4gICAgICAgIGNvbnN0IGVudkNvbnRlbnQgPSBgR0lUSFVCX1RPS0VOPSR7dG9rZW59XFxuYDtcclxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGVudlBhdGgsIGVudkNvbnRlbnQpO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgdHlwZSB7IEdyYXBoUUxSZXF1ZXN0Q29udGV4dCwgR3JhcGhRTFJlc3BvbnNlIH0gZnJvbSAnLi4vaGVscGVycy90eXBlcy5qcydcblxuZXhwb3J0IGNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVzcG9uc2U6IEdyYXBoUUxSZXNwb25zZVxuICBwdWJsaWMgcmVxdWVzdDogR3JhcGhRTFJlcXVlc3RDb250ZXh0XG5cbiAgY29uc3RydWN0b3IocmVzcG9uc2U6IEdyYXBoUUxSZXNwb25zZSwgcmVxdWVzdDogR3JhcGhRTFJlcXVlc3RDb250ZXh0KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGAke0NsaWVudEVycm9yLmV4dHJhY3RNZXNzYWdlKHJlc3BvbnNlKX06ICR7XG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgfSlcbiAgICB9YFxuXG4gICAgc3VwZXIobWVzc2FnZSlcblxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDbGllbnRFcnJvci5wcm90b3R5cGUpXG5cbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG5cbiAgICAvLyB0aGlzIGlzIG5lZWRlZCBhcyBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IC5jYXB0dXJlU3RhY2tUcmFjZVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IGBmdW5jdGlvbmApIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENsaWVudEVycm9yKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGV4dHJhY3RNZXNzYWdlKHJlc3BvbnNlOiBHcmFwaFFMUmVzcG9uc2UpOiBzdHJpbmcge1xuICAgIHJldHVybiByZXNwb25zZS5lcnJvcnM/LlswXT8ubWVzc2FnZSA/PyBgR3JhcGhRTCBFcnJvciAoQ29kZTogJHtTdHJpbmcocmVzcG9uc2Uuc3RhdHVzKX0pYFxuICB9XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCB0eXBlIFJlbW92ZUluZGV4PFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUIGFzIHN0cmluZyBleHRlbmRzIEsgPyBuZXZlciA6IG51bWJlciBleHRlbmRzIEsgPyBuZXZlciA6IEtdOiBUW0tdXG59XG5cbmV4cG9ydCBjb25zdCB1cHBlcmNhc2UgPSA8UyBleHRlbmRzIHN0cmluZz4oc3RyOiBTKTogVXBwZXJjYXNlPFM+ID0+IHN0ci50b1VwcGVyQ2FzZSgpIGFzIFVwcGVyY2FzZTxTPlxuXG5leHBvcnQgY29uc3QgY2FsbE9ySWRlbnRpdHkgPSA8VD4odmFsdWU6IE1heWJlTGF6eTxUPikgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBgZnVuY3Rpb25gID8gKHZhbHVlIGFzICgpID0+IFQpKCkgOiB2YWx1ZVxufVxuXG5leHBvcnQgdHlwZSBNYXliZUxhenk8VD4gPSBUIHwgKCgpID0+IFQpXG5cbmV4cG9ydCBjb25zdCB6aXAgPSA8QSwgQj4oYTogQVtdLCBiOiBCW10pOiBbQSwgQiB8IHVuZGVmaW5lZF1bXSA9PiBhLm1hcCgoaywgaSkgPT4gW2ssIGJbaV1dKVxuXG5leHBvcnQgY29uc3QgSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0ID0gKGhlYWRlcnM/OiBIZWFkZXJzSW5pdCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPT4ge1xuICBsZXQgb0hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIG9IZWFkZXJzID0gSGVhZGVyc0luc3RhbmNlVG9QbGFpbk9iamVjdChoZWFkZXJzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChuYW1lICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb0hlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIG9IZWFkZXJzID0gaGVhZGVyc1xuICB9XG5cbiAgcmV0dXJuIG9IZWFkZXJzXG59XG5cbmV4cG9ydCBjb25zdCBIZWFkZXJzSW5zdGFuY2VUb1BsYWluT2JqZWN0ID0gKGhlYWRlcnM6IFJlc3BvbnNlWydoZWFkZXJzJ10pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgY29uc3QgbzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XG4gIGhlYWRlcnMuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgIG9ba10gPSB2XG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmV4cG9ydCBjb25zdCB0cnlDYXRjaCA9IDwkUmV0dXJuLCAkVGhyb3cgZXh0ZW5kcyBFcnJvciA9IEVycm9yPihcbiAgZm46ICgpID0+ICRSZXR1cm4sXG4pOiAkUmV0dXJuIGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gUHJvbWlzZTxBd2FpdGVkPCRSZXR1cm4+IHwgJFRocm93PiA6ICRSZXR1cm4gfCAkVGhyb3cgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCkgYXMgYW55XG4gICAgaWYgKGlzUHJvbWlzZUxpa2VWYWx1ZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICByZXR1cm4gZXJyb3JGcm9tTWF5YmVFcnJvcihlcnJvcilcbiAgICAgIH0pIGFzIGFueVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yRnJvbU1heWJlRXJyb3IoZXJyb3IpIGFzIGFueVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIGFuZCByZXR1cm4gaXQuIElmIGl0IGlzIG5vdCBhbiBlcnJvciB0aGFuXG4gKiB3cmFwIGl0IGluIG9uZSwgcGFzc2luZyB0aGUgZ2l2ZW4gdmFsdWUgYXMgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBjb25zdCBlcnJvckZyb21NYXliZUVycm9yID0gKG1heWJlRXJyb3I6IHVua25vd24pOiBFcnJvciA9PiB7XG4gIGlmIChtYXliZUVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBtYXliZUVycm9yXG4gIHJldHVybiBuZXcgRXJyb3IoU3RyaW5nKG1heWJlRXJyb3IpKVxufVxuXG5leHBvcnQgY29uc3QgaXNQcm9taXNlTGlrZVZhbHVlID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUHJvbWlzZTx1bmtub3duPiA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSBgb2JqZWN0YFxuICAgICYmIHZhbHVlICE9PSBudWxsXG4gICAgJiYgYHRoZW5gIGluIHZhbHVlXG4gICAgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IGBmdW5jdGlvbmBcbiAgICAmJiBgY2F0Y2hgIGluIHZhbHVlXG4gICAgJiYgdHlwZW9mIHZhbHVlLmNhdGNoID09PSBgZnVuY3Rpb25gXG4gICAgJiYgYGZpbmFsbHlgIGluIHZhbHVlXG4gICAgJiYgdHlwZW9mIHZhbHVlLmZpbmFsbHkgPT09IGBmdW5jdGlvbmBcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgY2FzZXNFeGhhdXN0ZWQgPSAodmFsdWU6IG5ldmVyKTogbmV2ZXIgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjYXNlOiAke1N0cmluZyh2YWx1ZSl9YClcbn1cblxuZXhwb3J0IGNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IGBvYmplY3RgICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKVxufVxuXG5leHBvcnQgY29uc3QgZW50cmllcyA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ob2JqOiBUKSA9PiBPYmplY3QuZW50cmllcyhvYmopIGFzIFtrZXlvZiBULCBUW2tleW9mIFRdXVtdXG5cbmV4cG9ydCBjb25zdCB2YWx1ZXMgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihvYmo6IFQpOiBUW2tleW9mIFRdW10gPT4gT2JqZWN0LnZhbHVlcyhvYmopIGFzIFRba2V5b2YgVF1bXVxuXG4vLyBkcHJpbnQtaWdub3JlXG5leHBvcnQgdHlwZSBFeGFjdDwkVmFsdWUsICRDb25zdHJhaW50PiA9XG4gIChcbiAgICAkVmFsdWUgZXh0ZW5kcyB1bmtub3duICA/ICRDb25zdHJhaW50IGV4dGVuZHMgJFZhbHVlICAgPyAge30gZXh0ZW5kcyAkVmFsdWUgICAgPyAgJENvbnN0cmFpbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFtLIGluIGtleW9mICRWYWx1ZV06IEV4YWN0PCRWYWx1ZVtLXSwgJENvbnN0cmFpbnRbS10+IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkQ29uc3RyYWludCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXZlclxuICApXG4gIHwgKCRWYWx1ZSBleHRlbmRzIE5hcnJvd2FibGUgPyAkVmFsdWUgOiBuZXZlcilcblxuLy8gZHByaW50LWlnbm9yZVxuLy8gZXhwb3J0IHR5cGUgRXhhY3RPYmplY3ROb25FbXB0eTwkVmFsdWUsICRDb25zdHJhaW50PiA9XG4vLyAgIChcbi8vICAgICAkVmFsdWUgZXh0ZW5kcyB1bmtub3duICA/ICRDb25zdHJhaW50IGV4dGVuZHMgJFZhbHVlICAgPyAga2V5b2YgJFZhbHVlIGV4dGVuZHMgbmV2ZXIgID8gKHsgJ1R5cGVTY3JpcHQgRXJyb3I6IFlvdSBtdXN0IHN1cHBseSBhdCBsZWFzdCBvbmUga2V5Lic6IHRydWUgfSAmICRDb25zdHJhaW50KSAgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFtLIGluIGtleW9mICRWYWx1ZV06IEV4YWN0PCRWYWx1ZVtLXSwgJENvbnN0cmFpbnRbS10+IH0gOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkQ29uc3RyYWludCA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXZlclxuLy8gICApXG4vLyAgIHwgKCRWYWx1ZSBleHRlbmRzIE5hcnJvd2FibGUgPyAkVmFsdWUgOiBuZXZlcilcblxuZXhwb3J0IHR5cGUgTmFycm93YWJsZSA9IHN0cmluZyB8IG51bWJlciB8IGJpZ2ludCB8IGJvb2xlYW4gfCBbXVxuXG5leHBvcnQgdHlwZSBMZXR0ZXIgPSBMZXR0ZXJMb3dlciB8IExldHRlclVwcGVyXG5cbmV4cG9ydCB0eXBlIERpZ2l0ID0gJzAnIHwgJzEnIHwgJzInIHwgJzMnIHwgJzQnIHwgJzUnIHwgJzYnIHwgJzcnIHwgJzgnIHwgJzknXG5cbmV4cG9ydCB0eXBlIExldHRlckxvd2VyID1cbiAgfCAnYSdcbiAgfCAnYidcbiAgfCAnYydcbiAgfCAnZCdcbiAgfCAnZSdcbiAgfCAnZidcbiAgfCAnZydcbiAgfCAnaCdcbiAgfCAnaSdcbiAgfCAnaidcbiAgfCAnaydcbiAgfCAnbCdcbiAgfCAnbSdcbiAgfCAnbidcbiAgfCAnbydcbiAgfCAncCdcbiAgfCAncSdcbiAgfCAncidcbiAgfCAncydcbiAgfCAndCdcbiAgfCAndSdcbiAgfCAndidcbiAgfCAndydcbiAgfCAneCdcbiAgfCAneSdcbiAgfCAneidcbmV4cG9ydCB0eXBlIExldHRlclVwcGVyID1cbiAgfCAnQSdcbiAgfCAnQidcbiAgfCAnQydcbiAgfCAnRCdcbiAgfCAnRSdcbiAgfCAnRidcbiAgfCAnRydcbiAgfCAnSCdcbiAgfCAnSSdcbiAgfCAnSidcbiAgfCAnSydcbiAgfCAnTCdcbiAgfCAnTSdcbiAgfCAnTidcbiAgfCAnTydcbiAgfCAnUCdcbiAgfCAnUSdcbiAgfCAnUidcbiAgfCAnUydcbiAgfCAnVCdcbiAgfCAnVSdcbiAgfCAnVidcbiAgfCAnVydcbiAgfCAnWCdcbiAgfCAnWSdcbiAgfCAnWidcblxuZXhwb3J0IHR5cGUgU3RyaW5nTm9uRW1wdHkgPSBgJHtMZXR0ZXJ9JHtzdHJpbmd9YFxuXG5leHBvcnQgdHlwZSBNYXliZUxpc3Q8VD4gPSBUIHwgVFtdXG5cbmV4cG9ydCB0eXBlIE5vdEVtcHR5T2JqZWN0PFQ+ID0ga2V5b2YgVCBleHRlbmRzIG5ldmVyID8gbmV2ZXIgOiBUXG5cbmV4cG9ydCB0eXBlIFZhbHVlczxUPiA9IFRba2V5b2YgVF1cblxuZXhwb3J0IHR5cGUgR2V0S2V5T3I8VCwgS2V5LCBPcj4gPSBLZXkgZXh0ZW5kcyBrZXlvZiBUID8gVFtLZXldIDogT3JcblxuZXhwb3J0IHR5cGUgQXM8VCwgVT4gPSBVIGV4dGVuZHMgVCA/IFUgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFU+ID0gKFUgZXh0ZW5kcyBhbnkgPyAoazogVSkgPT4gdm9pZCA6IG5ldmVyKSBleHRlbmRzICgoazogaW5mZXIgSSkgPT4gdm9pZCkgPyBJIDogbmV2ZXJcblxuZXhwb3J0IHR5cGUgTGFzdE9mPFQ+ID0gVW5pb25Ub0ludGVyc2VjdGlvbjxUIGV4dGVuZHMgYW55ID8gKCkgPT4gVCA6IG5ldmVyPiBleHRlbmRzICgpID0+IGluZmVyIFIgPyBSIDogbmV2ZXJcblxuLy8gVFM0LjArXG5leHBvcnQgdHlwZSBQdXNoPFQgZXh0ZW5kcyBhbnlbXSwgVj4gPSBbLi4uVCwgVl1cblxuLy8gVFM0LjErXG5leHBvcnQgdHlwZSBVbmlvblRvVHVwbGU8VCwgTCA9IExhc3RPZjxUPiwgTiA9IFtUXSBleHRlbmRzIFtuZXZlcl0gPyB0cnVlIDogZmFsc2U+ID0gdHJ1ZSBleHRlbmRzIE4gPyBbXVxuICA6IFB1c2g8VW5pb25Ub1R1cGxlPEV4Y2x1ZGU8VCwgTD4+LCBMPlxuXG5leHBvcnQgdHlwZSBDb3VudEtleXM8VD4gPSBrZXlvZiBUIGV4dGVuZHMgbmV2ZXIgPyAwIDogVW5pb25Ub1R1cGxlPGtleW9mIFQ+WydsZW5ndGgnXVxuZXhwb3J0IHR5cGUgSXNNdWx0aXBsZUtleXM8VD4gPSBJc011bHRpcGxlPENvdW50S2V5czxUPj5cbmV4cG9ydCB0eXBlIElzTXVsdGlwbGU8VD4gPSBUIGV4dGVuZHMgMCA/IGZhbHNlIDogVCBleHRlbmRzIDEgPyBmYWxzZSA6IHRydWVcblxuZXhwb3J0IHR5cGUgRXhjbHVkZU51bGw8VD4gPSBFeGNsdWRlPFQsIG51bGw+XG5cbmV4cG9ydCBjb25zdCBtYXBWYWx1ZXMgPSA8XG4gICRPYmogZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAkRm4gZXh0ZW5kcyAodmFsdWU6ICRPYmpba2V5b2YgJE9ial0sIGtleToga2V5b2YgJE9iaikgPT4gYW55LFxuPihcbiAgb2JqZWN0OiAkT2JqLFxuICBmbjogJEZuLFxuKTogUmVjb3JkPGtleW9mICRPYmosIFJldHVyblR5cGU8JEZuPj4gPT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG9iamVjdCkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBba2V5LCBmbih2YWx1ZSwga2V5KV1cbiAgICB9KSxcbiAgKSBhcyBSZWNvcmQ8a2V5b2YgJE9iaiwgUmV0dXJuVHlwZTwkRm4+PlxufVxuXG5leHBvcnQgdHlwZSBTZXRQcm9wZXJ0eTwkT2JqIGV4dGVuZHMgb2JqZWN0LCAkUHJvcCBleHRlbmRzIGtleW9mICRPYmosICRUeXBlIGV4dGVuZHMgJE9ialskUHJvcF0+ID1cbiAgJiBPbWl0PCRPYmosICRQcm9wPlxuICAmIHsgW18gaW4gJFByb3BdOiAkVHlwZSB9XG5cbmV4cG9ydCBjb25zdCBsb3dlckNhc2VGaXJzdExldHRlciA9IChzOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIHMuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzLnNsaWNlKDEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcnJheSh2OiB1bmtub3duKTogYXNzZXJ0cyB2IGlzIHVua25vd25bXSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcnJheS4gR290OiAke1N0cmluZyh2KX1gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHY6IHVua25vd24pOiBhc3NlcnRzIHYgaXMgb2JqZWN0IHtcbiAgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgIT09IGBvYmplY3RgKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG9iamVjdC4gR290OiAke1N0cmluZyh2KX1gKVxufVxuXG5leHBvcnQgdHlwZSBTdHJpbmdLZXlvZjxUPiA9IGtleW9mIFQgJiBzdHJpbmdcblxuZXhwb3J0IHR5cGUgTWF5YmVQcm9taXNlPFQ+ID0gVCB8IFByb21pc2U8VD5cblxuZXhwb3J0IGNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IChzdHJpbmc6IHN0cmluZykgPT4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpXG5cbmV4cG9ydCB0eXBlIFNvbWVBc3luY0Z1bmN0aW9uID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gUHJvbWlzZTx1bmtub3duPlxuXG5leHBvcnQgdHlwZSBTb21lTWF5YmVBc3luY0Z1bmN0aW9uID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gTWF5YmVQcm9taXNlPHVua25vd24+XG5cbmV4cG9ydCB0eXBlIERlZmVycmVkPFQ+ID0ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+XG4gIGlzUmVzb2x2ZWQ6ICgpID0+IGJvb2xlYW5cbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWZlcnJlZCA9IDwkVD4ob3B0aW9ucz86IHsgc3RyaWN0PzogYm9vbGVhbiB9KTogRGVmZXJyZWQ8JFQ+ID0+IHtcbiAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZVxuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiAkVCkgPT4gdm9pZFxuICBsZXQgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWRcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8JFQ+KCgkcmVzb2x2ZSwgJHJlamVjdCkgPT4ge1xuICAgIHJlc29sdmUgPSAkcmVzb2x2ZVxuICAgIHJlamVjdCA9ICRyZWplY3RcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgaXNSZXNvbHZlZDogKCkgPT4gaXNSZXNvbHZlZCxcbiAgICByZXNvbHZlOiAodmFsdWUpID0+IHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlXG4gICAgICBpZiAob3B0aW9ucz8uc3RyaWN0ICYmIGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWZlcnJlZCBpcyBhbHJlYWR5IHJlc29sdmVkLiBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSB3aXRoOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSh2YWx1ZSlcbiAgICB9LFxuICAgIHJlamVjdDogKGVycm9yKSA9PiByZWplY3QoZXJyb3IpLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnZbYERFQlVHYF0pIHtcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1Z1N1YiA9ICguLi5hcmdzOiBhbnlbXSkgPT4gKC4uLnN1YkFyZ3M6IGFueVtdKSA9PiB7XG4gIGRlYnVnKC4uLmFyZ3MsIC4uLnN1YkFyZ3MpXG59XG5cbmV4cG9ydCB0eXBlIFBsdXNPbmVVcFRvVGVuPG4gZXh0ZW5kcyBudW1iZXI+ID0gbiBleHRlbmRzIDAgPyAxXG4gIDogbiBleHRlbmRzIDEgPyAyXG4gIDogbiBleHRlbmRzIDIgPyAzXG4gIDogbiBleHRlbmRzIDMgPyA0XG4gIDogbiBleHRlbmRzIDQgPyA1XG4gIDogbiBleHRlbmRzIDUgPyA2XG4gIDogbiBleHRlbmRzIDYgPyA3XG4gIDogbiBleHRlbmRzIDcgPyA4XG4gIDogbiBleHRlbmRzIDggPyA5XG4gIDogbiBleHRlbmRzIDkgPyAxMFxuICA6IG5ldmVyXG5cbmV4cG9ydCB0eXBlIE1pbnVzT25lVXBUb1RlbjxuIGV4dGVuZHMgbnVtYmVyPiA9IG4gZXh0ZW5kcyAxMCA/IDlcbiAgOiBuIGV4dGVuZHMgOSA/IDhcbiAgOiBuIGV4dGVuZHMgOCA/IDdcbiAgOiBuIGV4dGVuZHMgNyA/IDZcbiAgOiBuIGV4dGVuZHMgNiA/IDVcbiAgOiBuIGV4dGVuZHMgNSA/IDRcbiAgOiBuIGV4dGVuZHMgNCA/IDNcbiAgOiBuIGV4dGVuZHMgMyA/IDJcbiAgOiBuIGV4dGVuZHMgMiA/IDFcbiAgOiBuIGV4dGVuZHMgMSA/IDBcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBmaW5kSW5kZXhGb3JWYWx1ZTx2YWx1ZSwgbGlzdCBleHRlbmRzIHJlYWRvbmx5IFthbnksIC4uLmFueVtdXT4gPSBmaW5kSW5kZXhGb3JWYWx1ZV88dmFsdWUsIGxpc3QsIDA+XG50eXBlIGZpbmRJbmRleEZvclZhbHVlXzx2YWx1ZSwgbGlzdCBleHRlbmRzIHJlYWRvbmx5IFthbnksIC4uLmFueVtdXSwgaSBleHRlbmRzIG51bWJlcj4gPSB2YWx1ZSBleHRlbmRzIGxpc3RbaV0gPyBpXG4gIDogZmluZEluZGV4Rm9yVmFsdWVfPHZhbHVlLCBsaXN0LCBQbHVzT25lVXBUb1RlbjxpPj5cblxuZXhwb3J0IHR5cGUgRmluZFZhbHVlQWZ0ZXI8dmFsdWUsIGxpc3QgZXh0ZW5kcyByZWFkb25seSBbYW55LCAuLi5hbnlbXV0+ID1cbiAgbGlzdFtQbHVzT25lVXBUb1RlbjxmaW5kSW5kZXhGb3JWYWx1ZTx2YWx1ZSwgbGlzdD4+XVxuXG5leHBvcnQgdHlwZSBWYWx1ZU9yPHZhbHVlLCBvclZhbHVlPiA9IHZhbHVlIGV4dGVuZHMgdW5kZWZpbmVkID8gb3JWYWx1ZSA6IHZhbHVlXG5cbmV4cG9ydCB0eXBlIEZpbmRWYWx1ZUFmdGVyT3I8dmFsdWUsIGxpc3QgZXh0ZW5kcyByZWFkb25seSBbYW55LCAuLi5hbnlbXV0sIG9yVmFsdWU+ID0gVmFsdWVPcjxcbiAgbGlzdFtQbHVzT25lVXBUb1RlbjxmaW5kSW5kZXhGb3JWYWx1ZTx2YWx1ZSwgbGlzdD4+XSxcbiAgb3JWYWx1ZVxuPlxuXG5leHBvcnQgdHlwZSBHZXRMYXN0VmFsdWU8VCBleHRlbmRzIHJlYWRvbmx5IFthbnksIC4uLmFueVtdXT4gPSBUW01pbnVzT25lVXBUb1RlbjxUWydsZW5ndGgnXT5dXG5cbmV4cG9ydCB0eXBlIElzTGFzdFZhbHVlPHZhbHVlLCBsaXN0IGV4dGVuZHMgcmVhZG9ubHkgW2FueSwgLi4uYW55W11dPiA9IHZhbHVlIGV4dGVuZHMgR2V0TGFzdFZhbHVlPGxpc3Q+ID8gdHJ1ZSA6IGZhbHNlXG5cbmV4cG9ydCB0eXBlIEluY2x1ZGU8VCwgVT4gPSBUIGV4dGVuZHMgVSA/IFQgOiBuZXZlclxuXG5leHBvcnQgY29uc3QgcGFydGl0aW9uRXJyb3JzID0gPFQ+KGFycmF5OiBUW10pOiBbRXhjbHVkZTxULCBFcnJvcj5bXSwgSW5jbHVkZTxULCBFcnJvcj5bXV0gPT4ge1xuICBjb25zdCBlcnJvcnM6IEluY2x1ZGU8VCwgRXJyb3I+W10gPSBbXVxuICBjb25zdCB2YWx1ZXM6IEV4Y2x1ZGU8VCwgRXJyb3I+W10gPSBbXVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlcnJvcnMucHVzaChpdGVtIGFzIGFueSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzLnB1c2goaXRlbSBhcyBhbnkpXG4gICAgfVxuICB9XG4gIHJldHVybiBbdmFsdWVzLCBlcnJvcnNdXG59XG4iLCAiaW1wb3J0IHsgR3JhcGhRTENsaWVudCB9IGZyb20gJy4uL2NsYXNzZXMvR3JhcGhRTENsaWVudC5qcydcbmltcG9ydCB0eXBlIHsgUmVxdWVzdERvY3VtZW50LCBWYXJpYWJsZXMgfSBmcm9tICcuLi9oZWxwZXJzL3R5cGVzLmpzJ1xuXG5leHBvcnQgdHlwZSBCYXRjaFJlcXVlc3REb2N1bWVudDxWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPiA9IHtcbiAgZG9jdW1lbnQ6IFJlcXVlc3REb2N1bWVudFxuICB2YXJpYWJsZXM/OiBWXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hSZXF1ZXN0c09wdGlvbnM8ViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4ge1xuICBkb2N1bWVudHM6IEJhdGNoUmVxdWVzdERvY3VtZW50PFY+W11cbiAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdFxuICBzaWduYWw/OiBSZXF1ZXN0SW5pdFsnc2lnbmFsJ11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaFJlcXVlc3RzRXh0ZW5kZWRPcHRpb25zPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+IGV4dGVuZHMgQmF0Y2hSZXF1ZXN0c09wdGlvbnM8Vj4ge1xuICB1cmw6IHN0cmluZ1xufVxuXG4vKipcbiAqIFNlbmQgYSBiYXRjaCBvZiBHcmFwaFFMIERvY3VtZW50IHRvIHRoZSBHcmFwaFFMIHNlcnZlciBmb3IgZXhlY3V0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIC8vIFlvdSBjYW4gcGFzcyBhIHJhdyBzdHJpbmdcbiAqXG4gKiBhd2FpdCBiYXRjaFJlcXVlc3RzKCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIFtcbiAqIHtcbiAqICBxdWVyeTogYFxuICogICB7XG4gKiAgICAgcXVlcnkge1xuICogICAgICAgdXNlcnNcbiAqICAgICB9XG4gKiAgIH1gXG4gKiB9LFxuICoge1xuICogICBxdWVyeTogYFxuICogICB7XG4gKiAgICAgcXVlcnkge1xuICogICAgICAgdXNlcnNcbiAqICAgICB9XG4gKiAgIH1gXG4gKiB9XSlcbiAqXG4gKiAvLyBZb3UgY2FuIGFsc28gcGFzcyBhIEdyYXBoUUwgRG9jdW1lbnROb2RlIGFzIHF1ZXJ5LiBDb252ZW5pZW50IGlmIHlvdVxuICogLy8gYXJlIHVzaW5nIGdyYXBocWwtdGFnIHBhY2thZ2UuXG4gKlxuICogaW1wb3J0IGdxbCBmcm9tICdncmFwaHFsLXRhZydcbiAqXG4gKiBhd2FpdCBiYXRjaFJlcXVlc3RzKCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIFt7IHF1ZXJ5OiBncWxgLi4uYCB9XSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmF0Y2hSZXF1ZXN0czogQmF0Y2hSZXF1ZXN0cyA9IGFzeW5jICguLi5hcmdzOiBCYXRjaFJlcXVlc3RzQXJncykgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBwYXJzZUJhdGNoUmVxdWVzdHNBcmdzRXh0ZW5kZWQoYXJncylcbiAgY29uc3QgY2xpZW50ID0gbmV3IEdyYXBoUUxDbGllbnQocGFyYW1zLnVybClcbiAgcmV0dXJuIGNsaWVudC5iYXRjaFJlcXVlc3RzKHBhcmFtcylcbn1cblxudHlwZSBCYXRjaFJlcXVlc3RzQXJncyA9XG4gIHwgW3VybDogc3RyaW5nLCBkb2N1bWVudHM6IEJhdGNoUmVxdWVzdERvY3VtZW50W10sIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXRdXG4gIHwgW29wdGlvbnM6IEJhdGNoUmVxdWVzdHNFeHRlbmRlZE9wdGlvbnNdXG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoUmVxdWVzdHNBcmdzRXh0ZW5kZWQgPSAoYXJnczogQmF0Y2hSZXF1ZXN0c0FyZ3MpOiBCYXRjaFJlcXVlc3RzRXh0ZW5kZWRPcHRpb25zID0+IHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGFyZ3NbMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBhcmdzWzBdLFxuICAgICAgZG9jdW1lbnRzOiBhcmdzWzFdLFxuICAgICAgcmVxdWVzdEhlYWRlcnM6IGFyZ3NbMl0sXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH1cbn1cblxuLy8gZHByaW50LWlnbm9yZVxuaW50ZXJmYWNlIEJhdGNoUmVxdWVzdHMge1xuICA8VCBleHRlbmRzIEJhdGNoUmVzdWx0LCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPih1cmw6IHN0cmluZywgZG9jdW1lbnRzOiBCYXRjaFJlcXVlc3REb2N1bWVudDxWPltdLCByZXF1ZXN0SGVhZGVycz86IEhlYWRlcnNJbml0KTogUHJvbWlzZTxUPlxuICA8VCBleHRlbmRzIEJhdGNoUmVzdWx0LCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihvcHRpb25zOiBCYXRjaFJlcXVlc3RzRXh0ZW5kZWRPcHRpb25zPFY+KTogUHJvbWlzZTxUPlxufVxuXG5leHBvcnQgdHlwZSBCYXRjaFJlc3VsdCA9IFtSZXN1bHQsIC4uLlJlc3VsdFtdXVxuXG5pbnRlcmZhY2UgUmVzdWx0PERhdGEgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3Q+IHtcbiAgZGF0YTogRGF0YVxufVxuXG5leHBvcnQgY29uc3QgcGFyc2VCYXRjaFJlcXVlc3RBcmdzID0gPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICBkb2N1bWVudHNPck9wdGlvbnM6IEJhdGNoUmVxdWVzdERvY3VtZW50PFY+W10gfCBCYXRjaFJlcXVlc3RzT3B0aW9uczxWPixcbiAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdCxcbik6IEJhdGNoUmVxdWVzdHNPcHRpb25zPFY+ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHJldHVybiAoZG9jdW1lbnRzT3JPcHRpb25zIGFzIEJhdGNoUmVxdWVzdHNPcHRpb25zPFY+KS5kb2N1bWVudHNcbiAgICA/IChkb2N1bWVudHNPck9wdGlvbnMgYXMgQmF0Y2hSZXF1ZXN0c09wdGlvbnM8Vj4pXG4gICAgOiB7XG4gICAgICBkb2N1bWVudHM6IGRvY3VtZW50c09yT3B0aW9ucyBhcyBCYXRjaFJlcXVlc3REb2N1bWVudDxWPltdLFxuICAgICAgcmVxdWVzdEhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgc2lnbmFsOiB1bmRlZmluZWQsXG4gICAgfVxufVxuIiwgImltcG9ydCB7IEdyYXBoUUxDbGllbnQgfSBmcm9tICcuLi9jbGFzc2VzL0dyYXBoUUxDbGllbnQuanMnXG5pbXBvcnQgdHlwZSB7XG4gIEdyYXBoUUxDbGllbnRSZXNwb25zZSxcbiAgUmF3UmVxdWVzdE9wdGlvbnMsXG4gIFZhcmlhYmxlcyxcbiAgVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzLFxufSBmcm9tICcuLi9oZWxwZXJzL3R5cGVzLmpzJ1xuXG4vKipcbiAqIFNlbmQgYSBHcmFwaFFMIFF1ZXJ5IHRvIHRoZSBHcmFwaFFMIHNlcnZlciBmb3IgZXhlY3V0aW9uLlxuICovXG5leHBvcnQgY29uc3QgcmF3UmVxdWVzdDogUmF3UmVxdWVzdCA9IGFzeW5jIDxULCBWIGV4dGVuZHMgVmFyaWFibGVzPihcbiAgLi4uYXJnczogUmF3UmVxdWVzdEFyZ3M8Vj5cbik6IFByb21pc2U8R3JhcGhRTENsaWVudFJlc3BvbnNlPFQ+PiA9PiB7XG4gIGNvbnN0IFt1cmxPck9wdGlvbnMsIHF1ZXJ5LCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc10gPSBhcmdzXG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gcGFyc2VSYXdSZXF1ZXN0RXh0ZW5kZWRBcmdzPFY+KHVybE9yT3B0aW9ucywgcXVlcnksIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzKVxuICBjb25zdCBjbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudChyZXF1ZXN0T3B0aW9ucy51cmwpXG4gIHJldHVybiBjbGllbnQucmF3UmVxdWVzdDxULCBWPih7XG4gICAgLi4ucmVxdWVzdE9wdGlvbnMsXG4gIH0pXG59XG5cbi8vIGRwcmludC1pZ25vcmVcbmludGVyZmFjZSBSYXdSZXF1ZXN0IHtcbiAgPFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KHVybDogc3RyaW5nLCBxdWVyeTogc3RyaW5nLCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+KTogUHJvbWlzZTxHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD4+XG4gIDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihvcHRpb25zOiBSYXdSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+KTogUHJvbWlzZTxHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD4+XG59XG5cbi8vIGRwcmludC1pZ25vcmVcbnR5cGUgUmF3UmVxdWVzdEFyZ3M8ViBleHRlbmRzIFZhcmlhYmxlcz4gPSBcbiAgfCBbb3B0aW9uczogUmF3UmVxdWVzdEV4dGVuZGVkT3B0aW9uczxWPiwgcXVlcnk/OiBzdHJpbmcsIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzOiBWYXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc0FyZ3M8Vj5dXG4gIHwgW3VybDogc3RyaW5nLCAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Pzogc3RyaW5nLCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+XVxuXG5leHBvcnQgY29uc3QgcGFyc2VSYXdSZXF1ZXN0RXh0ZW5kZWRBcmdzID0gPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICB1cmxPck9wdGlvbnM6IHN0cmluZyB8IFJhd1JlcXVlc3RFeHRlbmRlZE9wdGlvbnM8Vj4sXG4gIHF1ZXJ5Pzogc3RyaW5nLFxuICAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+XG4pOiBSYXdSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+ID0+IHtcbiAgY29uc3QgW3ZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnNdID0gdmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNcbiAgcmV0dXJuIHR5cGVvZiB1cmxPck9wdGlvbnMgPT09IGBzdHJpbmdgXG4gICAgPyAoe1xuICAgICAgdXJsOiB1cmxPck9wdGlvbnMsXG4gICAgICBxdWVyeTogcXVlcnkgYXMgc3RyaW5nLFxuICAgICAgdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnMsXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9IGFzIHVua25vd24gYXMgUmF3UmVxdWVzdEV4dGVuZGVkT3B0aW9uczxWPilcbiAgICA6IHVybE9yT3B0aW9uc1xufVxuXG5leHBvcnQgdHlwZSBSYXdSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+ID0ge1xuICB1cmw6IHN0cmluZ1xufSAmIFJhd1JlcXVlc3RPcHRpb25zPFY+XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJhd1JlcXVlc3RBcmdzID0gPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICBxdWVyeU9yT3B0aW9uczogc3RyaW5nIHwgUmF3UmVxdWVzdE9wdGlvbnM8Vj4sXG4gIHZhcmlhYmxlcz86IFYsXG4gIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXQsXG4pOiBSYXdSZXF1ZXN0T3B0aW9uczxWPiA9PiB7XG4gIHJldHVybiAocXVlcnlPck9wdGlvbnMgYXMgUmF3UmVxdWVzdE9wdGlvbnM8Vj4pLnF1ZXJ5XG4gICAgPyAocXVlcnlPck9wdGlvbnMgYXMgUmF3UmVxdWVzdE9wdGlvbnM8Vj4pXG4gICAgOiAoe1xuICAgICAgcXVlcnk6IHF1ZXJ5T3JPcHRpb25zIGFzIHN0cmluZyxcbiAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgc2lnbmFsOiB1bmRlZmluZWQsXG4gICAgfSBhcyB1bmtub3duIGFzIFJhd1JlcXVlc3RPcHRpb25zPFY+KVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBkZXZBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGJvb2xlYW5Db25kaXRpb24gPSBCb29sZWFuKGNvbmRpdGlvbik7XG5cbiAgaWYgKCFib29sZWFuQ29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90XG4gKiBgbnVsbGAgYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgY29uc3QgYm9vbGVhbkNvbmRpdGlvbiA9IEJvb2xlYW4oY29uZGl0aW9uKTtcblxuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogJ1VuZXhwZWN0ZWQgaW52YXJpYW50IHRyaWdnZXJlZC4nLFxuICAgICk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICcuLi9qc3V0aWxzL2ludmFyaWFudC5tanMnO1xuY29uc3QgTGluZVJlZ0V4cCA9IC9cXHJcXG58W1xcblxccl0vZztcbi8qKlxuICogUmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgU291cmNlLlxuICovXG5cbi8qKlxuICogVGFrZXMgYSBTb3VyY2UgYW5kIGEgVVRGLTggY2hhcmFjdGVyIG9mZnNldCwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGxpbmUgYW5kIGNvbHVtbiBhcyBhIFNvdXJjZUxvY2F0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb24oc291cmNlLCBwb3NpdGlvbikge1xuICBsZXQgbGFzdExpbmVTdGFydCA9IDA7XG4gIGxldCBsaW5lID0gMTtcblxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIHNvdXJjZS5ib2R5Lm1hdGNoQWxsKExpbmVSZWdFeHApKSB7XG4gICAgdHlwZW9mIG1hdGNoLmluZGV4ID09PSAnbnVtYmVyJyB8fCBpbnZhcmlhbnQoZmFsc2UpO1xuXG4gICAgaWYgKG1hdGNoLmluZGV4ID49IHBvc2l0aW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsYXN0TGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgbGluZSArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbjogcG9zaXRpb24gKyAxIC0gbGFzdExpbmVTdGFydCxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBnZXRMb2NhdGlvbiB9IGZyb20gJy4vbG9jYXRpb24ubWpzJztcblxuLyoqXG4gKiBSZW5kZXIgYSBoZWxwZnVsIGRlc2NyaXB0aW9uIG9mIHRoZSBsb2NhdGlvbiBpbiB0aGUgR3JhcGhRTCBTb3VyY2UgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBwcmludFNvdXJjZUxvY2F0aW9uKFxuICAgIGxvY2F0aW9uLnNvdXJjZSxcbiAgICBnZXRMb2NhdGlvbihsb2NhdGlvbi5zb3VyY2UsIGxvY2F0aW9uLnN0YXJ0KSxcbiAgKTtcbn1cbi8qKlxuICogUmVuZGVyIGEgaGVscGZ1bCBkZXNjcmlwdGlvbiBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIEdyYXBoUUwgU291cmNlIGRvY3VtZW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgc291cmNlTG9jYXRpb24pIHtcbiAgY29uc3QgZmlyc3RMaW5lQ29sdW1uT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbiAtIDE7XG4gIGNvbnN0IGJvZHkgPSAnJy5wYWRTdGFydChmaXJzdExpbmVDb2x1bW5PZmZzZXQpICsgc291cmNlLmJvZHk7XG4gIGNvbnN0IGxpbmVJbmRleCA9IHNvdXJjZUxvY2F0aW9uLmxpbmUgLSAxO1xuICBjb25zdCBsaW5lT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmxpbmUgLSAxO1xuICBjb25zdCBsaW5lTnVtID0gc291cmNlTG9jYXRpb24ubGluZSArIGxpbmVPZmZzZXQ7XG4gIGNvbnN0IGNvbHVtbk9mZnNldCA9IHNvdXJjZUxvY2F0aW9uLmxpbmUgPT09IDEgPyBmaXJzdExpbmVDb2x1bW5PZmZzZXQgOiAwO1xuICBjb25zdCBjb2x1bW5OdW0gPSBzb3VyY2VMb2NhdGlvbi5jb2x1bW4gKyBjb2x1bW5PZmZzZXQ7XG4gIGNvbnN0IGxvY2F0aW9uU3RyID0gYCR7c291cmNlLm5hbWV9OiR7bGluZU51bX06JHtjb2x1bW5OdW19XFxuYDtcbiAgY29uc3QgbGluZXMgPSBib2R5LnNwbGl0KC9cXHJcXG58W1xcblxccl0vZyk7XG4gIGNvbnN0IGxvY2F0aW9uTGluZSA9IGxpbmVzW2xpbmVJbmRleF07IC8vIFNwZWNpYWwgY2FzZSBmb3IgbWluaWZpZWQgZG9jdW1lbnRzXG5cbiAgaWYgKGxvY2F0aW9uTGluZS5sZW5ndGggPiAxMjApIHtcbiAgICBjb25zdCBzdWJMaW5lSW5kZXggPSBNYXRoLmZsb29yKGNvbHVtbk51bSAvIDgwKTtcbiAgICBjb25zdCBzdWJMaW5lQ29sdW1uTnVtID0gY29sdW1uTnVtICUgODA7XG4gICAgY29uc3Qgc3ViTGluZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25MaW5lLmxlbmd0aDsgaSArPSA4MCkge1xuICAgICAgc3ViTGluZXMucHVzaChsb2NhdGlvbkxpbmUuc2xpY2UoaSwgaSArIDgwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGxvY2F0aW9uU3RyICtcbiAgICAgIHByaW50UHJlZml4ZWRMaW5lcyhbXG4gICAgICAgIFtgJHtsaW5lTnVtfSB8YCwgc3ViTGluZXNbMF1dLFxuICAgICAgICAuLi5zdWJMaW5lcy5zbGljZSgxLCBzdWJMaW5lSW5kZXggKyAxKS5tYXAoKHN1YkxpbmUpID0+IFsnfCcsIHN1YkxpbmVdKSxcbiAgICAgICAgWyd8JywgJ14nLnBhZFN0YXJ0KHN1YkxpbmVDb2x1bW5OdW0pXSxcbiAgICAgICAgWyd8Jywgc3ViTGluZXNbc3ViTGluZUluZGV4ICsgMV1dLFxuICAgICAgXSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBsb2NhdGlvblN0ciArXG4gICAgcHJpbnRQcmVmaXhlZExpbmVzKFtcbiAgICAgIC8vIExpbmVzIHNwZWNpZmllZCBsaWtlIHRoaXM6IFtcInByZWZpeFwiLCBcInN0cmluZ1wiXSxcbiAgICAgIFtgJHtsaW5lTnVtIC0gMX0gfGAsIGxpbmVzW2xpbmVJbmRleCAtIDFdXSxcbiAgICAgIFtgJHtsaW5lTnVtfSB8YCwgbG9jYXRpb25MaW5lXSxcbiAgICAgIFsnfCcsICdeJy5wYWRTdGFydChjb2x1bW5OdW0pXSxcbiAgICAgIFtgJHtsaW5lTnVtICsgMX0gfGAsIGxpbmVzW2xpbmVJbmRleCArIDFdXSxcbiAgICBdKVxuICApO1xufVxuXG5mdW5jdGlvbiBwcmludFByZWZpeGVkTGluZXMobGluZXMpIHtcbiAgY29uc3QgZXhpc3RpbmdMaW5lcyA9IGxpbmVzLmZpbHRlcigoW18sIGxpbmVdKSA9PiBsaW5lICE9PSB1bmRlZmluZWQpO1xuICBjb25zdCBwYWRMZW4gPSBNYXRoLm1heCguLi5leGlzdGluZ0xpbmVzLm1hcCgoW3ByZWZpeF0pID0+IHByZWZpeC5sZW5ndGgpKTtcbiAgcmV0dXJuIGV4aXN0aW5nTGluZXNcbiAgICAubWFwKChbcHJlZml4LCBsaW5lXSkgPT4gcHJlZml4LnBhZFN0YXJ0KHBhZExlbikgKyAobGluZSA/ICcgJyArIGxpbmUgOiAnJykpXG4gICAgLmpvaW4oJ1xcbicpO1xufVxuIiwgImltcG9ydCB7IGlzT2JqZWN0TGlrZSB9IGZyb20gJy4uL2pzdXRpbHMvaXNPYmplY3RMaWtlLm1qcyc7XG5pbXBvcnQgeyBnZXRMb2NhdGlvbiB9IGZyb20gJy4uL2xhbmd1YWdlL2xvY2F0aW9uLm1qcyc7XG5pbXBvcnQge1xuICBwcmludExvY2F0aW9uLFxuICBwcmludFNvdXJjZUxvY2F0aW9uLFxufSBmcm9tICcuLi9sYW5ndWFnZS9wcmludExvY2F0aW9uLm1qcyc7XG5cbmZ1bmN0aW9uIHRvTm9ybWFsaXplZE9wdGlvbnMoYXJncykge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG5cbiAgaWYgKGZpcnN0QXJnID09IG51bGwgfHwgJ2tpbmQnIGluIGZpcnN0QXJnIHx8ICdsZW5ndGgnIGluIGZpcnN0QXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVzOiBmaXJzdEFyZyxcbiAgICAgIHNvdXJjZTogYXJnc1sxXSxcbiAgICAgIHBvc2l0aW9uczogYXJnc1syXSxcbiAgICAgIHBhdGg6IGFyZ3NbM10sXG4gICAgICBvcmlnaW5hbEVycm9yOiBhcmdzWzRdLFxuICAgICAgZXh0ZW5zaW9uczogYXJnc1s1XSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpcnN0QXJnO1xufVxuLyoqXG4gKiBBIEdyYXBoUUxFcnJvciBkZXNjcmliZXMgYW4gRXJyb3IgZm91bmQgZHVyaW5nIHRoZSBwYXJzZSwgdmFsaWRhdGUsIG9yXG4gKiBleGVjdXRlIHBoYXNlcyBvZiBwZXJmb3JtaW5nIGEgR3JhcGhRTCBvcGVyYXRpb24uIEluIGFkZGl0aW9uIHRvIGEgbWVzc2FnZVxuICogYW5kIHN0YWNrIHRyYWNlLCBpdCBhbHNvIGluY2x1ZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2NhdGlvbnMgaW4gYVxuICogR3JhcGhRTCBkb2N1bWVudCBhbmQvb3IgZXhlY3V0aW9uIHJlc3VsdCB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIEVycm9yLlxuICovXG5cbmV4cG9ydCBjbGFzcyBHcmFwaFFMRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBgeyBsaW5lLCBjb2x1bW4gfWAgbG9jYXRpb25zIHdpdGhpbiB0aGUgc291cmNlIEdyYXBoUUwgZG9jdW1lbnRcbiAgICogd2hpY2ggY29ycmVzcG9uZCB0byB0aGlzIGVycm9yLlxuICAgKlxuICAgKiBFcnJvcnMgZHVyaW5nIHZhbGlkYXRpb24gb2Z0ZW4gY29udGFpbiBtdWx0aXBsZSBsb2NhdGlvbnMsIGZvciBleGFtcGxlIHRvXG4gICAqIHBvaW50IG91dCB0d28gdGhpbmdzIHdpdGggdGhlIHNhbWUgbmFtZS4gRXJyb3JzIGR1cmluZyBleGVjdXRpb24gaW5jbHVkZSBhXG4gICAqIHNpbmdsZSBsb2NhdGlvbiwgdGhlIGZpZWxkIHdoaWNoIHByb2R1Y2VkIHRoZSBlcnJvci5cbiAgICpcbiAgICogRW51bWVyYWJsZSwgYW5kIGFwcGVhcnMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAgKi9cblxuICAvKipcbiAgICogQW4gYXJyYXkgZGVzY3JpYmluZyB0aGUgSlNPTi1wYXRoIGludG8gdGhlIGV4ZWN1dGlvbiByZXNwb25zZSB3aGljaFxuICAgKiBjb3JyZXNwb25kcyB0byB0aGlzIGVycm9yLiBPbmx5IGluY2x1ZGVkIGZvciBlcnJvcnMgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogRW51bWVyYWJsZSwgYW5kIGFwcGVhcnMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAgKi9cblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgR3JhcGhRTCBBU1QgTm9kZXMgY29ycmVzcG9uZGluZyB0byB0aGlzIGVycm9yLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIHNvdXJjZSBHcmFwaFFMIGRvY3VtZW50IGZvciB0aGUgZmlyc3QgbG9jYXRpb24gb2YgdGhpcyBlcnJvci5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHRoaXMgRXJyb3IgcmVwcmVzZW50cyBtb3JlIHRoYW4gb25lIG5vZGUsIHRoZSBzb3VyY2UgbWF5IG5vdFxuICAgKiByZXByZXNlbnQgbm9kZXMgYWZ0ZXIgdGhlIGZpcnN0IG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXIgb2Zmc2V0cyB3aXRoaW4gdGhlIHNvdXJjZSBHcmFwaFFMIGRvY3VtZW50XG4gICAqIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhpcyBlcnJvci5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBlcnJvciB0aHJvd24gZnJvbSBhIGZpZWxkIHJlc29sdmVyIGR1cmluZyBleGVjdXRpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gZmllbGRzIHRvIGFkZCB0byB0aGUgZm9ybWF0dGVkIGVycm9yLlxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSB0aGUgYEdyYXBoUUxFcnJvck9wdGlvbnNgIGNvbnN0cnVjdG9yIG92ZXJsb2FkIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCAuLi5yYXdBcmdzKSB7XG4gICAgdmFyIF90aGlzJG5vZGVzLCBfbm9kZUxvY2F0aW9ucyQsIF9yZWY7XG5cbiAgICBjb25zdCB7IG5vZGVzLCBzb3VyY2UsIHBvc2l0aW9ucywgcGF0aCwgb3JpZ2luYWxFcnJvciwgZXh0ZW5zaW9ucyB9ID1cbiAgICAgIHRvTm9ybWFsaXplZE9wdGlvbnMocmF3QXJncyk7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0dyYXBoUUxFcnJvcic7XG4gICAgdGhpcy5wYXRoID0gcGF0aCAhPT0gbnVsbCAmJiBwYXRoICE9PSB2b2lkIDAgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9XG4gICAgICBvcmlnaW5hbEVycm9yICE9PSBudWxsICYmIG9yaWdpbmFsRXJyb3IgIT09IHZvaWQgMFxuICAgICAgICA/IG9yaWdpbmFsRXJyb3JcbiAgICAgICAgOiB1bmRlZmluZWQ7IC8vIENvbXB1dGUgbGlzdCBvZiBibGFtZSBub2Rlcy5cblxuICAgIHRoaXMubm9kZXMgPSB1bmRlZmluZWRJZkVtcHR5KFxuICAgICAgQXJyYXkuaXNBcnJheShub2RlcykgPyBub2RlcyA6IG5vZGVzID8gW25vZGVzXSA6IHVuZGVmaW5lZCxcbiAgICApO1xuICAgIGNvbnN0IG5vZGVMb2NhdGlvbnMgPSB1bmRlZmluZWRJZkVtcHR5KFxuICAgICAgKF90aGlzJG5vZGVzID0gdGhpcy5ub2RlcykgPT09IG51bGwgfHwgX3RoaXMkbm9kZXMgPT09IHZvaWQgMFxuICAgICAgICA/IHZvaWQgMFxuICAgICAgICA6IF90aGlzJG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5sb2MpLmZpbHRlcigobG9jKSA9PiBsb2MgIT0gbnVsbCksXG4gICAgKTsgLy8gQ29tcHV0ZSBsb2NhdGlvbnMgaW4gdGhlIHNvdXJjZSBmb3IgdGhlIGdpdmVuIG5vZGVzL3Bvc2l0aW9ucy5cblxuICAgIHRoaXMuc291cmNlID1cbiAgICAgIHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UgIT09IHZvaWQgMFxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IG5vZGVMb2NhdGlvbnMgPT09IG51bGwgfHwgbm9kZUxvY2F0aW9ucyA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogKF9ub2RlTG9jYXRpb25zJCA9IG5vZGVMb2NhdGlvbnNbMF0pID09PSBudWxsIHx8XG4gICAgICAgICAgX25vZGVMb2NhdGlvbnMkID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBfbm9kZUxvY2F0aW9ucyQuc291cmNlO1xuICAgIHRoaXMucG9zaXRpb25zID1cbiAgICAgIHBvc2l0aW9ucyAhPT0gbnVsbCAmJiBwb3NpdGlvbnMgIT09IHZvaWQgMFxuICAgICAgICA/IHBvc2l0aW9uc1xuICAgICAgICA6IG5vZGVMb2NhdGlvbnMgPT09IG51bGwgfHwgbm9kZUxvY2F0aW9ucyA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogbm9kZUxvY2F0aW9ucy5tYXAoKGxvYykgPT4gbG9jLnN0YXJ0KTtcbiAgICB0aGlzLmxvY2F0aW9ucyA9XG4gICAgICBwb3NpdGlvbnMgJiYgc291cmNlXG4gICAgICAgID8gcG9zaXRpb25zLm1hcCgocG9zKSA9PiBnZXRMb2NhdGlvbihzb3VyY2UsIHBvcykpXG4gICAgICAgIDogbm9kZUxvY2F0aW9ucyA9PT0gbnVsbCB8fCBub2RlTG9jYXRpb25zID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBub2RlTG9jYXRpb25zLm1hcCgobG9jKSA9PiBnZXRMb2NhdGlvbihsb2Muc291cmNlLCBsb2Muc3RhcnQpKTtcbiAgICBjb25zdCBvcmlnaW5hbEV4dGVuc2lvbnMgPSBpc09iamVjdExpa2UoXG4gICAgICBvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMFxuICAgICAgICA/IHZvaWQgMFxuICAgICAgICA6IG9yaWdpbmFsRXJyb3IuZXh0ZW5zaW9ucyxcbiAgICApXG4gICAgICA/IG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwXG4gICAgICAgID8gdm9pZCAwXG4gICAgICAgIDogb3JpZ2luYWxFcnJvci5leHRlbnNpb25zXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPVxuICAgICAgKF9yZWYgPVxuICAgICAgICBleHRlbnNpb25zICE9PSBudWxsICYmIGV4dGVuc2lvbnMgIT09IHZvaWQgMFxuICAgICAgICAgID8gZXh0ZW5zaW9uc1xuICAgICAgICAgIDogb3JpZ2luYWxFeHRlbnNpb25zKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDBcbiAgICAgICAgPyBfcmVmXG4gICAgICAgIDogT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gT25seSBwcm9wZXJ0aWVzIHByZXNjcmliZWQgYnkgdGhlIHNwZWMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG4gICAgLy8gS2VlcCB0aGUgcmVzdCBhcyBub24tZW51bWVyYWJsZS5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB9LFxuICAgICAgbmFtZToge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBub2Rlczoge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIG9yaWdpbmFsRXJyb3I6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pOyAvLyBJbmNsdWRlIChub24tZW51bWVyYWJsZSkgc3RhY2sgdHJhY2UuXG5cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAvLyBGSVhNRTogaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxN1xuXG4gICAgaWYgKFxuICAgICAgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJlxuICAgICAgb3JpZ2luYWxFcnJvciAhPT0gdm9pZCAwICYmXG4gICAgICBvcmlnaW5hbEVycm9yLnN0YWNrXG4gICAgKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICB2YWx1ZTogb3JpZ2luYWxFcnJvci5zdGFjayxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEdyYXBoUUxFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgIHZhbHVlOiBFcnJvcigpLnN0YWNrLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdHcmFwaFFMRXJyb3InO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IG91dHB1dCA9IHRoaXMubWVzc2FnZTtcblxuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5sb2MpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gJ1xcblxcbicgKyBwcmludExvY2F0aW9uKG5vZGUubG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgbG9jYXRpb24gb2YgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgICAgb3V0cHV0ICs9ICdcXG5cXG4nICsgcHJpbnRTb3VyY2VMb2NhdGlvbih0aGlzLnNvdXJjZSwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkRXJyb3IgPSB7XG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmxvY2F0aW9ucyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXR0ZWRFcnJvci5sb2NhdGlvbnMgPSB0aGlzLmxvY2F0aW9ucztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRoICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdHRlZEVycm9yLnBhdGggPSB0aGlzLnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9ucyAhPSBudWxsICYmIE9iamVjdC5rZXlzKHRoaXMuZXh0ZW5zaW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgZm9ybWF0dGVkRXJyb3IuZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkRXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5kZWZpbmVkSWZFbXB0eShhcnJheSkge1xuICByZXR1cm4gYXJyYXkgPT09IHVuZGVmaW5lZCB8fCBhcnJheS5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBhcnJheTtcbn1cbi8qKlxuICogU2VlOiBodHRwczovL3NwZWMuZ3JhcGhxbC5vcmcvZHJhZnQvI3NlYy1FcnJvcnNcbiAqL1xuXG4vKipcbiAqIFByaW50cyBhIEdyYXBoUUxFcnJvciB0byBhIHN0cmluZywgcmVwcmVzZW50aW5nIHVzZWZ1bCBsb2NhdGlvbiBpbmZvcm1hdGlvblxuICogYWJvdXQgdGhlIGVycm9yJ3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBlcnJvci50b1N0cmluZ2AgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIHYxN1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBHcmFwaFFMRXJyb3IsIGZvcm1hdCBpdCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlc2NyaWJlZCBieSB0aGVcbiAqIFJlc3BvbnNlIEZvcm1hdCwgRXJyb3JzIHNlY3Rpb24gb2YgdGhlIEdyYXBoUUwgU3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBlcnJvci50b0pTT05gIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MTdcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yLnRvSlNPTigpO1xufVxuIiwgImltcG9ydCB7IEdyYXBoUUxFcnJvciB9IGZyb20gJy4vR3JhcGhRTEVycm9yLm1qcyc7XG4vKipcbiAqIFByb2R1Y2VzIGEgR3JhcGhRTEVycm9yIHJlcHJlc2VudGluZyBhIHN5bnRheCBlcnJvciwgY29udGFpbmluZyB1c2VmdWxcbiAqIGRlc2NyaXB0aXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzeW50YXggZXJyb3IncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBkZXNjcmlwdGlvbikge1xuICByZXR1cm4gbmV3IEdyYXBoUUxFcnJvcihgU3ludGF4IEVycm9yOiAke2Rlc2NyaXB0aW9ufWAsIHtcbiAgICBzb3VyY2UsXG4gICAgcG9zaXRpb25zOiBbcG9zaXRpb25dLFxuICB9KTtcbn1cbiIsICIvKipcbiAqIENvbnRhaW5zIGEgcmFuZ2Ugb2YgVVRGLTggY2hhcmFjdGVyIG9mZnNldHMgYW5kIHRva2VuIHJlZmVyZW5jZXMgdGhhdFxuICogaWRlbnRpZnkgdGhlIHJlZ2lvbiBvZiB0aGUgc291cmNlIGZyb20gd2hpY2ggdGhlIEFTVCBkZXJpdmVkLlxuICovXG5leHBvcnQgY2xhc3MgTG9jYXRpb24ge1xuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIFRva2VuIGF0IHdoaWNoIHRoaXMgTm9kZSBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgU291cmNlIGRvY3VtZW50IHRoZSBBU1QgcmVwcmVzZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRUb2tlbi5zdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZFRva2VuLmVuZDtcbiAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgIHRoaXMuZW5kVG9rZW4gPSBlbmRUb2tlbjtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kLFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHJhbmdlIG9mIGNoYXJhY3RlcnMgcmVwcmVzZW50ZWQgYnkgYSBsZXhpY2FsIHRva2VuXG4gKiB3aXRoaW4gYSBTb3VyY2UuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRva2VuIHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIFRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIDEtaW5kZXhlZCBsaW5lIG51bWJlciBvbiB3aGljaCB0aGlzIFRva2VuIGFwcGVhcnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgMS1pbmRleGVkIGNvbHVtbiBudW1iZXIgYXQgd2hpY2ggdGhpcyBUb2tlbiBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGb3Igbm9uLXB1bmN0dWF0aW9uIHRva2VucywgcmVwcmVzZW50cyB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgKlxuICAgKiBOb3RlOiBpcyB1bmRlZmluZWQgZm9yIHB1bmN0dWF0aW9uIHRva2VucywgYnV0IHR5cGVkIGFzIHN0cmluZyBmb3JcbiAgICogY29udmVuaWVuY2UgaW4gdGhlIHBhcnNlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRva2VucyBleGlzdCBhcyBub2RlcyBpbiBhIGRvdWJsZS1saW5rZWQtbGlzdCBhbW9uZ3N0IGFsbCB0b2tlbnNcbiAgICogaW5jbHVkaW5nIGlnbm9yZWQgdG9rZW5zLiA8U09GPiBpcyBhbHdheXMgdGhlIGZpcnN0IG5vZGUgYW5kIDxFT0Y+XG4gICAqIHRoZSBsYXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2luZCwgc3RhcnQsIGVuZCwgbGluZSwgY29sdW1uLCB2YWx1ZSkge1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnVG9rZW4nO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgbGlzdCBvZiBhbGwgcG9zc2libGUgQVNUIG5vZGUgdHlwZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFF1ZXJ5RG9jdW1lbnRLZXlzID0ge1xuICBOYW1lOiBbXSxcbiAgRG9jdW1lbnQ6IFsnZGVmaW5pdGlvbnMnXSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjogW1xuICAgICduYW1lJyxcbiAgICAndmFyaWFibGVEZWZpbml0aW9ucycsXG4gICAgJ2RpcmVjdGl2ZXMnLFxuICAgICdzZWxlY3Rpb25TZXQnLFxuICBdLFxuICBWYXJpYWJsZURlZmluaXRpb246IFsndmFyaWFibGUnLCAndHlwZScsICdkZWZhdWx0VmFsdWUnLCAnZGlyZWN0aXZlcyddLFxuICBWYXJpYWJsZTogWyduYW1lJ10sXG4gIFNlbGVjdGlvblNldDogWydzZWxlY3Rpb25zJ10sXG4gIEZpZWxkOiBbJ2FsaWFzJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEFyZ3VtZW50OiBbJ25hbWUnLCAndmFsdWUnXSxcbiAgRnJhZ21lbnRTcHJlYWQ6IFsnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElubGluZUZyYWdtZW50OiBbJ3R5cGVDb25kaXRpb24nLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgRnJhZ21lbnREZWZpbml0aW9uOiBbXG4gICAgJ25hbWUnLCAvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCByZW1vdmVkIGluIHYxNy4wLjBcbiAgICAndmFyaWFibGVEZWZpbml0aW9ucycsXG4gICAgJ3R5cGVDb25kaXRpb24nLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnc2VsZWN0aW9uU2V0JyxcbiAgXSxcbiAgSW50VmFsdWU6IFtdLFxuICBGbG9hdFZhbHVlOiBbXSxcbiAgU3RyaW5nVmFsdWU6IFtdLFxuICBCb29sZWFuVmFsdWU6IFtdLFxuICBOdWxsVmFsdWU6IFtdLFxuICBFbnVtVmFsdWU6IFtdLFxuICBMaXN0VmFsdWU6IFsndmFsdWVzJ10sXG4gIE9iamVjdFZhbHVlOiBbJ2ZpZWxkcyddLFxuICBPYmplY3RGaWVsZDogWyduYW1lJywgJ3ZhbHVlJ10sXG4gIERpcmVjdGl2ZTogWyduYW1lJywgJ2FyZ3VtZW50cyddLFxuICBOYW1lZFR5cGU6IFsnbmFtZSddLFxuICBMaXN0VHlwZTogWyd0eXBlJ10sXG4gIE5vbk51bGxUeXBlOiBbJ3R5cGUnXSxcbiAgU2NoZW1hRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICdkaXJlY3RpdmVzJywgJ29wZXJhdGlvblR5cGVzJ10sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiBbJ3R5cGUnXSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiBbXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnbmFtZScsXG4gICAgJ2ludGVyZmFjZXMnLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnZmllbGRzJyxcbiAgXSxcbiAgRmllbGREZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ3R5cGUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogW1xuICAgICdkZXNjcmlwdGlvbicsXG4gICAgJ25hbWUnLFxuICAgICd0eXBlJyxcbiAgICAnZGVmYXVsdFZhbHVlJyxcbiAgICAnZGlyZWN0aXZlcycsXG4gIF0sXG4gIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiBbXG4gICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAnbmFtZScsXG4gICAgJ2ludGVyZmFjZXMnLFxuICAgICdkaXJlY3RpdmVzJyxcbiAgICAnZmllbGRzJyxcbiAgXSxcbiAgVW5pb25UeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndHlwZXMnXSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcycsICd2YWx1ZXMnXSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnXSxcbiAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIERpcmVjdGl2ZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdhcmd1bWVudHMnLCAnbG9jYXRpb25zJ10sXG4gIFNjaGVtYUV4dGVuc2lvbjogWydkaXJlY3RpdmVzJywgJ29wZXJhdGlvblR5cGVzJ10sXG4gIFNjYWxhclR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIE9iamVjdFR5cGVFeHRlbnNpb246IFsnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIEludGVyZmFjZVR5cGVFeHRlbnNpb246IFsnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndHlwZXMnXSxcbiAgRW51bVR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ3ZhbHVlcyddLFxuICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxufTtcbmNvbnN0IGtpbmRWYWx1ZXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKFF1ZXJ5RG9jdW1lbnRLZXlzKSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGUobWF5YmVOb2RlKSB7XG4gIGNvbnN0IG1heWJlS2luZCA9XG4gICAgbWF5YmVOb2RlID09PSBudWxsIHx8IG1heWJlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVOb2RlLmtpbmQ7XG4gIHJldHVybiB0eXBlb2YgbWF5YmVLaW5kID09PSAnc3RyaW5nJyAmJiBraW5kVmFsdWVzLmhhcyhtYXliZUtpbmQpO1xufVxuLyoqIE5hbWUgKi9cblxudmFyIE9wZXJhdGlvblR5cGVOb2RlO1xuXG4oZnVuY3Rpb24gKE9wZXJhdGlvblR5cGVOb2RlKSB7XG4gIE9wZXJhdGlvblR5cGVOb2RlWydRVUVSWSddID0gJ3F1ZXJ5JztcbiAgT3BlcmF0aW9uVHlwZU5vZGVbJ01VVEFUSU9OJ10gPSAnbXV0YXRpb24nO1xuICBPcGVyYXRpb25UeXBlTm9kZVsnU1VCU0NSSVBUSU9OJ10gPSAnc3Vic2NyaXB0aW9uJztcbn0pKE9wZXJhdGlvblR5cGVOb2RlIHx8IChPcGVyYXRpb25UeXBlTm9kZSA9IHt9KSk7XG5cbmV4cG9ydCB7IE9wZXJhdGlvblR5cGVOb2RlIH07XG4iLCAiLyoqXG4gKiBUaGUgc2V0IG9mIGFsbG93ZWQgZGlyZWN0aXZlIGxvY2F0aW9uIHZhbHVlcy5cbiAqL1xudmFyIERpcmVjdGl2ZUxvY2F0aW9uO1xuXG4oZnVuY3Rpb24gKERpcmVjdGl2ZUxvY2F0aW9uKSB7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydRVUVSWSddID0gJ1FVRVJZJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ01VVEFUSU9OJ10gPSAnTVVUQVRJT04nO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnU1VCU0NSSVBUSU9OJ10gPSAnU1VCU0NSSVBUSU9OJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0ZJRUxEJ10gPSAnRklFTEQnO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnRlJBR01FTlRfREVGSU5JVElPTiddID0gJ0ZSQUdNRU5UX0RFRklOSVRJT04nO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnRlJBR01FTlRfU1BSRUFEJ10gPSAnRlJBR01FTlRfU1BSRUFEJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ0lOTElORV9GUkFHTUVOVCddID0gJ0lOTElORV9GUkFHTUVOVCc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydWQVJJQUJMRV9ERUZJTklUSU9OJ10gPSAnVkFSSUFCTEVfREVGSU5JVElPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydTQ0hFTUEnXSA9ICdTQ0hFTUEnO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnU0NBTEFSJ10gPSAnU0NBTEFSJztcbiAgRGlyZWN0aXZlTG9jYXRpb25bJ09CSkVDVCddID0gJ09CSkVDVCc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydGSUVMRF9ERUZJTklUSU9OJ10gPSAnRklFTERfREVGSU5JVElPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydBUkdVTUVOVF9ERUZJTklUSU9OJ10gPSAnQVJHVU1FTlRfREVGSU5JVElPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydJTlRFUkZBQ0UnXSA9ICdJTlRFUkZBQ0UnO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnVU5JT04nXSA9ICdVTklPTic7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydFTlVNJ10gPSAnRU5VTSc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydFTlVNX1ZBTFVFJ10gPSAnRU5VTV9WQUxVRSc7XG4gIERpcmVjdGl2ZUxvY2F0aW9uWydJTlBVVF9PQkpFQ1QnXSA9ICdJTlBVVF9PQkpFQ1QnO1xuICBEaXJlY3RpdmVMb2NhdGlvblsnSU5QVVRfRklFTERfREVGSU5JVElPTiddID0gJ0lOUFVUX0ZJRUxEX0RFRklOSVRJT04nO1xufSkoRGlyZWN0aXZlTG9jYXRpb24gfHwgKERpcmVjdGl2ZUxvY2F0aW9uID0ge30pKTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlTG9jYXRpb24gfTtcbi8qKlxuICogVGhlIGVudW0gdHlwZSByZXByZXNlbnRpbmcgdGhlIGRpcmVjdGl2ZSBsb2NhdGlvbiB2YWx1ZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgRGlyZWN0aXZlTG9jYXRpb25gLiBXaWxsIGJlIHJlbW92ZSBpbiB2MTcuXG4gKi9cbiIsICIvKipcbiAqIFRoZSBzZXQgb2YgYWxsb3dlZCBraW5kIHZhbHVlcyBmb3IgQVNUIG5vZGVzLlxuICovXG52YXIgS2luZDtcblxuKGZ1bmN0aW9uIChLaW5kKSB7XG4gIEtpbmRbJ05BTUUnXSA9ICdOYW1lJztcbiAgS2luZFsnRE9DVU1FTlQnXSA9ICdEb2N1bWVudCc7XG4gIEtpbmRbJ09QRVJBVElPTl9ERUZJTklUSU9OJ10gPSAnT3BlcmF0aW9uRGVmaW5pdGlvbic7XG4gIEtpbmRbJ1ZBUklBQkxFX0RFRklOSVRJT04nXSA9ICdWYXJpYWJsZURlZmluaXRpb24nO1xuICBLaW5kWydTRUxFQ1RJT05fU0VUJ10gPSAnU2VsZWN0aW9uU2V0JztcbiAgS2luZFsnRklFTEQnXSA9ICdGaWVsZCc7XG4gIEtpbmRbJ0FSR1VNRU5UJ10gPSAnQXJndW1lbnQnO1xuICBLaW5kWydGUkFHTUVOVF9TUFJFQUQnXSA9ICdGcmFnbWVudFNwcmVhZCc7XG4gIEtpbmRbJ0lOTElORV9GUkFHTUVOVCddID0gJ0lubGluZUZyYWdtZW50JztcbiAgS2luZFsnRlJBR01FTlRfREVGSU5JVElPTiddID0gJ0ZyYWdtZW50RGVmaW5pdGlvbic7XG4gIEtpbmRbJ1ZBUklBQkxFJ10gPSAnVmFyaWFibGUnO1xuICBLaW5kWydJTlQnXSA9ICdJbnRWYWx1ZSc7XG4gIEtpbmRbJ0ZMT0FUJ10gPSAnRmxvYXRWYWx1ZSc7XG4gIEtpbmRbJ1NUUklORyddID0gJ1N0cmluZ1ZhbHVlJztcbiAgS2luZFsnQk9PTEVBTiddID0gJ0Jvb2xlYW5WYWx1ZSc7XG4gIEtpbmRbJ05VTEwnXSA9ICdOdWxsVmFsdWUnO1xuICBLaW5kWydFTlVNJ10gPSAnRW51bVZhbHVlJztcbiAgS2luZFsnTElTVCddID0gJ0xpc3RWYWx1ZSc7XG4gIEtpbmRbJ09CSkVDVCddID0gJ09iamVjdFZhbHVlJztcbiAgS2luZFsnT0JKRUNUX0ZJRUxEJ10gPSAnT2JqZWN0RmllbGQnO1xuICBLaW5kWydESVJFQ1RJVkUnXSA9ICdEaXJlY3RpdmUnO1xuICBLaW5kWydOQU1FRF9UWVBFJ10gPSAnTmFtZWRUeXBlJztcbiAgS2luZFsnTElTVF9UWVBFJ10gPSAnTGlzdFR5cGUnO1xuICBLaW5kWydOT05fTlVMTF9UWVBFJ10gPSAnTm9uTnVsbFR5cGUnO1xuICBLaW5kWydTQ0hFTUFfREVGSU5JVElPTiddID0gJ1NjaGVtYURlZmluaXRpb24nO1xuICBLaW5kWydPUEVSQVRJT05fVFlQRV9ERUZJTklUSU9OJ10gPSAnT3BlcmF0aW9uVHlwZURlZmluaXRpb24nO1xuICBLaW5kWydTQ0FMQVJfVFlQRV9ERUZJTklUSU9OJ10gPSAnU2NhbGFyVHlwZURlZmluaXRpb24nO1xuICBLaW5kWydPQkpFQ1RfVFlQRV9ERUZJTklUSU9OJ10gPSAnT2JqZWN0VHlwZURlZmluaXRpb24nO1xuICBLaW5kWydGSUVMRF9ERUZJTklUSU9OJ10gPSAnRmllbGREZWZpbml0aW9uJztcbiAgS2luZFsnSU5QVVRfVkFMVUVfREVGSU5JVElPTiddID0gJ0lucHV0VmFsdWVEZWZpbml0aW9uJztcbiAgS2luZFsnSU5URVJGQUNFX1RZUEVfREVGSU5JVElPTiddID0gJ0ludGVyZmFjZVR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnVU5JT05fVFlQRV9ERUZJTklUSU9OJ10gPSAnVW5pb25UeXBlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0VOVU1fVFlQRV9ERUZJTklUSU9OJ10gPSAnRW51bVR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnRU5VTV9WQUxVRV9ERUZJTklUSU9OJ10gPSAnRW51bVZhbHVlRGVmaW5pdGlvbic7XG4gIEtpbmRbJ0lOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04nXSA9ICdJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uJztcbiAgS2luZFsnRElSRUNUSVZFX0RFRklOSVRJT04nXSA9ICdEaXJlY3RpdmVEZWZpbml0aW9uJztcbiAgS2luZFsnU0NIRU1BX0VYVEVOU0lPTiddID0gJ1NjaGVtYUV4dGVuc2lvbic7XG4gIEtpbmRbJ1NDQUxBUl9UWVBFX0VYVEVOU0lPTiddID0gJ1NjYWxhclR5cGVFeHRlbnNpb24nO1xuICBLaW5kWydPQkpFQ1RfVFlQRV9FWFRFTlNJT04nXSA9ICdPYmplY3RUeXBlRXh0ZW5zaW9uJztcbiAgS2luZFsnSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OJ10gPSAnSW50ZXJmYWNlVHlwZUV4dGVuc2lvbic7XG4gIEtpbmRbJ1VOSU9OX1RZUEVfRVhURU5TSU9OJ10gPSAnVW5pb25UeXBlRXh0ZW5zaW9uJztcbiAgS2luZFsnRU5VTV9UWVBFX0VYVEVOU0lPTiddID0gJ0VudW1UeXBlRXh0ZW5zaW9uJztcbiAgS2luZFsnSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OJ10gPSAnSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uJztcbn0pKEtpbmQgfHwgKEtpbmQgPSB7fSkpO1xuXG5leHBvcnQgeyBLaW5kIH07XG4vKipcbiAqIFRoZSBlbnVtIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBwb3NzaWJsZSBraW5kIHZhbHVlcyBvZiBBU1Qgbm9kZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgS2luZGAuIFdpbGwgYmUgcmVtb3ZlIGluIHYxNy5cbiAqL1xuIiwgIi8qKlxuICogYGBgXG4gKiBXaGl0ZVNwYWNlIDo6XG4gKiAgIC0gXCJIb3Jpem9udGFsIFRhYiAoVSswMDA5KVwiXG4gKiAgIC0gXCJTcGFjZSAoVSswMDIwKVwiXG4gKiBgYGBcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDB4MDAwOSB8fCBjb2RlID09PSAweDAwMjA7XG59XG4vKipcbiAqIGBgYFxuICogRGlnaXQgOjogb25lIG9mXG4gKiAgIC0gYDBgIGAxYCBgMmAgYDNgIGA0YCBgNWAgYDZgIGA3YCBgOGAgYDlgXG4gKiBgYGBcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5O1xufVxuLyoqXG4gKiBgYGBcbiAqIExldHRlciA6OiBvbmUgb2ZcbiAqICAgLSBgQWAgYEJgIGBDYCBgRGAgYEVgIGBGYCBgR2AgYEhgIGBJYCBgSmAgYEtgIGBMYCBgTWBcbiAqICAgLSBgTmAgYE9gIGBQYCBgUWAgYFJgIGBTYCBgVGAgYFVgIGBWYCBgV2AgYFhgIGBZYCBgWmBcbiAqICAgLSBgYWAgYGJgIGBjYCBgZGAgYGVgIGBmYCBgZ2AgYGhgIGBpYCBgamAgYGtgIGBsYCBgbWBcbiAqICAgLSBgbmAgYG9gIGBwYCBgcWAgYHJgIGBzYCBgdGAgYHVgIGB2YCBgd2AgYHhgIGB5YCBgemBcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGV0dGVyKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EpIHx8IC8vIEEtWlxuICAgIChjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSkgLy8gYS16XG4gICk7XG59XG4vKipcbiAqIGBgYFxuICogTmFtZVN0YXJ0IDo6XG4gKiAgIC0gTGV0dGVyXG4gKiAgIC0gYF9gXG4gKiBgYGBcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVTdGFydChjb2RlKSB7XG4gIHJldHVybiBpc0xldHRlcihjb2RlKSB8fCBjb2RlID09PSAweDAwNWY7XG59XG4vKipcbiAqIGBgYFxuICogTmFtZUNvbnRpbnVlIDo6XG4gKiAgIC0gTGV0dGVyXG4gKiAgIC0gRGlnaXRcbiAqICAgLSBgX2BcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTmFtZUNvbnRpbnVlKGNvZGUpIHtcbiAgcmV0dXJuIGlzTGV0dGVyKGNvZGUpIHx8IGlzRGlnaXQoY29kZSkgfHwgY29kZSA9PT0gMHgwMDVmO1xufVxuIiwgImltcG9ydCB7IGlzV2hpdGVTcGFjZSB9IGZyb20gJy4vY2hhcmFjdGVyQ2xhc3Nlcy5tanMnO1xuLyoqXG4gKiBQcm9kdWNlcyB0aGUgdmFsdWUgb2YgYSBibG9jayBzdHJpbmcgZnJvbSBpdHMgcGFyc2VkIHJhdyB2YWx1ZSwgc2ltaWxhciB0b1xuICogQ29mZmVlU2NyaXB0J3MgYmxvY2sgc3RyaW5nLCBQeXRob24ncyBkb2NzdHJpbmcgdHJpbSBvciBSdWJ5J3Mgc3RyaXBfaGVyZWRvYy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIEdyYXBoUUwgc3BlYydzIEJsb2NrU3RyaW5nVmFsdWUoKSBzdGF0aWMgYWxnb3JpdGhtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWRlbnRCbG9ja1N0cmluZ0xpbmVzKGxpbmVzKSB7XG4gIHZhciBfZmlyc3ROb25FbXB0eUxpbmUyO1xuXG4gIGxldCBjb21tb25JbmRlbnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgbGV0IGZpcnN0Tm9uRW1wdHlMaW5lID0gbnVsbDtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAtMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIF9maXJzdE5vbkVtcHR5TGluZTtcblxuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZShsaW5lKTtcblxuICAgIGlmIChpbmRlbnQgPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eSBsaW5lc1xuICAgIH1cblxuICAgIGZpcnN0Tm9uRW1wdHlMaW5lID1cbiAgICAgIChfZmlyc3ROb25FbXB0eUxpbmUgPSBmaXJzdE5vbkVtcHR5TGluZSkgIT09IG51bGwgJiZcbiAgICAgIF9maXJzdE5vbkVtcHR5TGluZSAhPT0gdm9pZCAwXG4gICAgICAgID8gX2ZpcnN0Tm9uRW1wdHlMaW5lXG4gICAgICAgIDogaTtcbiAgICBsYXN0Tm9uRW1wdHlMaW5lID0gaTtcblxuICAgIGlmIChpICE9PSAwICYmIGluZGVudCA8IGNvbW1vbkluZGVudCkge1xuICAgICAgY29tbW9uSW5kZW50ID0gaW5kZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5lcyAvLyBSZW1vdmUgY29tbW9uIGluZGVudGF0aW9uIGZyb20gYWxsIGxpbmVzIGJ1dCBmaXJzdC5cbiAgICAubWFwKChsaW5lLCBpKSA9PiAoaSA9PT0gMCA/IGxpbmUgOiBsaW5lLnNsaWNlKGNvbW1vbkluZGVudCkpKSAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgYmxhbmsgbGluZXMuXG4gICAgLnNsaWNlKFxuICAgICAgKF9maXJzdE5vbkVtcHR5TGluZTIgPSBmaXJzdE5vbkVtcHR5TGluZSkgIT09IG51bGwgJiZcbiAgICAgICAgX2ZpcnN0Tm9uRW1wdHlMaW5lMiAhPT0gdm9pZCAwXG4gICAgICAgID8gX2ZpcnN0Tm9uRW1wdHlMaW5lMlxuICAgICAgICA6IDAsXG4gICAgICBsYXN0Tm9uRW1wdHlMaW5lICsgMSxcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsZWFkaW5nV2hpdGVzcGFjZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgc3RyLmxlbmd0aCAmJiBpc1doaXRlU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgKytpO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW50YWJsZUFzQmxvY2tTdHJpbmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgcHJpbnRhYmxlXG4gIH1cblxuICBsZXQgaXNFbXB0eUxpbmUgPSB0cnVlO1xuICBsZXQgaGFzSW5kZW50ID0gZmFsc2U7XG4gIGxldCBoYXNDb21tb25JbmRlbnQgPSB0cnVlO1xuICBsZXQgc2Vlbk5vbkVtcHR5TGluZSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvZGVQb2ludEF0KGkpKSB7XG4gICAgICBjYXNlIDB4MDAwMDpcbiAgICAgIGNhc2UgMHgwMDAxOlxuICAgICAgY2FzZSAweDAwMDI6XG4gICAgICBjYXNlIDB4MDAwMzpcbiAgICAgIGNhc2UgMHgwMDA0OlxuICAgICAgY2FzZSAweDAwMDU6XG4gICAgICBjYXNlIDB4MDAwNjpcbiAgICAgIGNhc2UgMHgwMDA3OlxuICAgICAgY2FzZSAweDAwMDg6XG4gICAgICBjYXNlIDB4MDAwYjpcbiAgICAgIGNhc2UgMHgwMDBjOlxuICAgICAgY2FzZSAweDAwMGU6XG4gICAgICBjYXNlIDB4MDAwZjpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gSGFzIG5vbi1wcmludGFibGUgY2hhcmFjdGVyc1xuXG4gICAgICBjYXNlIDB4MDAwZDpcbiAgICAgICAgLy8gIFxcclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBIYXMgXFxyIG9yIFxcclxcbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIGFzIFxcblxuXG4gICAgICBjYXNlIDEwOlxuICAgICAgICAvLyAgXFxuXG4gICAgICAgIGlmIChpc0VtcHR5TGluZSAmJiAhc2Vlbk5vbkVtcHR5TGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSGFzIGxlYWRpbmcgbmV3IGxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5Ob25FbXB0eUxpbmUgPSB0cnVlO1xuICAgICAgICBpc0VtcHR5TGluZSA9IHRydWU7XG4gICAgICAgIGhhc0luZGVudCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5OiAvLyAgIFxcdFxuXG4gICAgICBjYXNlIDMyOlxuICAgICAgICAvLyAgPHNwYWNlPlxuICAgICAgICBoYXNJbmRlbnQgfHwgKGhhc0luZGVudCA9IGlzRW1wdHlMaW5lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhhc0NvbW1vbkluZGVudCAmJiAoaGFzQ29tbW9uSW5kZW50ID0gaGFzSW5kZW50KTtcbiAgICAgICAgaXNFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNFbXB0eUxpbmUpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIEhhcyB0cmFpbGluZyBlbXB0eSBsaW5lc1xuICB9XG5cbiAgaWYgKGhhc0NvbW1vbkluZGVudCAmJiBzZWVuTm9uRW1wdHlMaW5lKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBIYXMgaW50ZXJuYWwgaW5kZW50XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUHJpbnQgYSBibG9jayBzdHJpbmcgaW4gdGhlIGluZGVudGVkIGJsb2NrIGZvcm0gYnkgYWRkaW5nIGEgbGVhZGluZyBhbmRcbiAqIHRyYWlsaW5nIGJsYW5rIGxpbmUuIEhvd2V2ZXIsIGlmIGEgYmxvY2sgc3RyaW5nIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UgYW5kIGlzXG4gKiBhIHNpbmdsZS1saW5lLCBhZGRpbmcgYSBsZWFkaW5nIGJsYW5rIGxpbmUgd291bGQgc3RyaXAgdGhhdCB3aGl0ZXNwYWNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludEJsb2NrU3RyaW5nKHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLCAnXFxcXFwiXCJcIicpOyAvLyBFeHBhbmQgYSBibG9jayBzdHJpbmcncyByYXcgdmFsdWUgaW50byBpbmRlcGVuZGVudCBsaW5lcy5cblxuICBjb25zdCBsaW5lcyA9IGVzY2FwZWRWYWx1ZS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBpc1NpbmdsZUxpbmUgPSBsaW5lcy5sZW5ndGggPT09IDE7IC8vIElmIGNvbW1vbiBpbmRlbnRhdGlvbiBpcyBmb3VuZCB3ZSBjYW4gZml4IHNvbWUgb2YgdGhvc2UgY2FzZXMgYnkgYWRkaW5nIGxlYWRpbmcgbmV3IGxpbmVcblxuICBjb25zdCBmb3JjZUxlYWRpbmdOZXdMaW5lID1cbiAgICBsaW5lcy5sZW5ndGggPiAxICYmXG4gICAgbGluZXNcbiAgICAgIC5zbGljZSgxKVxuICAgICAgLmV2ZXJ5KChsaW5lKSA9PiBsaW5lLmxlbmd0aCA9PT0gMCB8fCBpc1doaXRlU3BhY2UobGluZS5jaGFyQ29kZUF0KDApKSk7IC8vIFRyYWlsaW5nIHRyaXBsZSBxdW90ZXMganVzdCBsb29rcyBjb25mdXNpbmcgYnV0IGRvZXNuJ3QgZm9yY2UgdHJhaWxpbmcgbmV3IGxpbmVcblxuICBjb25zdCBoYXNUcmFpbGluZ1RyaXBsZVF1b3RlcyA9IGVzY2FwZWRWYWx1ZS5lbmRzV2l0aCgnXFxcXFwiXCJcIicpOyAvLyBUcmFpbGluZyBxdW90ZSAoc2luZ2xlIG9yIGRvdWJsZSkgb3Igc2xhc2ggZm9yY2VzIHRyYWlsaW5nIG5ldyBsaW5lXG5cbiAgY29uc3QgaGFzVHJhaWxpbmdRdW90ZSA9IHZhbHVlLmVuZHNXaXRoKCdcIicpICYmICFoYXNUcmFpbGluZ1RyaXBsZVF1b3RlcztcbiAgY29uc3QgaGFzVHJhaWxpbmdTbGFzaCA9IHZhbHVlLmVuZHNXaXRoKCdcXFxcJyk7XG4gIGNvbnN0IGZvcmNlVHJhaWxpbmdOZXdsaW5lID0gaGFzVHJhaWxpbmdRdW90ZSB8fCBoYXNUcmFpbGluZ1NsYXNoO1xuICBjb25zdCBwcmludEFzTXVsdGlwbGVMaW5lcyA9XG4gICAgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm1pbmltaXplKSAmJiAvLyBhZGQgbGVhZGluZyBhbmQgdHJhaWxpbmcgbmV3IGxpbmVzIG9ubHkgaWYgaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHlcbiAgICAoIWlzU2luZ2xlTGluZSB8fFxuICAgICAgdmFsdWUubGVuZ3RoID4gNzAgfHxcbiAgICAgIGZvcmNlVHJhaWxpbmdOZXdsaW5lIHx8XG4gICAgICBmb3JjZUxlYWRpbmdOZXdMaW5lIHx8XG4gICAgICBoYXNUcmFpbGluZ1RyaXBsZVF1b3Rlcyk7XG4gIGxldCByZXN1bHQgPSAnJzsgLy8gRm9ybWF0IGEgbXVsdGktbGluZSBibG9jayBxdW90ZSB0byBhY2NvdW50IGZvciBsZWFkaW5nIHNwYWNlLlxuXG4gIGNvbnN0IHNraXBMZWFkaW5nTmV3TGluZSA9IGlzU2luZ2xlTGluZSAmJiBpc1doaXRlU3BhY2UodmFsdWUuY2hhckNvZGVBdCgwKSk7XG5cbiAgaWYgKChwcmludEFzTXVsdGlwbGVMaW5lcyAmJiAhc2tpcExlYWRpbmdOZXdMaW5lKSB8fCBmb3JjZUxlYWRpbmdOZXdMaW5lKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgcmVzdWx0ICs9IGVzY2FwZWRWYWx1ZTtcblxuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMgfHwgZm9yY2VUcmFpbGluZ05ld2xpbmUpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICByZXR1cm4gJ1wiXCJcIicgKyByZXN1bHQgKyAnXCJcIlwiJztcbn1cbiIsICIvKipcbiAqIEFuIGV4cG9ydGVkIGVudW0gZGVzY3JpYmluZyB0aGUgZGlmZmVyZW50IGtpbmRzIG9mIHRva2VucyB0aGF0IHRoZVxuICogbGV4ZXIgZW1pdHMuXG4gKi9cbnZhciBUb2tlbktpbmQ7XG5cbihmdW5jdGlvbiAoVG9rZW5LaW5kKSB7XG4gIFRva2VuS2luZFsnU09GJ10gPSAnPFNPRj4nO1xuICBUb2tlbktpbmRbJ0VPRiddID0gJzxFT0Y+JztcbiAgVG9rZW5LaW5kWydCQU5HJ10gPSAnISc7XG4gIFRva2VuS2luZFsnRE9MTEFSJ10gPSAnJCc7XG4gIFRva2VuS2luZFsnQU1QJ10gPSAnJic7XG4gIFRva2VuS2luZFsnUEFSRU5fTCddID0gJygnO1xuICBUb2tlbktpbmRbJ1BBUkVOX1InXSA9ICcpJztcbiAgVG9rZW5LaW5kWydTUFJFQUQnXSA9ICcuLi4nO1xuICBUb2tlbktpbmRbJ0NPTE9OJ10gPSAnOic7XG4gIFRva2VuS2luZFsnRVFVQUxTJ10gPSAnPSc7XG4gIFRva2VuS2luZFsnQVQnXSA9ICdAJztcbiAgVG9rZW5LaW5kWydCUkFDS0VUX0wnXSA9ICdbJztcbiAgVG9rZW5LaW5kWydCUkFDS0VUX1InXSA9ICddJztcbiAgVG9rZW5LaW5kWydCUkFDRV9MJ10gPSAneyc7XG4gIFRva2VuS2luZFsnUElQRSddID0gJ3wnO1xuICBUb2tlbktpbmRbJ0JSQUNFX1InXSA9ICd9JztcbiAgVG9rZW5LaW5kWydOQU1FJ10gPSAnTmFtZSc7XG4gIFRva2VuS2luZFsnSU5UJ10gPSAnSW50JztcbiAgVG9rZW5LaW5kWydGTE9BVCddID0gJ0Zsb2F0JztcbiAgVG9rZW5LaW5kWydTVFJJTkcnXSA9ICdTdHJpbmcnO1xuICBUb2tlbktpbmRbJ0JMT0NLX1NUUklORyddID0gJ0Jsb2NrU3RyaW5nJztcbiAgVG9rZW5LaW5kWydDT01NRU5UJ10gPSAnQ29tbWVudCc7XG59KShUb2tlbktpbmQgfHwgKFRva2VuS2luZCA9IHt9KSk7XG5cbmV4cG9ydCB7IFRva2VuS2luZCB9O1xuLyoqXG4gKiBUaGUgZW51bSB0eXBlIHJlcHJlc2VudGluZyB0aGUgdG9rZW4ga2luZHMgdmFsdWVzLlxuICpcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYFRva2VuS2luZGAuIFdpbGwgYmUgcmVtb3ZlIGluIHYxNy5cbiAqL1xuIiwgImltcG9ydCB7IHN5bnRheEVycm9yIH0gZnJvbSAnLi4vZXJyb3Ivc3ludGF4RXJyb3IubWpzJztcbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnLi9hc3QubWpzJztcbmltcG9ydCB7IGRlZGVudEJsb2NrU3RyaW5nTGluZXMgfSBmcm9tICcuL2Jsb2NrU3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc0RpZ2l0LCBpc05hbWVDb250aW51ZSwgaXNOYW1lU3RhcnQgfSBmcm9tICcuL2NoYXJhY3RlckNsYXNzZXMubWpzJztcbmltcG9ydCB7IFRva2VuS2luZCB9IGZyb20gJy4vdG9rZW5LaW5kLm1qcyc7XG4vKipcbiAqIEdpdmVuIGEgU291cmNlIG9iamVjdCwgY3JlYXRlcyBhIExleGVyIGZvciB0aGF0IHNvdXJjZS5cbiAqIEEgTGV4ZXIgaXMgYSBzdGF0ZWZ1bCBzdHJlYW0gZ2VuZXJhdG9yIGluIHRoYXQgZXZlcnkgdGltZVxuICogaXQgaXMgYWR2YW5jZWQsIGl0IHJldHVybnMgdGhlIG5leHQgdG9rZW4gaW4gdGhlIFNvdXJjZS4gQXNzdW1pbmcgdGhlXG4gKiBzb3VyY2UgbGV4ZXMsIHRoZSBmaW5hbCBUb2tlbiBlbWl0dGVkIGJ5IHRoZSBsZXhlciB3aWxsIGJlIG9mIGtpbmRcbiAqIEVPRiwgYWZ0ZXIgd2hpY2ggdGhlIGxleGVyIHdpbGwgcmVwZWF0ZWRseSByZXR1cm4gdGhlIHNhbWUgRU9GIHRva2VuXG4gKiB3aGVuZXZlciBjYWxsZWQuXG4gKi9cblxuZXhwb3J0IGNsYXNzIExleGVyIHtcbiAgLyoqXG4gICAqIFRoZSBwcmV2aW91c2x5IGZvY3VzZWQgbm9uLWlnbm9yZWQgdG9rZW4uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGZvY3VzZWQgbm9uLWlnbm9yZWQgdG9rZW4uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgKDEtaW5kZXhlZCkgbGluZSBjb250YWluaW5nIHRoZSBjdXJyZW50IHRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhlIGN1cnJlbnQgbGluZSBiZWdpbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBjb25zdCBzdGFydE9mRmlsZVRva2VuID0gbmV3IFRva2VuKFRva2VuS2luZC5TT0YsIDAsIDAsIDAsIDApO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubGFzdFRva2VuID0gc3RhcnRPZkZpbGVUb2tlbjtcbiAgICB0aGlzLnRva2VuID0gc3RhcnRPZkZpbGVUb2tlbjtcbiAgICB0aGlzLmxpbmUgPSAxO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0xleGVyJztcbiAgfVxuICAvKipcbiAgICogQWR2YW5jZXMgdGhlIHRva2VuIHN0cmVhbSB0byB0aGUgbmV4dCBub24taWdub3JlZCB0b2tlbi5cbiAgICovXG5cbiAgYWR2YW5jZSgpIHtcbiAgICB0aGlzLmxhc3RUb2tlbiA9IHRoaXMudG9rZW47XG4gICAgY29uc3QgdG9rZW4gPSAodGhpcy50b2tlbiA9IHRoaXMubG9va2FoZWFkKCkpO1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICAvKipcbiAgICogTG9va3MgYWhlYWQgYW5kIHJldHVybnMgdGhlIG5leHQgbm9uLWlnbm9yZWQgdG9rZW4sIGJ1dCBkb2VzIG5vdCBjaGFuZ2VcbiAgICogdGhlIHN0YXRlIG9mIExleGVyLlxuICAgKi9cblxuICBsb29rYWhlYWQoKSB7XG4gICAgbGV0IHRva2VuID0gdGhpcy50b2tlbjtcblxuICAgIGlmICh0b2tlbi5raW5kICE9PSBUb2tlbktpbmQuRU9GKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICh0b2tlbi5uZXh0KSB7XG4gICAgICAgICAgdG9rZW4gPSB0b2tlbi5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlYWQgdGhlIG5leHQgdG9rZW4gYW5kIGZvcm0gYSBsaW5rIGluIHRoZSB0b2tlbiBsaW5rZWQtbGlzdC5cbiAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSByZWFkTmV4dFRva2VuKHRoaXMsIHRva2VuLmVuZCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgbmV4dCBpcyBvbmx5IG11dGFibGUgZHVyaW5nIHBhcnNpbmcuXG5cbiAgICAgICAgICB0b2tlbi5uZXh0ID0gbmV4dFRva2VuOyAvLyBAdHMtZXhwZWN0LWVycm9yIHByZXYgaXMgb25seSBtdXRhYmxlIGR1cmluZyBwYXJzaW5nLlxuXG4gICAgICAgICAgbmV4dFRva2VuLnByZXYgPSB0b2tlbjtcbiAgICAgICAgICB0b2tlbiA9IG5leHRUb2tlbjtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLkNPTU1FTlQpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQdW5jdHVhdG9yVG9rZW5LaW5kKGtpbmQpIHtcbiAgcmV0dXJuIChcbiAgICBraW5kID09PSBUb2tlbktpbmQuQkFORyB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5ET0xMQVIgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQU1QIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLlBBUkVOX0wgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuUEFSRU5fUiB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5TUFJFQUQgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQ09MT04gfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuRVFVQUxTIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLkFUIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNLRVRfTCB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5CUkFDS0VUX1IgfHxcbiAgICBraW5kID09PSBUb2tlbktpbmQuQlJBQ0VfTCB8fFxuICAgIGtpbmQgPT09IFRva2VuS2luZC5QSVBFIHx8XG4gICAga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNFX1JcbiAgKTtcbn1cbi8qKlxuICogQSBVbmljb2RlIHNjYWxhciB2YWx1ZSBpcyBhbnkgVW5pY29kZSBjb2RlIHBvaW50IGV4Y2VwdCBzdXJyb2dhdGUgY29kZVxuICogcG9pbnRzLiBJbiBvdGhlciB3b3JkcywgdGhlIGluY2x1c2l2ZSByYW5nZXMgb2YgdmFsdWVzIDB4MDAwMCB0byAweEQ3RkYgYW5kXG4gKiAweEUwMDAgdG8gMHgxMEZGRkYuXG4gKlxuICogU291cmNlQ2hhcmFjdGVyIDo6XG4gKiAgIC0gXCJBbnkgVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxuICovXG5cbmZ1bmN0aW9uIGlzVW5pY29kZVNjYWxhclZhbHVlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAweDAwMDAgJiYgY29kZSA8PSAweGQ3ZmYpIHx8IChjb2RlID49IDB4ZTAwMCAmJiBjb2RlIDw9IDB4MTBmZmZmKVxuICApO1xufVxuLyoqXG4gKiBUaGUgR3JhcGhRTCBzcGVjaWZpY2F0aW9uIGRlZmluZXMgc291cmNlIHRleHQgYXMgYSBzZXF1ZW5jZSBvZiB1bmljb2RlIHNjYWxhclxuICogdmFsdWVzICh3aGljaCBVbmljb2RlIGRlZmluZXMgdG8gZXhjbHVkZSBzdXJyb2dhdGUgY29kZSBwb2ludHMpLiBIb3dldmVyXG4gKiBKYXZhU2NyaXB0IGRlZmluZXMgc3RyaW5ncyBhcyBhIHNlcXVlbmNlIG9mIFVURi0xNiBjb2RlIHVuaXRzIHdoaWNoIG1heVxuICogaW5jbHVkZSBzdXJyb2dhdGVzLiBBIHN1cnJvZ2F0ZSBwYWlyIGlzIGEgdmFsaWQgc291cmNlIGNoYXJhY3RlciBhcyBpdFxuICogZW5jb2RlcyBhIHN1cHBsZW1lbnRhcnkgY29kZSBwb2ludCAoYWJvdmUgVStGRkZGKSwgYnV0IHVucGFpcmVkIHN1cnJvZ2F0ZVxuICogY29kZSBwb2ludHMgYXJlIG5vdCB2YWxpZCBzb3VyY2UgY2hhcmFjdGVycy5cbiAqL1xuXG5mdW5jdGlvbiBpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIChcbiAgICBpc0xlYWRpbmdTdXJyb2dhdGUoYm9keS5jaGFyQ29kZUF0KGxvY2F0aW9uKSkgJiZcbiAgICBpc1RyYWlsaW5nU3Vycm9nYXRlKGJvZHkuY2hhckNvZGVBdChsb2NhdGlvbiArIDEpKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0xlYWRpbmdTdXJyb2dhdGUoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmY7XG59XG5cbmZ1bmN0aW9uIGlzVHJhaWxpbmdTdXJyb2dhdGUoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAweGRjMDAgJiYgY29kZSA8PSAweGRmZmY7XG59XG4vKipcbiAqIFByaW50cyB0aGUgY29kZSBwb2ludCAob3IgZW5kIG9mIGZpbGUgcmVmZXJlbmNlKSBhdCBhIGdpdmVuIGxvY2F0aW9uIGluIGFcbiAqIHNvdXJjZSBmb3IgdXNlIGluIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFByaW50YWJsZSBBU0NJSSBpcyBwcmludGVkIHF1b3RlZCwgd2hpbGUgb3RoZXIgcG9pbnRzIGFyZSBwcmludGVkIGluIFVuaWNvZGVcbiAqIGNvZGUgcG9pbnQgZm9ybSAoaWUuIFUrMTIzNCkuXG4gKi9cblxuZnVuY3Rpb24gcHJpbnRDb2RlUG9pbnRBdChsZXhlciwgbG9jYXRpb24pIHtcbiAgY29uc3QgY29kZSA9IGxleGVyLnNvdXJjZS5ib2R5LmNvZGVQb2ludEF0KGxvY2F0aW9uKTtcblxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFRva2VuS2luZC5FT0Y7XG4gIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMjAgJiYgY29kZSA8PSAweDAwN2UpIHtcbiAgICAvLyBQcmludGFibGUgQVNDSUlcbiAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgcmV0dXJuIGNoYXIgPT09ICdcIicgPyBcIidcXFwiJ1wiIDogYFwiJHtjaGFyfVwiYDtcbiAgfSAvLyBVbmljb2RlIGNvZGUgcG9pbnRcblxuICByZXR1cm4gJ1UrJyArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoNCwgJzAnKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdG9rZW4gd2l0aCBsaW5lIGFuZCBjb2x1bW4gbG9jYXRpb24gaW5mb3JtYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVG9rZW4obGV4ZXIsIGtpbmQsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG4gIGNvbnN0IGxpbmUgPSBsZXhlci5saW5lO1xuICBjb25zdCBjb2wgPSAxICsgc3RhcnQgLSBsZXhlci5saW5lU3RhcnQ7XG4gIHJldHVybiBuZXcgVG9rZW4oa2luZCwgc3RhcnQsIGVuZCwgbGluZSwgY29sLCB2YWx1ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgc291cmNlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAqXG4gKiBUaGlzIHNraXBzIG92ZXIgd2hpdGVzcGFjZSB1bnRpbCBpdCBmaW5kcyB0aGUgbmV4dCBsZXhhYmxlIHRva2VuLCB0aGVuIGxleGVzXG4gKiBwdW5jdHVhdG9ycyBpbW1lZGlhdGVseSBvciBjYWxscyB0aGUgYXBwcm9wcmlhdGUgaGVscGVyIGZ1bmN0aW9uIGZvciBtb3JlXG4gKiBjb21wbGljYXRlZCB0b2tlbnMuXG4gKi9cblxuZnVuY3Rpb24gcmVhZE5leHRUb2tlbihsZXhlciwgc3RhcnQpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBjb25zdCBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gIGxldCBwb3NpdGlvbiA9IHN0YXJ0O1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTsgLy8gU291cmNlQ2hhcmFjdGVyXG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIC8vIElnbm9yZWQgOjpcbiAgICAgIC8vICAgLSBVbmljb2RlQk9NXG4gICAgICAvLyAgIC0gV2hpdGVTcGFjZVxuICAgICAgLy8gICAtIExpbmVUZXJtaW5hdG9yXG4gICAgICAvLyAgIC0gQ29tbWVudFxuICAgICAgLy8gICAtIENvbW1hXG4gICAgICAvL1xuICAgICAgLy8gVW5pY29kZUJPTSA6OiBcIkJ5dGUgT3JkZXIgTWFyayAoVStGRUZGKVwiXG4gICAgICAvL1xuICAgICAgLy8gV2hpdGVTcGFjZSA6OlxuICAgICAgLy8gICAtIFwiSG9yaXpvbnRhbCBUYWIgKFUrMDAwOSlcIlxuICAgICAgLy8gICAtIFwiU3BhY2UgKFUrMDAyMClcIlxuICAgICAgLy9cbiAgICAgIC8vIENvbW1hIDo6ICxcbiAgICAgIGNhc2UgMHhmZWZmOiAvLyA8Qk9NPlxuXG4gICAgICBjYXNlIDB4MDAwOTogLy8gXFx0XG5cbiAgICAgIGNhc2UgMHgwMDIwOiAvLyA8c3BhY2U+XG5cbiAgICAgIGNhc2UgMHgwMDJjOlxuICAgICAgICAvLyAsXG4gICAgICAgICsrcG9zaXRpb247XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gTGluZVRlcm1pbmF0b3IgOjpcbiAgICAgIC8vICAgLSBcIk5ldyBMaW5lIChVKzAwMEEpXCJcbiAgICAgIC8vICAgLSBcIkNhcnJpYWdlIFJldHVybiAoVSswMDBEKVwiIFtsb29rYWhlYWQgIT0gXCJOZXcgTGluZSAoVSswMDBBKVwiXVxuICAgICAgLy8gICAtIFwiQ2FycmlhZ2UgUmV0dXJuIChVKzAwMEQpXCIgXCJOZXcgTGluZSAoVSswMDBBKVwiXG5cbiAgICAgIGNhc2UgMHgwMDBhOlxuICAgICAgICAvLyBcXG5cbiAgICAgICAgKytwb3NpdGlvbjtcbiAgICAgICAgKytsZXhlci5saW5lO1xuICAgICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgMHgwMDBkOlxuICAgICAgICAvLyBcXHJcbiAgICAgICAgaWYgKGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAweDAwMGEpIHtcbiAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICArK2xleGVyLmxpbmU7XG4gICAgICAgIGxleGVyLmxpbmVTdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIENvbW1lbnRcblxuICAgICAgY2FzZSAweDAwMjM6XG4gICAgICAgIC8vICNcbiAgICAgICAgcmV0dXJuIHJlYWRDb21tZW50KGxleGVyLCBwb3NpdGlvbik7XG4gICAgICAvLyBUb2tlbiA6OlxuICAgICAgLy8gICAtIFB1bmN0dWF0b3JcbiAgICAgIC8vICAgLSBOYW1lXG4gICAgICAvLyAgIC0gSW50VmFsdWVcbiAgICAgIC8vICAgLSBGbG9hdFZhbHVlXG4gICAgICAvLyAgIC0gU3RyaW5nVmFsdWVcbiAgICAgIC8vXG4gICAgICAvLyBQdW5jdHVhdG9yIDo6IG9uZSBvZiAhICQgJiAoICkgLi4uIDogPSBAIFsgXSB7IHwgfVxuXG4gICAgICBjYXNlIDB4MDAyMTpcbiAgICAgICAgLy8gIVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CQU5HLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwMjQ6XG4gICAgICAgIC8vICRcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuRE9MTEFSLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwMjY6XG4gICAgICAgIC8vICZcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQU1QLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwMjg6XG4gICAgICAgIC8vIChcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuUEFSRU5fTCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDI5OlxuICAgICAgICAvLyApXG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLlBBUkVOX1IsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDAyZTpcbiAgICAgICAgLy8gLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDB4MDAyZSAmJlxuICAgICAgICAgIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAweDAwMmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuU1BSRUFELCBwb3NpdGlvbiwgcG9zaXRpb24gKyAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MDAzYTpcbiAgICAgICAgLy8gOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5DT0xPTiwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDNkOlxuICAgICAgICAvLyA9XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkVRVUFMUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDQwOlxuICAgICAgICAvLyBAXG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkFULCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwNWI6XG4gICAgICAgIC8vIFtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQlJBQ0tFVF9MLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwNWQ6XG4gICAgICAgIC8vIF1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQlJBQ0tFVF9SLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcblxuICAgICAgY2FzZSAweDAwN2I6XG4gICAgICAgIC8vIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKGxleGVyLCBUb2tlbktpbmQuQlJBQ0VfTCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGNhc2UgMHgwMDdjOlxuICAgICAgICAvLyB8XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLlBJUEUsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDEpO1xuXG4gICAgICBjYXNlIDB4MDA3ZDpcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4obGV4ZXIsIFRva2VuS2luZC5CUkFDRV9SLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAxKTtcbiAgICAgIC8vIFN0cmluZ1ZhbHVlXG5cbiAgICAgIGNhc2UgMHgwMDIyOlxuICAgICAgICAvLyBcIlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDB4MDAyMiAmJlxuICAgICAgICAgIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpID09PSAweDAwMjJcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9ja1N0cmluZyhsZXhlciwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcobGV4ZXIsIHBvc2l0aW9uKTtcbiAgICB9IC8vIEludFZhbHVlIHwgRmxvYXRWYWx1ZSAoRGlnaXQgfCAtKVxuXG4gICAgaWYgKGlzRGlnaXQoY29kZSkgfHwgY29kZSA9PT0gMHgwMDJkKSB7XG4gICAgICByZXR1cm4gcmVhZE51bWJlcihsZXhlciwgcG9zaXRpb24sIGNvZGUpO1xuICAgIH0gLy8gTmFtZVxuXG4gICAgaWYgKGlzTmFtZVN0YXJ0KGNvZGUpKSB7XG4gICAgICByZXR1cm4gcmVhZE5hbWUobGV4ZXIsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY29kZSA9PT0gMHgwMDI3XG4gICAgICAgID8gJ1VuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoXFwnKSwgZGlkIHlvdSBtZWFuIHRvIHVzZSBhIGRvdWJsZSBxdW90ZSAoXCIpPydcbiAgICAgICAgOiBpc1VuaWNvZGVTY2FsYXJWYWx1ZShjb2RlKSB8fCBpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgcG9zaXRpb24pXG4gICAgICAgID8gYFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke3ByaW50Q29kZVBvaW50QXQobGV4ZXIsIHBvc2l0aW9uKX0uYFxuICAgICAgICA6IGBJbnZhbGlkIGNoYXJhY3RlcjogJHtwcmludENvZGVQb2ludEF0KGxleGVyLCBwb3NpdGlvbil9LmAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLkVPRiwgYm9keUxlbmd0aCwgYm9keUxlbmd0aCk7XG59XG4vKipcbiAqIFJlYWRzIGEgY29tbWVudCB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBgYGBcbiAqIENvbW1lbnQgOjogIyBDb21tZW50Q2hhciogW2xvb2thaGVhZCAhPSBDb21tZW50Q2hhcl1cbiAqXG4gKiBDb21tZW50Q2hhciA6OiBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBMaW5lVGVybWluYXRvclxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVhZENvbW1lbnQobGV4ZXIsIHN0YXJ0KSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDE7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pOyAvLyBMaW5lVGVybWluYXRvciAoXFxuIHwgXFxyKVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MDAwYSB8fCBjb2RlID09PSAweDAwMGQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gU291cmNlQ2hhcmFjdGVyXG5cbiAgICBpZiAoaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkpIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgcG9zaXRpb24pKSB7XG4gICAgICBwb3NpdGlvbiArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlVG9rZW4oXG4gICAgbGV4ZXIsXG4gICAgVG9rZW5LaW5kLkNPTU1FTlQsXG4gICAgc3RhcnQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keS5zbGljZShzdGFydCArIDEsIHBvc2l0aW9uKSxcbiAgKTtcbn1cbi8qKlxuICogUmVhZHMgYSBudW1iZXIgdG9rZW4gZnJvbSB0aGUgc291cmNlIGZpbGUsIGVpdGhlciBhIEZsb2F0VmFsdWUgb3IgYW4gSW50VmFsdWVcbiAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgRnJhY3Rpb25hbFBhcnQgb3IgRXhwb25lbnRQYXJ0IGlzIGVuY291bnRlcmVkLlxuICpcbiAqIGBgYFxuICogSW50VmFsdWUgOjogSW50ZWdlclBhcnQgW2xvb2thaGVhZCAhPSB7RGlnaXQsIGAuYCwgTmFtZVN0YXJ0fV1cbiAqXG4gKiBJbnRlZ2VyUGFydCA6OlxuICogICAtIE5lZ2F0aXZlU2lnbj8gMFxuICogICAtIE5lZ2F0aXZlU2lnbj8gTm9uWmVyb0RpZ2l0IERpZ2l0KlxuICpcbiAqIE5lZ2F0aXZlU2lnbiA6OiAtXG4gKlxuICogTm9uWmVyb0RpZ2l0IDo6IERpZ2l0IGJ1dCBub3QgYDBgXG4gKlxuICogRmxvYXRWYWx1ZSA6OlxuICogICAtIEludGVnZXJQYXJ0IEZyYWN0aW9uYWxQYXJ0IEV4cG9uZW50UGFydCBbbG9va2FoZWFkICE9IHtEaWdpdCwgYC5gLCBOYW1lU3RhcnR9XVxuICogICAtIEludGVnZXJQYXJ0IEZyYWN0aW9uYWxQYXJ0IFtsb29rYWhlYWQgIT0ge0RpZ2l0LCBgLmAsIE5hbWVTdGFydH1dXG4gKiAgIC0gSW50ZWdlclBhcnQgRXhwb25lbnRQYXJ0IFtsb29rYWhlYWQgIT0ge0RpZ2l0LCBgLmAsIE5hbWVTdGFydH1dXG4gKlxuICogRnJhY3Rpb25hbFBhcnQgOjogLiBEaWdpdCtcbiAqXG4gKiBFeHBvbmVudFBhcnQgOjogRXhwb25lbnRJbmRpY2F0b3IgU2lnbj8gRGlnaXQrXG4gKlxuICogRXhwb25lbnRJbmRpY2F0b3IgOjogb25lIG9mIGBlYCBgRWBcbiAqXG4gKiBTaWduIDo6IG9uZSBvZiArIC1cbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHJlYWROdW1iZXIobGV4ZXIsIHN0YXJ0LCBmaXJzdENvZGUpIHtcbiAgY29uc3QgYm9keSA9IGxleGVyLnNvdXJjZS5ib2R5O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydDtcbiAgbGV0IGNvZGUgPSBmaXJzdENvZGU7XG4gIGxldCBpc0Zsb2F0ID0gZmFsc2U7IC8vIE5lZ2F0aXZlU2lnbiAoLSlcblxuICBpZiAoY29kZSA9PT0gMHgwMDJkKSB7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgfSAvLyBaZXJvICgwKVxuXG4gIGlmIChjb2RlID09PSAweDAwMzApIHtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuXG4gICAgaWYgKGlzRGlnaXQoY29kZSkpIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICBsZXhlci5zb3VyY2UsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBgSW52YWxpZCBudW1iZXIsIHVuZXhwZWN0ZWQgZGlnaXQgYWZ0ZXIgMDogJHtwcmludENvZGVQb2ludEF0KFxuICAgICAgICAgIGxleGVyLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICApfS5gLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKGxleGVyLCBwb3NpdGlvbiwgY29kZSk7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIH0gLy8gRnVsbCBzdG9wICguKVxuXG4gIGlmIChjb2RlID09PSAweDAwMmUpIHtcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgIHBvc2l0aW9uID0gcmVhZERpZ2l0cyhsZXhlciwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9IC8vIEUgZVxuXG4gIGlmIChjb2RlID09PSAweDAwNDUgfHwgY29kZSA9PT0gMHgwMDY1KSB7XG4gICAgaXNGbG9hdCA9IHRydWU7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTsgLy8gKyAtXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDJiIHx8IGNvZGUgPT09IDB4MDAyZCkge1xuICAgICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbiA9IHJlYWREaWdpdHMobGV4ZXIsIHBvc2l0aW9uLCBjb2RlKTtcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgfSAvLyBOdW1iZXJzIGNhbm5vdCBiZSBmb2xsb3dlZCBieSAuIG9yIE5hbWVTdGFydFxuXG4gIGlmIChjb2RlID09PSAweDAwMmUgfHwgaXNOYW1lU3RhcnQoY29kZSkpIHtcbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgIGxleGVyLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICl9LmAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUb2tlbihcbiAgICBsZXhlcixcbiAgICBpc0Zsb2F0ID8gVG9rZW5LaW5kLkZMT0FUIDogVG9rZW5LaW5kLklOVCxcbiAgICBzdGFydCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbiksXG4gICk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGFmdGVyIHJlYWRpbmcgb25lIG9yIG1vcmUgZGlnaXRzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWREaWdpdHMobGV4ZXIsIHN0YXJ0LCBmaXJzdENvZGUpIHtcbiAgaWYgKCFpc0RpZ2l0KGZpcnN0Q29kZSkpIHtcbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgIGxleGVyLFxuICAgICAgICBzdGFydCxcbiAgICAgICl9LmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQgKyAxOyAvLyArMSB0byBza2lwIGZpcnN0IGZpcnN0Q29kZVxuXG4gIHdoaWxlIChpc0RpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbikpKSB7XG4gICAgKytwb3NpdGlvbjtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbjtcbn1cbi8qKlxuICogUmVhZHMgYSBzaW5nbGUtcXVvdGUgc3RyaW5nIHRva2VuIGZyb20gdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIGBgYFxuICogU3RyaW5nVmFsdWUgOjpcbiAqICAgLSBgXCJcImAgW2xvb2thaGVhZCAhPSBgXCJgXVxuICogICAtIGBcImAgU3RyaW5nQ2hhcmFjdGVyKyBgXCJgXG4gKlxuICogU3RyaW5nQ2hhcmFjdGVyIDo6XG4gKiAgIC0gU291cmNlQ2hhcmFjdGVyIGJ1dCBub3QgYFwiYCBvciBgXFxgIG9yIExpbmVUZXJtaW5hdG9yXG4gKiAgIC0gYFxcdWAgRXNjYXBlZFVuaWNvZGVcbiAqICAgLSBgXFxgIEVzY2FwZWRDaGFyYWN0ZXJcbiAqXG4gKiBFc2NhcGVkVW5pY29kZSA6OlxuICogICAtIGB7YCBIZXhEaWdpdCsgYH1gXG4gKiAgIC0gSGV4RGlnaXQgSGV4RGlnaXQgSGV4RGlnaXQgSGV4RGlnaXRcbiAqXG4gKiBFc2NhcGVkQ2hhcmFjdGVyIDo6IG9uZSBvZiBgXCJgIGBcXGAgYC9gIGBiYCBgZmAgYG5gIGByYCBgdGBcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmcobGV4ZXIsIHN0YXJ0KSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDE7XG4gIGxldCBjaHVua1N0YXJ0ID0gcG9zaXRpb247XG4gIGxldCB2YWx1ZSA9ICcnO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTsgLy8gQ2xvc2luZyBRdW90ZSAoXCIpXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDIyKSB7XG4gICAgICB2YWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBjcmVhdGVUb2tlbihsZXhlciwgVG9rZW5LaW5kLlNUUklORywgc3RhcnQsIHBvc2l0aW9uICsgMSwgdmFsdWUpO1xuICAgIH0gLy8gRXNjYXBlIFNlcXVlbmNlIChcXClcblxuICAgIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhbHVlICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgY29uc3QgZXNjYXBlID1cbiAgICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDB4MDA3NSAvLyB1XG4gICAgICAgICAgPyBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAyKSA9PT0gMHgwMDdiIC8vIHtcbiAgICAgICAgICAgID8gcmVhZEVzY2FwZWRVbmljb2RlVmFyaWFibGVXaWR0aChsZXhlciwgcG9zaXRpb24pXG4gICAgICAgICAgICA6IHJlYWRFc2NhcGVkVW5pY29kZUZpeGVkV2lkdGgobGV4ZXIsIHBvc2l0aW9uKVxuICAgICAgICAgIDogcmVhZEVzY2FwZWRDaGFyYWN0ZXIobGV4ZXIsIHBvc2l0aW9uKTtcbiAgICAgIHZhbHVlICs9IGVzY2FwZS52YWx1ZTtcbiAgICAgIHBvc2l0aW9uICs9IGVzY2FwZS5zaXplO1xuICAgICAgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBMaW5lVGVybWluYXRvciAoXFxuIHwgXFxyKVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MDAwYSB8fCBjb2RlID09PSAweDAwMGQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gU291cmNlQ2hhcmFjdGVyXG5cbiAgICBpZiAoaXNVbmljb2RlU2NhbGFyVmFsdWUoY29kZSkpIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChpc1N1cHBsZW1lbnRhcnlDb2RlUG9pbnQoYm9keSwgcG9zaXRpb24pKSB7XG4gICAgICBwb3NpdGlvbiArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgbGV4ZXIuc291cmNlLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgYEludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6ICR7cHJpbnRDb2RlUG9pbnRBdChcbiAgICAgICAgICBsZXhlcixcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgKX0uYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3IobGV4ZXIuc291cmNlLCBwb3NpdGlvbiwgJ1VudGVybWluYXRlZCBzdHJpbmcuJyk7XG59IC8vIFRoZSBzdHJpbmcgdmFsdWUgYW5kIGxleGVkIHNpemUgb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuXG5mdW5jdGlvbiByZWFkRXNjYXBlZFVuaWNvZGVWYXJpYWJsZVdpZHRoKGxleGVyLCBwb3NpdGlvbikge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGxldCBwb2ludCA9IDA7XG4gIGxldCBzaXplID0gMzsgLy8gQ2Fubm90IGJlIGxhcmdlciB0aGFuIDEyIGNoYXJzIChcXHV7MDAwMDAwMDB9KS5cblxuICB3aGlsZSAoc2l6ZSA8IDEyKSB7XG4gICAgY29uc3QgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIHNpemUrKyk7IC8vIENsb3NpbmcgQnJhY2UgKH0pXG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDdkKSB7XG4gICAgICAvLyBNdXN0IGJlIGF0IGxlYXN0IDUgY2hhcnMgKFxcdXswfSkgYW5kIGVuY29kZSBhIFVuaWNvZGUgc2NhbGFyIHZhbHVlLlxuICAgICAgaWYgKHNpemUgPCA1IHx8ICFpc1VuaWNvZGVTY2FsYXJWYWx1ZShwb2ludCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNvZGVQb2ludChwb2ludCksXG4gICAgICAgIHNpemUsXG4gICAgICB9O1xuICAgIH0gLy8gQXBwZW5kIHRoaXMgaGV4IGRpZ2l0IHRvIHRoZSBjb2RlIHBvaW50LlxuXG4gICAgcG9pbnQgPSAocG9pbnQgPDwgNCkgfCByZWFkSGV4RGlnaXQoY29kZSk7XG5cbiAgICBpZiAocG9pbnQgPCAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICBsZXhlci5zb3VyY2UsXG4gICAgcG9zaXRpb24sXG4gICAgYEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2U6IFwiJHtib2R5LnNsaWNlKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiArIHNpemUsXG4gICAgKX1cIi5gLFxuICApO1xufVxuXG5mdW5jdGlvbiByZWFkRXNjYXBlZFVuaWNvZGVGaXhlZFdpZHRoKGxleGVyLCBwb3NpdGlvbikge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGNvZGUgPSByZWFkMTZCaXRIZXhDb2RlKGJvZHksIHBvc2l0aW9uICsgMik7XG5cbiAgaWYgKGlzVW5pY29kZVNjYWxhclZhbHVlKGNvZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSxcbiAgICAgIHNpemU6IDYsXG4gICAgfTtcbiAgfSAvLyBHcmFwaFFMIGFsbG93cyBKU09OLXN0eWxlIHN1cnJvZ2F0ZSBwYWlyIGVzY2FwZSBzZXF1ZW5jZXMsIGJ1dCBvbmx5IHdoZW5cbiAgLy8gYSB2YWxpZCBwYWlyIGlzIGZvcm1lZC5cblxuICBpZiAoaXNMZWFkaW5nU3Vycm9nYXRlKGNvZGUpKSB7XG4gICAgLy8gXFx1XG4gICAgaWYgKFxuICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgNikgPT09IDB4MDA1YyAmJlxuICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgNykgPT09IDB4MDA3NVxuICAgICkge1xuICAgICAgY29uc3QgdHJhaWxpbmdDb2RlID0gcmVhZDE2Qml0SGV4Q29kZShib2R5LCBwb3NpdGlvbiArIDgpO1xuXG4gICAgICBpZiAoaXNUcmFpbGluZ1N1cnJvZ2F0ZSh0cmFpbGluZ0NvZGUpKSB7XG4gICAgICAgIC8vIEphdmFTY3JpcHQgZGVmaW5lcyBzdHJpbmdzIGFzIGEgc2VxdWVuY2Ugb2YgVVRGLTE2IGNvZGUgdW5pdHMgYW5kXG4gICAgICAgIC8vIGVuY29kZXMgVW5pY29kZSBjb2RlIHBvaW50cyBhYm92ZSBVK0ZGRkYgdXNpbmcgYSBzdXJyb2dhdGUgcGFpciBvZlxuICAgICAgICAvLyBjb2RlIHVuaXRzLiBTaW5jZSB0aGlzIGlzIGEgc3Vycm9nYXRlIHBhaXIgZXNjYXBlIHNlcXVlbmNlLCBqdXN0XG4gICAgICAgIC8vIGluY2x1ZGUgYm90aCBjb2RlcyBpbnRvIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB2YWx1ZS4gSGFkIEphdmFTY3JpcHRcbiAgICAgICAgLy8gbm90IGJlZW4gaW50ZXJuYWxseSBiYXNlZCBvbiBVVEYtMTYsIHRoZW4gdGhpcyBzdXJyb2dhdGUgcGFpciB3b3VsZFxuICAgICAgICAvLyBiZSBkZWNvZGVkIHRvIHJldHJpZXZlIHRoZSBzdXBwbGVtZW50YXJ5IGNvZGUgcG9pbnQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUsIHRyYWlsaW5nQ29kZSksXG4gICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgbGV4ZXIuc291cmNlLFxuICAgIHBvc2l0aW9uLFxuICAgIGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiBcIiR7Ym9keS5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA2KX1cIi5gLFxuICApO1xufVxuLyoqXG4gKiBSZWFkcyBmb3VyIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgdGhlIHBvc2l0aXZlIGludGVnZXIgdGhhdCAxNmJpdFxuICogaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudHMuIEZvciBleGFtcGxlLCBcIjAwMGZcIiB3aWxsIHJldHVybiAxNSwgYW5kIFwiZGVhZFwiXG4gKiB3aWxsIHJldHVybiA1NzAwNS5cbiAqXG4gKiBSZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyIGlmIGFueSBjaGFyIHdhcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBkaWdpdC5cbiAqL1xuXG5mdW5jdGlvbiByZWFkMTZCaXRIZXhDb2RlKGJvZHksIHBvc2l0aW9uKSB7XG4gIC8vIHJlYWRIZXhEaWdpdCgpIHJldHVybnMgLTEgb24gZXJyb3IuIE9SaW5nIGEgbmVnYXRpdmUgdmFsdWUgd2l0aCBhbnkgb3RoZXJcbiAgLy8gdmFsdWUgYWx3YXlzIHByb2R1Y2VzIGEgbmVnYXRpdmUgdmFsdWUuXG4gIHJldHVybiAoXG4gICAgKHJlYWRIZXhEaWdpdChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pKSA8PCAxMikgfFxuICAgIChyZWFkSGV4RGlnaXQoYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDw8IDgpIHxcbiAgICAocmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDIpKSA8PCA0KSB8XG4gICAgcmVhZEhleERpZ2l0KGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDMpKVxuICApO1xufVxuLyoqXG4gKiBSZWFkcyBhIGhleGFkZWNpbWFsIGNoYXJhY3RlciBhbmQgcmV0dXJucyBpdHMgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZSAoMC0xNSkuXG4gKlxuICogJzAnIGJlY29tZXMgMCwgJzknIGJlY29tZXMgOVxuICogJ0EnIGJlY29tZXMgMTAsICdGJyBiZWNvbWVzIDE1XG4gKiAnYScgYmVjb21lcyAxMCwgJ2YnIGJlY29tZXMgMTVcbiAqXG4gKiBSZXR1cm5zIC0xIGlmIHRoZSBwcm92aWRlZCBjaGFyYWN0ZXIgY29kZSB3YXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgZGlnaXQuXG4gKlxuICogSGV4RGlnaXQgOjogb25lIG9mXG4gKiAgIC0gYDBgIGAxYCBgMmAgYDNgIGA0YCBgNWAgYDZgIGA3YCBgOGAgYDlgXG4gKiAgIC0gYEFgIGBCYCBgQ2AgYERgIGBFYCBgRmBcbiAqICAgLSBgYWAgYGJgIGBjYCBgZGAgYGVgIGBmYFxuICovXG5cbmZ1bmN0aW9uIHJlYWRIZXhEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSAvLyAwLTlcbiAgICA/IGNvZGUgLSAweDAwMzBcbiAgICA6IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDQ2IC8vIEEtRlxuICAgID8gY29kZSAtIDB4MDAzN1xuICAgIDogY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwNjYgLy8gYS1mXG4gICAgPyBjb2RlIC0gMHgwMDU3XG4gICAgOiAtMTtcbn1cbi8qKlxuICogfCBFc2NhcGVkIENoYXJhY3RlciB8IENvZGUgUG9pbnQgfCBDaGFyYWN0ZXIgTmFtZSAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBcImAgICAgICAgICAgICAgICB8IFUrMDAyMiAgICAgfCBkb3VibGUgcXVvdGUgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFxcYCAgICAgICAgICAgICAgIHwgVSswMDVDICAgICB8IHJldmVyc2Ugc29saWR1cyAoYmFjayBzbGFzaCkgfFxuICogfCBgL2AgICAgICAgICAgICAgICB8IFUrMDAyRiAgICAgfCBzb2xpZHVzIChmb3J3YXJkIHNsYXNoKSAgICAgIHxcbiAqIHwgYGJgICAgICAgICAgICAgICAgfCBVKzAwMDggICAgIHwgYmFja3NwYWNlICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGBmYCAgICAgICAgICAgICAgIHwgVSswMDBDICAgICB8IGZvcm0gZmVlZCAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgbmAgICAgICAgICAgICAgICB8IFUrMDAwQSAgICAgfCBsaW5lIGZlZWQgKG5ldyBsaW5lKSAgICAgICAgIHxcbiAqIHwgYHJgICAgICAgICAgICAgICAgfCBVKzAwMEQgICAgIHwgY2FycmlhZ2UgcmV0dXJuICAgICAgICAgICAgICB8XG4gKiB8IGB0YCAgICAgICAgICAgICAgIHwgVSswMDA5ICAgICB8IGhvcml6b250YWwgdGFiICAgICAgICAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIHJlYWRFc2NhcGVkQ2hhcmFjdGVyKGxleGVyLCBwb3NpdGlvbikge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKTtcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDAyMjpcbiAgICAgIC8vIFwiXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1xcdTAwMjInLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgfTtcblxuICAgIGNhc2UgMHgwMDVjOlxuICAgICAgLy8gXFxcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDA1YycsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuXG4gICAgY2FzZSAweDAwMmY6XG4gICAgICAvLyAvXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1xcdTAwMmYnLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgfTtcblxuICAgIGNhc2UgMHgwMDYyOlxuICAgICAgLy8gYlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6ICdcXHUwMDA4JyxcbiAgICAgICAgc2l6ZTogMixcbiAgICAgIH07XG5cbiAgICBjYXNlIDB4MDA2NjpcbiAgICAgIC8vIGZcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDAwYycsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuXG4gICAgY2FzZSAweDAwNmU6XG4gICAgICAvLyBuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogJ1xcdTAwMGEnLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgfTtcblxuICAgIGNhc2UgMHgwMDcyOlxuICAgICAgLy8gclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6ICdcXHUwMDBkJyxcbiAgICAgICAgc2l6ZTogMixcbiAgICAgIH07XG5cbiAgICBjYXNlIDB4MDA3NDpcbiAgICAgIC8vIHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAnXFx1MDAwOScsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICB9O1xuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgbGV4ZXIuc291cmNlLFxuICAgIHBvc2l0aW9uLFxuICAgIGBJbnZhbGlkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2U6IFwiJHtib2R5LnNsaWNlKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiArIDIsXG4gICAgKX1cIi5gLFxuICApO1xufVxuLyoqXG4gKiBSZWFkcyBhIGJsb2NrIHN0cmluZyB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBgYGBcbiAqIFN0cmluZ1ZhbHVlIDo6XG4gKiAgIC0gYFwiXCJcImAgQmxvY2tTdHJpbmdDaGFyYWN0ZXIqIGBcIlwiXCJgXG4gKlxuICogQmxvY2tTdHJpbmdDaGFyYWN0ZXIgOjpcbiAqICAgLSBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBgXCJcIlwiYCBvciBgXFxcIlwiXCJgXG4gKiAgIC0gYFxcXCJcIlwiYFxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVhZEJsb2NrU3RyaW5nKGxleGVyLCBzdGFydCkge1xuICBjb25zdCBib2R5ID0gbGV4ZXIuc291cmNlLmJvZHk7XG4gIGNvbnN0IGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgbGV0IGxpbmVTdGFydCA9IGxleGVyLmxpbmVTdGFydDtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQgKyAzO1xuICBsZXQgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICBsZXQgY3VycmVudExpbmUgPSAnJztcbiAgY29uc3QgYmxvY2tMaW5lcyA9IFtdO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTsgLy8gQ2xvc2luZyBUcmlwbGUtUXVvdGUgKFwiXCJcIilcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IDB4MDAyMiAmJlxuICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgPT09IDB4MDAyMiAmJlxuICAgICAgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDB4MDAyMlxuICAgICkge1xuICAgICAgY3VycmVudExpbmUgKz0gYm9keS5zbGljZShjaHVua1N0YXJ0LCBwb3NpdGlvbik7XG4gICAgICBibG9ja0xpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihcbiAgICAgICAgbGV4ZXIsXG4gICAgICAgIFRva2VuS2luZC5CTE9DS19TVFJJTkcsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwb3NpdGlvbiArIDMsIC8vIFJldHVybiBhIHN0cmluZyBvZiB0aGUgbGluZXMgam9pbmVkIHdpdGggVSswMDBBLlxuICAgICAgICBkZWRlbnRCbG9ja1N0cmluZ0xpbmVzKGJsb2NrTGluZXMpLmpvaW4oJ1xcbicpLFxuICAgICAgKTtcbiAgICAgIGxleGVyLmxpbmUgKz0gYmxvY2tMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgbGV4ZXIubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0gLy8gRXNjYXBlZCBUcmlwbGUtUXVvdGUgKFxcXCJcIlwiKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gMHgwMDVjICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDIyICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAyKSA9PT0gMHgwMDIyICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAzKSA9PT0gMHgwMDIyXG4gICAgKSB7XG4gICAgICBjdXJyZW50TGluZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3NpdGlvbiArIDE7IC8vIHNraXAgb25seSBzbGFzaFxuXG4gICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBMaW5lVGVybWluYXRvclxuXG4gICAgaWYgKGNvZGUgPT09IDB4MDAwYSB8fCBjb2RlID09PSAweDAwMGQpIHtcbiAgICAgIGN1cnJlbnRMaW5lICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgYmxvY2tMaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcblxuICAgICAgaWYgKGNvZGUgPT09IDB4MDAwZCAmJiBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMHgwMDBhKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGluZSA9ICcnO1xuICAgICAgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICAgICAgbGluZVN0YXJ0ID0gcG9zaXRpb247XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFNvdXJjZUNoYXJhY3RlclxuXG4gICAgaWYgKGlzVW5pY29kZVNjYWxhclZhbHVlKGNvZGUpKSB7XG4gICAgICArK3Bvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNTdXBwbGVtZW50YXJ5Q29kZVBvaW50KGJvZHksIHBvc2l0aW9uKSkge1xuICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXG4gICAgICAgIGxleGVyLnNvdXJjZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGBJbnZhbGlkIGNoYXJhY3RlciB3aXRoaW4gU3RyaW5nOiAke3ByaW50Q29kZVBvaW50QXQoXG4gICAgICAgICAgbGV4ZXIsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICl9LmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IHN5bnRheEVycm9yKGxleGVyLnNvdXJjZSwgcG9zaXRpb24sICdVbnRlcm1pbmF0ZWQgc3RyaW5nLicpO1xufVxuLyoqXG4gKiBSZWFkcyBhbiBhbHBoYW51bWVyaWMgKyB1bmRlcnNjb3JlIG5hbWUgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIGBgYFxuICogTmFtZSA6OlxuICogICAtIE5hbWVTdGFydCBOYW1lQ29udGludWUqIFtsb29rYWhlYWQgIT0gTmFtZUNvbnRpbnVlXVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVhZE5hbWUobGV4ZXIsIHN0YXJ0KSB7XG4gIGNvbnN0IGJvZHkgPSBsZXhlci5zb3VyY2UuYm9keTtcbiAgY29uc3QgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICBsZXQgcG9zaXRpb24gPSBzdGFydCArIDE7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgYm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXG4gICAgaWYgKGlzTmFtZUNvbnRpbnVlKGNvZGUpKSB7XG4gICAgICArK3Bvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlVG9rZW4oXG4gICAgbGV4ZXIsXG4gICAgVG9rZW5LaW5kLk5BTUUsXG4gICAgc3RhcnQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keS5zbGljZShzdGFydCwgcG9zaXRpb24pLFxuICApO1xufVxuIiwgImNvbnN0IE1BWF9BUlJBWV9MRU5HVEggPSAxMDtcbmNvbnN0IE1BWF9SRUNVUlNJVkVfREVQVEggPSAyO1xuLyoqXG4gKiBVc2VkIHRvIHByaW50IHZhbHVlcyBpbiBlcnJvciBtZXNzYWdlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSkge1xuICByZXR1cm4gZm9ybWF0VmFsdWUodmFsdWUsIFtdKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB2YWx1ZS5uYW1lID8gYFtmdW5jdGlvbiAke3ZhbHVlLm5hbWV9XWAgOiAnW2Z1bmN0aW9uXSc7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRPYmplY3RWYWx1ZSh2YWx1ZSwgcHJldmlvdXNseVNlZW5WYWx1ZXMpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIGlmIChwcmV2aW91c2x5U2VlblZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgY29uc3Qgc2VlblZhbHVlcyA9IFsuLi5wcmV2aW91c2x5U2VlblZhbHVlcywgdmFsdWVdO1xuXG4gIGlmIChpc0pTT05hYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGpzb25WYWx1ZSA9IHZhbHVlLnRvSlNPTigpOyAvLyBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG5cbiAgICBpZiAoanNvblZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBqc29uVmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgID8ganNvblZhbHVlXG4gICAgICAgIDogZm9ybWF0VmFsdWUoanNvblZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXkodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdE9iamVjdCh2YWx1ZSwgc2VlblZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIGlzSlNPTmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmplY3QsIHNlZW5WYWx1ZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdCk7XG5cbiAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICd7fSc7XG4gIH1cblxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuICdbJyArIGdldE9iamVjdFRhZyhvYmplY3QpICsgJ10nO1xuICB9XG5cbiAgY29uc3QgcHJvcGVydGllcyA9IGVudHJpZXMubWFwKFxuICAgIChba2V5LCB2YWx1ZV0pID0+IGtleSArICc6ICcgKyBmb3JtYXRWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcyksXG4gICk7XG4gIHJldHVybiAneyAnICsgcHJvcGVydGllcy5qb2luKCcsICcpICsgJyB9Jztcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoYXJyYXksIHNlZW5WYWx1ZXMpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnW10nO1xuICB9XG5cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiAnW0FycmF5XSc7XG4gIH1cblxuICBjb25zdCBsZW4gPSBNYXRoLm1pbihNQVhfQVJSQVlfTEVOR1RILCBhcnJheS5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSBhcnJheS5sZW5ndGggLSBsZW47XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGl0ZW1zLnB1c2goZm9ybWF0VmFsdWUoYXJyYXlbaV0sIHNlZW5WYWx1ZXMpKTtcbiAgfVxuXG4gIGlmIChyZW1haW5pbmcgPT09IDEpIHtcbiAgICBpdGVtcy5wdXNoKCcuLi4gMSBtb3JlIGl0ZW0nKTtcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAxKSB7XG4gICAgaXRlbXMucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW1zYCk7XG4gIH1cblxuICByZXR1cm4gJ1snICsgaXRlbXMuam9pbignLCAnKSArICddJztcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0VGFnKG9iamVjdCkge1xuICBjb25zdCB0YWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqZWN0KVxuICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0IC8sICcnKVxuICAgIC5yZXBsYWNlKC9dJC8sICcnKTtcblxuICBpZiAodGFnID09PSAnT2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lICE9PSAnJykge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhZztcbn1cbiIsICJpbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnLi9pbnNwZWN0Lm1qcyc7XG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG5cbmNvbnN0IGlzUHJvZHVjdGlvbiA9XG4gIGdsb2JhbFRoaXMucHJvY2VzcyAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbi8qKlxuICogQSByZXBsYWNlbWVudCBmb3IgaW5zdGFuY2VvZiB3aGljaCBpbmNsdWRlcyBhbiBlcnJvciB3YXJuaW5nIHdoZW4gbXVsdGktcmVhbG1cbiAqIGNvbnN0cnVjdG9ycyBhcmUgZGV0ZWN0ZWQuXG4gKiBTZWU6IGh0dHBzOi8vZXhwcmVzc2pzLmNvbS9lbi9hZHZhbmNlZC9iZXN0LXByYWN0aWNlLXBlcmZvcm1hbmNlLmh0bWwjc2V0LW5vZGVfZW52LXRvLXByb2R1Y3Rpb25cbiAqIFNlZTogaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvcHJvZHVjdGlvbi9cbiAqL1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VPZiA9XG4gIC8qIGM4IGlnbm9yZSBuZXh0IDYgKi9cbiAgLy8gRklYTUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtanMvaXNzdWVzLzIzMTdcbiAgaXNQcm9kdWN0aW9uXG4gICAgPyBmdW5jdGlvbiBpbnN0YW5jZU9mKHZhbHVlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcjtcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uIGluc3RhbmNlT2YodmFsdWUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfdmFsdWUkY29uc3RydWN0b3I7XG5cbiAgICAgICAgICAvLyBQcmVmZXIgU3ltYm9sLnRvU3RyaW5nVGFnIHNpbmNlIGl0IGlzIGltbXVuZSB0byBtaW5pZmljYXRpb24uXG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY29uc3RydWN0b3IucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICAgICAgY29uc3QgdmFsdWVDbGFzc05hbWUgPSAvLyBXZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgY29uc3RydWN0b3IncyBuYW1lIHRvIGRldGVjdCBjb25mbGljdHMgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBidWcgc2VlLCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM4MDA5XG4gICAgICAgICAgICAgID8gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXVxuICAgICAgICAgICAgICA6IChfdmFsdWUkY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBfdmFsdWUkY29uc3RydWN0b3IgPT09IHZvaWQgMFxuICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICA6IF92YWx1ZSRjb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gdmFsdWVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBpbnNwZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSAke2NsYXNzTmFtZX0gXCIke3N0cmluZ2lmaWVkVmFsdWV9XCIgZnJvbSBhbm90aGVyIG1vZHVsZSBvciByZWFsbS5cblxuRW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgaW5zdGFuY2Ugb2YgXCJncmFwaHFsXCIgaW4gdGhlIG5vZGVfbW9kdWxlc1xuZGlyZWN0b3J5LiBJZiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgXCJncmFwaHFsXCIgYXJlIHRoZSBkZXBlbmRlbmNpZXMgb2Ygb3RoZXJcbnJlbGllZCBvbiBtb2R1bGVzLCB1c2UgXCJyZXNvbHV0aW9uc1wiIHRvIGVuc3VyZSBvbmx5IG9uZSB2ZXJzaW9uIGlzIGluc3RhbGxlZC5cblxuaHR0cHM6Ly95YXJucGtnLmNvbS9lbi9kb2NzL3NlbGVjdGl2ZS12ZXJzaW9uLXJlc29sdXRpb25zXG5cbkR1cGxpY2F0ZSBcImdyYXBocWxcIiBtb2R1bGVzIGNhbm5vdCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUgc2luY2UgZGlmZmVyZW50XG52ZXJzaW9ucyBtYXkgaGF2ZSBkaWZmZXJlbnQgY2FwYWJpbGl0aWVzIGFuZCBiZWhhdmlvci4gVGhlIGRhdGEgZnJvbSBvbmVcbnZlcnNpb24gdXNlZCBpbiB0aGUgZnVuY3Rpb24gZnJvbSBhbm90aGVyIGNvdWxkIHByb2R1Y2UgY29uZnVzaW5nIGFuZFxuc3B1cmlvdXMgcmVzdWx0cy5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuIiwgImltcG9ydCB7IGRldkFzc2VydCB9IGZyb20gJy4uL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qcyc7XG5pbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnLi4vanN1dGlscy9pbnNwZWN0Lm1qcyc7XG5pbXBvcnQgeyBpbnN0YW5jZU9mIH0gZnJvbSAnLi4vanN1dGlscy9pbnN0YW5jZU9mLm1qcyc7XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBzb3VyY2UgaW5wdXQgdG8gR3JhcGhRTC4gVGhlIGBuYW1lYCBhbmQgYGxvY2F0aW9uT2Zmc2V0YCBwYXJhbWV0ZXJzIGFyZVxuICogb3B0aW9uYWwsIGJ1dCB0aGV5IGFyZSB1c2VmdWwgZm9yIGNsaWVudHMgd2hvIHN0b3JlIEdyYXBoUUwgZG9jdW1lbnRzIGluIHNvdXJjZSBmaWxlcy5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgR3JhcGhRTCBpbnB1dCBzdGFydHMgYXQgbGluZSA0MCBpbiBhIGZpbGUgbmFtZWQgYEZvby5ncmFwaHFsYCwgaXQgbWlnaHRcbiAqIGJlIHVzZWZ1bCBmb3IgYG5hbWVgIHRvIGJlIGBcIkZvby5ncmFwaHFsXCJgIGFuZCBsb2NhdGlvbiB0byBiZSBgeyBsaW5lOiA0MCwgY29sdW1uOiAxIH1gLlxuICogVGhlIGBsaW5lYCBhbmQgYGNvbHVtbmAgcHJvcGVydGllcyBpbiBgbG9jYXRpb25PZmZzZXRgIGFyZSAxLWluZGV4ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBib2R5LFxuICAgIG5hbWUgPSAnR3JhcGhRTCByZXF1ZXN0JyxcbiAgICBsb2NhdGlvbk9mZnNldCA9IHtcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDEsXG4gICAgfSxcbiAgKSB7XG4gICAgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnIHx8XG4gICAgICBkZXZBc3NlcnQoZmFsc2UsIGBCb2R5IG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkOiAke2luc3BlY3QoYm9keSl9LmApO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmxvY2F0aW9uT2Zmc2V0ID0gbG9jYXRpb25PZmZzZXQ7XG4gICAgdGhpcy5sb2NhdGlvbk9mZnNldC5saW5lID4gMCB8fFxuICAgICAgZGV2QXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2xpbmUgaW4gbG9jYXRpb25PZmZzZXQgaXMgMS1pbmRleGVkIGFuZCBtdXN0IGJlIHBvc2l0aXZlLicsXG4gICAgICApO1xuICAgIHRoaXMubG9jYXRpb25PZmZzZXQuY29sdW1uID4gMCB8fFxuICAgICAgZGV2QXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2NvbHVtbiBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuJyxcbiAgICAgICk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdTb3VyY2UnO1xuICB9XG59XG4vKipcbiAqIFRlc3QgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgU291cmNlIG9iamVjdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTb3VyY2Uoc291cmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKHNvdXJjZSwgU291cmNlKTtcbn1cbiIsICJpbXBvcnQgeyBzeW50YXhFcnJvciB9IGZyb20gJy4uL2Vycm9yL3N5bnRheEVycm9yLm1qcyc7XG5pbXBvcnQgeyBMb2NhdGlvbiwgT3BlcmF0aW9uVHlwZU5vZGUgfSBmcm9tICcuL2FzdC5tanMnO1xuaW1wb3J0IHsgRGlyZWN0aXZlTG9jYXRpb24gfSBmcm9tICcuL2RpcmVjdGl2ZUxvY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBLaW5kIH0gZnJvbSAnLi9raW5kcy5tanMnO1xuaW1wb3J0IHsgaXNQdW5jdHVhdG9yVG9rZW5LaW5kLCBMZXhlciB9IGZyb20gJy4vbGV4ZXIubWpzJztcbmltcG9ydCB7IGlzU291cmNlLCBTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS5tanMnO1xuaW1wb3J0IHsgVG9rZW5LaW5kIH0gZnJvbSAnLi90b2tlbktpbmQubWpzJztcbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIHRvIGNvbnRyb2wgcGFyc2VyIGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBHaXZlbiBhIEdyYXBoUUwgc291cmNlLCBwYXJzZXMgaXQgaW50byBhIERvY3VtZW50LlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRvY3VtZW50ID0gcGFyc2VyLnBhcnNlRG9jdW1lbnQoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAndG9rZW5Db3VudCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogcGFyc2VyLnRva2VuQ291bnQsXG4gIH0pO1xuICByZXR1cm4gZG9jdW1lbnQ7XG59XG4vKipcbiAqIEdpdmVuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBHcmFwaFFMIHZhbHVlIChleC4gYFs0Ml1gKSwgcGFyc2UgdGhlIEFTVCBmb3JcbiAqIHRoYXQgdmFsdWUuXG4gKiBUaHJvd3MgR3JhcGhRTEVycm9yIGlmIGEgc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdpdGhpbiB0b29scyB0aGF0IG9wZXJhdGUgdXBvbiBHcmFwaFFMIFZhbHVlcyBkaXJlY3RseSBhbmRcbiAqIGluIGlzb2xhdGlvbiBvZiBjb21wbGV0ZSBHcmFwaFFMIGRvY3VtZW50cy5cbiAqXG4gKiBDb25zaWRlciBwcm92aWRpbmcgdGhlIHJlc3VsdHMgdG8gdGhlIHV0aWxpdHkgZnVuY3Rpb246IHZhbHVlRnJvbUFTVCgpLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZhbHVlKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuU09GKTtcbiAgY29uc3QgdmFsdWUgPSBwYXJzZXIucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkVPRik7XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogU2ltaWxhciB0byBwYXJzZVZhbHVlKCksIGJ1dCByYWlzZXMgYSBwYXJzZSBlcnJvciBpZiBpdCBlbmNvdW50ZXJzIGFcbiAqIHZhcmlhYmxlLiBUaGUgcmV0dXJuIHR5cGUgd2lsbCBiZSBhIGNvbnN0YW50IHZhbHVlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnN0VmFsdWUoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5TT0YpO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlci5wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuRU9GKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBHaXZlbiBhIHN0cmluZyBjb250YWluaW5nIGEgR3JhcGhRTCBUeXBlIChleC4gYFtJbnQhXWApLCBwYXJzZSB0aGUgQVNUIGZvclxuICogdGhhdCB0eXBlLlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aXRoaW4gdG9vbHMgdGhhdCBvcGVyYXRlIHVwb24gR3JhcGhRTCBUeXBlcyBkaXJlY3RseSBhbmRcbiAqIGluIGlzb2xhdGlvbiBvZiBjb21wbGV0ZSBHcmFwaFFMIGRvY3VtZW50cy5cbiAqXG4gKiBDb25zaWRlciBwcm92aWRpbmcgdGhlIHJlc3VsdHMgdG8gdGhlIHV0aWxpdHkgZnVuY3Rpb246IHR5cGVGcm9tQVNUKCkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHlwZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihzb3VyY2UsIG9wdGlvbnMpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLlNPRik7XG4gIGNvbnN0IHR5cGUgPSBwYXJzZXIucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuRU9GKTtcbiAgcmV0dXJuIHR5cGU7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgZXhwb3J0ZWQgb25seSB0byBhc3Npc3QgcGVvcGxlIGluIGltcGxlbWVudGluZyB0aGVpciBvd24gcGFyc2Vyc1xuICogd2l0aG91dCBkdXBsaWNhdGluZyB0b28gbXVjaCBjb2RlIGFuZCBzaG91bGQgYmUgdXNlZCBvbmx5IGFzIGxhc3QgcmVzb3J0IGZvciBjYXNlc1xuICogc3VjaCBhcyBleHBlcmltZW50YWwgc3ludGF4IG9yIGlmIGNlcnRhaW4gZmVhdHVyZXMgY291bGQgbm90IGJlIGNvbnRyaWJ1dGVkIHVwc3RyZWFtLlxuICpcbiAqIEl0IGlzIHN0aWxsIHBhcnQgb2YgdGhlIGludGVybmFsIEFQSSBhbmQgaXMgdmVyc2lvbmVkLCBzbyBhbnkgY2hhbmdlcyB0byBpdCBhcmUgbmV2ZXJcbiAqIGNvbnNpZGVyZWQgYnJlYWtpbmcgY2hhbmdlcy4gSWYgeW91IHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB2ZXJzaW9ucyBvZiB0aGVcbiAqIGxpYnJhcnksIHBsZWFzZSB1c2UgdGhlIGB2ZXJzaW9uSW5mb2AgdmFyaWFibGUgZm9yIHZlcnNpb24gZGV0ZWN0aW9uLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNvdXJjZU9iaiA9IGlzU291cmNlKHNvdXJjZSkgPyBzb3VyY2UgOiBuZXcgU291cmNlKHNvdXJjZSk7XG4gICAgdGhpcy5fbGV4ZXIgPSBuZXcgTGV4ZXIoc291cmNlT2JqKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl90b2tlbkNvdW50ZXIgPSAwO1xuICB9XG5cbiAgZ2V0IHRva2VuQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rva2VuQ291bnRlcjtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBuYW1lIGxleCB0b2tlbiBpbnRvIGEgbmFtZSBwYXJzZSBub2RlLlxuICAgKi9cblxuICBwYXJzZU5hbWUoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5OQU1FKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICBraW5kOiBLaW5kLk5BTUUsXG4gICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgfSk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgRG9jdW1lbnQgc2VjdGlvbi5cblxuICAvKipcbiAgICogRG9jdW1lbnQgOiBEZWZpbml0aW9uK1xuICAgKi9cblxuICBwYXJzZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuRE9DVU1FTlQsXG4gICAgICBkZWZpbml0aW9uczogdGhpcy5tYW55KFxuICAgICAgICBUb2tlbktpbmQuU09GLFxuICAgICAgICB0aGlzLnBhcnNlRGVmaW5pdGlvbixcbiAgICAgICAgVG9rZW5LaW5kLkVPRixcbiAgICAgICksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluaXRpb24gOlxuICAgKiAgIC0gRXhlY3V0YWJsZURlZmluaXRpb25cbiAgICogICAtIFR5cGVTeXN0ZW1EZWZpbml0aW9uXG4gICAqICAgLSBUeXBlU3lzdGVtRXh0ZW5zaW9uXG4gICAqXG4gICAqIEV4ZWN1dGFibGVEZWZpbml0aW9uIDpcbiAgICogICAtIE9wZXJhdGlvbkRlZmluaXRpb25cbiAgICogICAtIEZyYWdtZW50RGVmaW5pdGlvblxuICAgKlxuICAgKiBUeXBlU3lzdGVtRGVmaW5pdGlvbiA6XG4gICAqICAgLSBTY2hlbWFEZWZpbml0aW9uXG4gICAqICAgLSBUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gRGlyZWN0aXZlRGVmaW5pdGlvblxuICAgKlxuICAgKiBUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBTY2FsYXJUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gT2JqZWN0VHlwZURlZmluaXRpb25cbiAgICogICAtIEludGVyZmFjZVR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBVbmlvblR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBFbnVtVHlwZURlZmluaXRpb25cbiAgICogICAtIElucHV0T2JqZWN0VHlwZURlZmluaXRpb25cbiAgICovXG5cbiAgcGFyc2VEZWZpbml0aW9uKCkge1xuICAgIGlmICh0aGlzLnBlZWsoVG9rZW5LaW5kLkJSQUNFX0wpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKTtcbiAgICB9IC8vIE1hbnkgZGVmaW5pdGlvbnMgYmVnaW4gd2l0aCBhIGRlc2NyaXB0aW9uIGFuZCByZXF1aXJlIGEgbG9va2FoZWFkLlxuXG4gICAgY29uc3QgaGFzRGVzY3JpcHRpb24gPSB0aGlzLnBlZWtEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IGtleXdvcmRUb2tlbiA9IGhhc0Rlc2NyaXB0aW9uXG4gICAgICA/IHRoaXMuX2xleGVyLmxvb2thaGVhZCgpXG4gICAgICA6IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKGtleXdvcmRUb2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSkge1xuICAgICAgc3dpdGNoIChrZXl3b3JkVG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc2NoZW1hJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZVR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNEZXNjcmlwdGlvbikge1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgICAgdGhpcy5fbGV4ZXIudG9rZW4uc3RhcnQsXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgZGVzY3JpcHRpb24sIGRlc2NyaXB0aW9ucyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gdHlwZSBkZWZpbml0aW9ucy4nLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgY2FzZSAnc3Vic2NyaXB0aW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdmcmFnbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGcmFnbWVudERlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdleHRlbmQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChrZXl3b3JkVG9rZW4pO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIE9wZXJhdGlvbnMgc2VjdGlvbi5cblxuICAvKipcbiAgICogT3BlcmF0aW9uRGVmaW5pdGlvbiA6XG4gICAqICAtIFNlbGVjdGlvblNldFxuICAgKiAgLSBPcGVyYXRpb25UeXBlIE5hbWU/IFZhcmlhYmxlRGVmaW5pdGlvbnM/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cblxuICBwYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIGlmICh0aGlzLnBlZWsoVG9rZW5LaW5kLkJSQUNFX0wpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgIGtpbmQ6IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04sXG4gICAgICAgIG9wZXJhdGlvbjogT3BlcmF0aW9uVHlwZU5vZGUuUVVFUlksXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogW10sXG4gICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxuICAgICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMucGFyc2VPcGVyYXRpb25UeXBlKCk7XG4gICAgbGV0IG5hbWU7XG5cbiAgICBpZiAodGhpcy5wZWVrKFRva2VuS2luZC5OQU1FKSkge1xuICAgICAgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5PUEVSQVRJT05fREVGSU5JVElPTixcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICB2YXJpYWJsZURlZmluaXRpb25zOiB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZXJhdGlvblR5cGUgOiBvbmUgb2YgcXVlcnkgbXV0YXRpb24gc3Vic2NyaXB0aW9uXG4gICAqL1xuXG4gIHBhcnNlT3BlcmF0aW9uVHlwZSgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25Ub2tlbiA9IHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLk5BTUUpO1xuXG4gICAgc3dpdGNoIChvcGVyYXRpb25Ub2tlbi52YWx1ZSkge1xuICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICByZXR1cm4gT3BlcmF0aW9uVHlwZU5vZGUuUVVFUlk7XG5cbiAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgcmV0dXJuIE9wZXJhdGlvblR5cGVOb2RlLk1VVEFUSU9OO1xuXG4gICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICByZXR1cm4gT3BlcmF0aW9uVHlwZU5vZGUuU1VCU0NSSVBUSU9OO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChvcGVyYXRpb25Ub2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIFZhcmlhYmxlRGVmaW5pdGlvbnMgOiAoIFZhcmlhYmxlRGVmaW5pdGlvbisgKVxuICAgKi9cblxuICBwYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgVG9rZW5LaW5kLlBBUkVOX0wsXG4gICAgICB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9uLFxuICAgICAgVG9rZW5LaW5kLlBBUkVOX1IsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGVEZWZpbml0aW9uIDogVmFyaWFibGUgOiBUeXBlIERlZmF1bHRWYWx1ZT8gRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuXG4gIHBhcnNlVmFyaWFibGVEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuVkFSSUFCTEVfREVGSU5JVElPTixcbiAgICAgIHZhcmlhYmxlOiB0aGlzLnBhcnNlVmFyaWFibGUoKSxcbiAgICAgIHR5cGU6ICh0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTiksIHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCkpLFxuICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkVRVUFMUylcbiAgICAgICAgPyB0aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGUgOiAkIE5hbWVcbiAgICovXG5cbiAgcGFyc2VWYXJpYWJsZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkRPTExBUik7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5WQVJJQUJMRSxcbiAgICAgIG5hbWU6IHRoaXMucGFyc2VOYW1lKCksXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBTZWxlY3Rpb25TZXQgOiB7IFNlbGVjdGlvbisgfVxuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VTZWxlY3Rpb25TZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbiwge1xuICAgICAga2luZDogS2luZC5TRUxFQ1RJT05fU0VULFxuICAgICAgc2VsZWN0aW9uczogdGhpcy5tYW55KFxuICAgICAgICBUb2tlbktpbmQuQlJBQ0VfTCxcbiAgICAgICAgdGhpcy5wYXJzZVNlbGVjdGlvbixcbiAgICAgICAgVG9rZW5LaW5kLkJSQUNFX1IsXG4gICAgICApLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3Rpb24gOlxuICAgKiAgIC0gRmllbGRcbiAgICogICAtIEZyYWdtZW50U3ByZWFkXG4gICAqICAgLSBJbmxpbmVGcmFnbWVudFxuICAgKi9cblxuICBwYXJzZVNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wZWVrKFRva2VuS2luZC5TUFJFQUQpXG4gICAgICA/IHRoaXMucGFyc2VGcmFnbWVudCgpXG4gICAgICA6IHRoaXMucGFyc2VGaWVsZCgpO1xuICB9XG4gIC8qKlxuICAgKiBGaWVsZCA6IEFsaWFzPyBOYW1lIEFyZ3VtZW50cz8gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0P1xuICAgKlxuICAgKiBBbGlhcyA6IE5hbWUgOlxuICAgKi9cblxuICBwYXJzZUZpZWxkKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgbmFtZU9yQWxpYXMgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGxldCBhbGlhcztcbiAgICBsZXQgbmFtZTtcblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkNPTE9OKSkge1xuICAgICAgYWxpYXMgPSBuYW1lT3JBbGlhcztcbiAgICAgIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZU9yQWxpYXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5GSUVMRCxcbiAgICAgIGFsaWFzLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhmYWxzZSksXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTClcbiAgICAgICAgPyB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFyZ3VtZW50c1tDb25zdF0gOiAoIEFyZ3VtZW50Wz9Db25zdF0rIClcbiAgICovXG5cbiAgcGFyc2VBcmd1bWVudHMoaXNDb25zdCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpc0NvbnN0ID8gdGhpcy5wYXJzZUNvbnN0QXJndW1lbnQgOiB0aGlzLnBhcnNlQXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFRva2VuS2luZC5QQVJFTl9MLCBpdGVtLCBUb2tlbktpbmQuUEFSRU5fUik7XG4gIH1cbiAgLyoqXG4gICAqIEFyZ3VtZW50W0NvbnN0XSA6IE5hbWUgOiBWYWx1ZVs/Q29uc3RdXG4gICAqL1xuXG4gIHBhcnNlQXJndW1lbnQoaXNDb25zdCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5BUkdVTUVOVCxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KSxcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnNlQ29uc3RBcmd1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50KHRydWUpO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIEZyYWdtZW50cyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBDb3JyZXNwb25kcyB0byBib3RoIEZyYWdtZW50U3ByZWFkIGFuZCBJbmxpbmVGcmFnbWVudCBpbiB0aGUgc3BlYy5cbiAgICpcbiAgICogRnJhZ21lbnRTcHJlYWQgOiAuLi4gRnJhZ21lbnROYW1lIERpcmVjdGl2ZXM/XG4gICAqXG4gICAqIElubGluZUZyYWdtZW50IDogLi4uIFR5cGVDb25kaXRpb24/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cblxuICBwYXJzZUZyYWdtZW50KCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuU1BSRUFEKTtcbiAgICBjb25zdCBoYXNUeXBlQ29uZGl0aW9uID0gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ29uJyk7XG5cbiAgICBpZiAoIWhhc1R5cGVDb25kaXRpb24gJiYgdGhpcy5wZWVrKFRva2VuS2luZC5OQU1FKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICBraW5kOiBLaW5kLkZSQUdNRU5UX1NQUkVBRCxcbiAgICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLklOTElORV9GUkFHTUVOVCxcbiAgICAgIHR5cGVDb25kaXRpb246IGhhc1R5cGVDb25kaXRpb24gPyB0aGlzLnBhcnNlTmFtZWRUeXBlKCkgOiB1bmRlZmluZWQsXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRnJhZ21lbnREZWZpbml0aW9uIDpcbiAgICogICAtIGZyYWdtZW50IEZyYWdtZW50TmFtZSBvbiBUeXBlQ29uZGl0aW9uIERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKlxuICAgKiBUeXBlQ29uZGl0aW9uIDogTmFtZWRUeXBlXG4gICAqL1xuXG4gIHBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmcmFnbWVudCcpOyAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgZGVmaW5pbmcgdmFyaWFibGVzIHdpdGhpbiBmcmFnbWVudHMgY2hhbmdlc1xuICAgIC8vIHRoZSBncmFtbWFyIG9mIEZyYWdtZW50RGVmaW5pdGlvbjpcbiAgICAvLyAgIC0gZnJhZ21lbnQgRnJhZ21lbnROYW1lIFZhcmlhYmxlRGVmaW5pdGlvbnM/IG9uIFR5cGVDb25kaXRpb24gRGlyZWN0aXZlcz8gU2VsZWN0aW9uU2V0XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5hbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgIGtpbmQ6IEtpbmQuRlJBR01FTlRfREVGSU5JVElPTixcbiAgICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpLFxuICAgICAgICB0eXBlQ29uZGl0aW9uOiAodGhpcy5leHBlY3RLZXl3b3JkKCdvbicpLCB0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLFxuICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgdHlwZUNvbmRpdGlvbjogKHRoaXMuZXhwZWN0S2V5d29yZCgnb24nKSwgdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGcmFnbWVudE5hbWUgOiBOYW1lIGJ1dCBub3QgYG9uYFxuICAgKi9cblxuICBwYXJzZUZyYWdtZW50TmFtZSgpIHtcbiAgICBpZiAodGhpcy5fbGV4ZXIudG9rZW4udmFsdWUgPT09ICdvbicpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlTmFtZSgpO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFZhbHVlcyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBWYWx1ZVtDb25zdF0gOlxuICAgKiAgIC0gW35Db25zdF0gVmFyaWFibGVcbiAgICogICAtIEludFZhbHVlXG4gICAqICAgLSBGbG9hdFZhbHVlXG4gICAqICAgLSBTdHJpbmdWYWx1ZVxuICAgKiAgIC0gQm9vbGVhblZhbHVlXG4gICAqICAgLSBOdWxsVmFsdWVcbiAgICogICAtIEVudW1WYWx1ZVxuICAgKiAgIC0gTGlzdFZhbHVlWz9Db25zdF1cbiAgICogICAtIE9iamVjdFZhbHVlWz9Db25zdF1cbiAgICpcbiAgICogQm9vbGVhblZhbHVlIDogb25lIG9mIGB0cnVlYCBgZmFsc2VgXG4gICAqXG4gICAqIE51bGxWYWx1ZSA6IGBudWxsYFxuICAgKlxuICAgKiBFbnVtVmFsdWUgOiBOYW1lIGJ1dCBub3QgYHRydWVgLCBgZmFsc2VgIG9yIGBudWxsYFxuICAgKi9cblxuICBwYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIHN3aXRjaCAodG9rZW4ua2luZCkge1xuICAgICAgY2FzZSBUb2tlbktpbmQuQlJBQ0tFVF9MOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoaXNDb25zdCk7XG5cbiAgICAgIGNhc2UgVG9rZW5LaW5kLkJSQUNFX0w6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KGlzQ29uc3QpO1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5JTlQ6XG4gICAgICAgIHRoaXMuYWR2YW5jZUxleGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgICAgICBraW5kOiBLaW5kLklOVCxcbiAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5GTE9BVDpcbiAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRkxPQVQsXG4gICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBUb2tlbktpbmQuU1RSSU5HOlxuICAgICAgY2FzZSBUb2tlbktpbmQuQkxPQ0tfU1RSSU5HOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoKTtcblxuICAgICAgY2FzZSBUb2tlbktpbmQuTkFNRTpcbiAgICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgIGtpbmQ6IEtpbmQuQk9PTEVBTixcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUodG9rZW4sIHtcbiAgICAgICAgICAgICAga2luZDogS2luZC5CT09MRUFOLFxuICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZSh0b2tlbiwge1xuICAgICAgICAgICAgICBraW5kOiBLaW5kLk5VTEwsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICAgICAgICAgIGtpbmQ6IEtpbmQuRU5VTSxcbiAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUb2tlbktpbmQuRE9MTEFSOlxuICAgICAgICBpZiAoaXNDb25zdCkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkRPTExBUik7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbGV4ZXIudG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhck5hbWUgPSB0aGlzLl9sZXhlci50b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFxuICAgICAgICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgICAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCB2YXJpYWJsZSBcIiQke3Zhck5hbWV9XCIgaW4gY29uc3RhbnQgdmFsdWUuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJpYWJsZSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHRydWUpO1xuICB9XG5cbiAgcGFyc2VTdHJpbmdMaXRlcmFsKCkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHRva2VuLCB7XG4gICAgICBraW5kOiBLaW5kLlNUUklORyxcbiAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgIGJsb2NrOiB0b2tlbi5raW5kID09PSBUb2tlbktpbmQuQkxPQ0tfU1RSSU5HLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0VmFsdWVbQ29uc3RdIDpcbiAgICogICAtIFsgXVxuICAgKiAgIC0gWyBWYWx1ZVs/Q29uc3RdKyBdXG4gICAqL1xuXG4gIHBhcnNlTGlzdChpc0NvbnN0KSB7XG4gICAgY29uc3QgaXRlbSA9ICgpID0+IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCk7XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICBraW5kOiBLaW5kLkxJU1QsXG4gICAgICB2YWx1ZXM6IHRoaXMuYW55KFRva2VuS2luZC5CUkFDS0VUX0wsIGl0ZW0sIFRva2VuS2luZC5CUkFDS0VUX1IpLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBgYGBcbiAgICogT2JqZWN0VmFsdWVbQ29uc3RdIDpcbiAgICogICAtIHsgfVxuICAgKiAgIC0geyBPYmplY3RGaWVsZFs/Q29uc3RdKyB9XG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZU9iamVjdChpc0NvbnN0KSB7XG4gICAgY29uc3QgaXRlbSA9ICgpID0+IHRoaXMucGFyc2VPYmplY3RGaWVsZChpc0NvbnN0KTtcblxuICAgIHJldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4sIHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNULFxuICAgICAgZmllbGRzOiB0aGlzLmFueShUb2tlbktpbmQuQlJBQ0VfTCwgaXRlbSwgVG9rZW5LaW5kLkJSQUNFX1IpLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RGaWVsZFtDb25zdF0gOiBOYW1lIDogVmFsdWVbP0NvbnN0XVxuICAgKi9cblxuICBwYXJzZU9iamVjdEZpZWxkKGlzQ29uc3QpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLk9CSkVDVF9GSUVMRCxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChpc0NvbnN0KSxcbiAgICB9KTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBEaXJlY3RpdmVzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIERpcmVjdGl2ZXNbQ29uc3RdIDogRGlyZWN0aXZlWz9Db25zdF0rXG4gICAqL1xuXG4gIHBhcnNlRGlyZWN0aXZlcyhpc0NvbnN0KSB7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IFtdO1xuXG4gICAgd2hpbGUgKHRoaXMucGVlayhUb2tlbktpbmQuQVQpKSB7XG4gICAgICBkaXJlY3RpdmVzLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZShpc0NvbnN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGl2ZXM7XG4gIH1cblxuICBwYXJzZUNvbnN0RGlyZWN0aXZlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBEaXJlY3RpdmVbQ29uc3RdIDogQCBOYW1lIEFyZ3VtZW50c1s/Q29uc3RdP1xuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VEaXJlY3RpdmUoaXNDb25zdCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQVQpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuRElSRUNUSVZFLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKSxcbiAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhpc0NvbnN0KSxcbiAgICB9KTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBUeXBlcyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBUeXBlIDpcbiAgICogICAtIE5hbWVkVHlwZVxuICAgKiAgIC0gTGlzdFR5cGVcbiAgICogICAtIE5vbk51bGxUeXBlXG4gICAqL1xuXG4gIHBhcnNlVHlwZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGxldCB0eXBlO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQlJBQ0tFVF9MKSkge1xuICAgICAgY29uc3QgaW5uZXJUeXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkJSQUNLRVRfUik7XG4gICAgICB0eXBlID0gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICAgIGtpbmQ6IEtpbmQuTElTVF9UWVBFLFxuICAgICAgICB0eXBlOiBpbm5lclR5cGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHRoaXMucGFyc2VOYW1lZFR5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5CQU5HKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAgICBraW5kOiBLaW5kLk5PTl9OVUxMX1RZUEUsXG4gICAgICAgIHR5cGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICAvKipcbiAgICogTmFtZWRUeXBlIDogTmFtZVxuICAgKi9cblxuICBwYXJzZU5hbWVkVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLCB7XG4gICAgICBraW5kOiBLaW5kLk5BTUVEX1RZUEUsXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgIH0pO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIFR5cGUgRGVmaW5pdGlvbiBzZWN0aW9uLlxuXG4gIHBlZWtEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wZWVrKFRva2VuS2luZC5TVFJJTkcpIHx8IHRoaXMucGVlayhUb2tlbktpbmQuQkxPQ0tfU1RSSU5HKTtcbiAgfVxuICAvKipcbiAgICogRGVzY3JpcHRpb24gOiBTdHJpbmdWYWx1ZVxuICAgKi9cblxuICBwYXJzZURlc2NyaXB0aW9uKCkge1xuICAgIGlmICh0aGlzLnBlZWtEZXNjcmlwdGlvbigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBTY2hlbWFEZWZpbml0aW9uIDogRGVzY3JpcHRpb24/IHNjaGVtYSBEaXJlY3RpdmVzW0NvbnN0XT8geyBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbisgfVxuICAgKiBgYGBcbiAgICovXG5cbiAgcGFyc2VTY2hlbWFEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjaGVtYScpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSB0aGlzLm1hbnkoXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfTCxcbiAgICAgIHRoaXMucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbixcbiAgICAgIFRva2VuS2luZC5CUkFDRV9SLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5TQ0hFTUFfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIG9wZXJhdGlvblR5cGVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbiA6IE9wZXJhdGlvblR5cGUgOiBOYW1lZFR5cGVcbiAgICovXG5cbiAgcGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMucGFyc2VPcGVyYXRpb25UeXBlKCk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcnNlTmFtZWRUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5PUEVSQVRJT05fVFlQRV9ERUZJTklUSU9OLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgdHlwZSxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2NhbGFyVHlwZURlZmluaXRpb24gOiBEZXNjcmlwdGlvbj8gc2NhbGFyIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuXG4gIHBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NhbGFyJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLlNDQUxBUl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RUeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgRGVzY3JpcHRpb24/XG4gICAqICAgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvbj9cbiAgICovXG5cbiAgcGFyc2VPYmplY3RUeXBlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0eXBlJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLk9CSkVDVF9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW1wbGVtZW50c0ludGVyZmFjZXMgOlxuICAgKiAgIC0gaW1wbGVtZW50cyBgJmA/IE5hbWVkVHlwZVxuICAgKiAgIC0gSW1wbGVtZW50c0ludGVyZmFjZXMgJiBOYW1lZFR5cGVcbiAgICovXG5cbiAgcGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ2ltcGxlbWVudHMnKVxuICAgICAgPyB0aGlzLmRlbGltaXRlZE1hbnkoVG9rZW5LaW5kLkFNUCwgdGhpcy5wYXJzZU5hbWVkVHlwZSlcbiAgICAgIDogW107XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBGaWVsZHNEZWZpbml0aW9uIDogeyBGaWVsZERlZmluaXRpb24rIH1cbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlRmllbGRzRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfTCxcbiAgICAgIHRoaXMucGFyc2VGaWVsZERlZmluaXRpb24sXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfUixcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaWVsZERlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IE5hbWUgQXJndW1lbnRzRGVmaW5pdGlvbj8gOiBUeXBlIERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cblxuICBwYXJzZUZpZWxkRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudERlZnMoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkZJRUxEX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICB0eXBlLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXJndW1lbnRzRGVmaW5pdGlvbiA6ICggSW5wdXRWYWx1ZURlZmluaXRpb24rIClcbiAgICovXG5cbiAgcGFyc2VBcmd1bWVudERlZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFxuICAgICAgVG9rZW5LaW5kLlBBUkVOX0wsXG4gICAgICB0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixcbiAgICAgIFRva2VuS2luZC5QQVJFTl9SLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0VmFsdWVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBOYW1lIDogVHlwZSBEZWZhdWx0VmFsdWU/IERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cblxuICBwYXJzZUlucHV0VmFsdWVEZWYoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICBsZXQgZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuRVFVQUxTKSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLklOUFVUX1ZBTFVFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJmYWNlVHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGludGVyZmFjZSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBGaWVsZHNEZWZpbml0aW9uP1xuICAgKi9cblxuICBwYXJzZUludGVyZmFjZVR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ludGVyZmFjZScpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGludGVyZmFjZXMgPSB0aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgaW50ZXJmYWNlcyxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW9uVHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IHVuaW9uIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IFVuaW9uTWVtYmVyVHlwZXM/XG4gICAqL1xuXG4gIHBhcnNlVW5pb25UeXBlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCd1bmlvbicpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuVU5JT05fVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIHR5cGVzLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbmlvbk1lbWJlclR5cGVzIDpcbiAgICogICAtID0gYHxgPyBOYW1lZFR5cGVcbiAgICogICAtIFVuaW9uTWVtYmVyVHlwZXMgfCBOYW1lZFR5cGVcbiAgICovXG5cbiAgcGFyc2VVbmlvbk1lbWJlclR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkVRVUFMUylcbiAgICAgID8gdGhpcy5kZWxpbWl0ZWRNYW55KFRva2VuS2luZC5QSVBFLCB0aGlzLnBhcnNlTmFtZWRUeXBlKVxuICAgICAgOiBbXTtcbiAgfVxuICAvKipcbiAgICogRW51bVR5cGVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBlbnVtIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IEVudW1WYWx1ZXNEZWZpbml0aW9uP1xuICAgKi9cblxuICBwYXJzZUVudW1UeXBlRGVmaW5pdGlvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdlbnVtJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkVOVU1fVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIHZhbHVlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIEVudW1WYWx1ZXNEZWZpbml0aW9uIDogeyBFbnVtVmFsdWVEZWZpbml0aW9uKyB9XG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShcbiAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgdGhpcy5wYXJzZUVudW1WYWx1ZURlZmluaXRpb24sXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfUixcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFbnVtVmFsdWVEZWZpbml0aW9uIDogRGVzY3JpcHRpb24/IEVudW1WYWx1ZSBEaXJlY3RpdmVzW0NvbnN0XT9cbiAgICovXG5cbiAgcGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZUVudW1WYWx1ZU5hbWUoKTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO1xuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuRU5VTV9WQUxVRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW51bVZhbHVlIDogTmFtZSBidXQgbm90IGB0cnVlYCwgYGZhbHNlYCBvciBgbnVsbGBcbiAgICovXG5cbiAgcGFyc2VFbnVtVmFsdWVOYW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSAndHJ1ZScgfHxcbiAgICAgIHRoaXMuX2xleGVyLnRva2VuLnZhbHVlID09PSAnZmFsc2UnIHx8XG4gICAgICB0aGlzLl9sZXhlci50b2tlbi52YWx1ZSA9PT0gJ251bGwnXG4gICAgKSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICB0aGlzLl9sZXhlci50b2tlbi5zdGFydCxcbiAgICAgICAgYCR7Z2V0VG9rZW5EZXNjKFxuICAgICAgICAgIHRoaXMuX2xleGVyLnRva2VuLFxuICAgICAgICApfSBpcyByZXNlcnZlZCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFuIGVudW0gdmFsdWUuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lKCk7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0T2JqZWN0VHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IGlucHV0IE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IElucHV0RmllbGRzRGVmaW5pdGlvbj9cbiAgICovXG5cbiAgcGFyc2VJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lucHV0Jyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYGBgXG4gICAqIElucHV0RmllbGRzRGVmaW5pdGlvbiA6IHsgSW5wdXRWYWx1ZURlZmluaXRpb24rIH1cbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShcbiAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgdGhpcy5wYXJzZUlucHV0VmFsdWVEZWYsXG4gICAgICBUb2tlbktpbmQuQlJBQ0VfUixcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUeXBlU3lzdGVtRXh0ZW5zaW9uIDpcbiAgICogICAtIFNjaGVtYUV4dGVuc2lvblxuICAgKiAgIC0gVHlwZUV4dGVuc2lvblxuICAgKlxuICAgKiBUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIFNjYWxhclR5cGVFeHRlbnNpb25cbiAgICogICAtIE9iamVjdFR5cGVFeHRlbnNpb25cbiAgICogICAtIEludGVyZmFjZVR5cGVFeHRlbnNpb25cbiAgICogICAtIFVuaW9uVHlwZUV4dGVuc2lvblxuICAgKiAgIC0gRW51bVR5cGVFeHRlbnNpb25cbiAgICogICAtIElucHV0T2JqZWN0VHlwZURlZmluaXRpb25cbiAgICovXG5cbiAgcGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IGtleXdvcmRUb2tlbiA9IHRoaXMuX2xleGVyLmxvb2thaGVhZCgpO1xuXG4gICAgaWYgKGtleXdvcmRUb2tlbi5raW5kID09PSBUb2tlbktpbmQuTkFNRSkge1xuICAgICAgc3dpdGNoIChrZXl3b3JkVG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc2NoZW1hJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2FsYXJUeXBlRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RUeXBlRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmlvblR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVudW1UeXBlRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKGtleXdvcmRUb2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBTY2hlbWFFeHRlbnNpb24gOlxuICAgKiAgLSBleHRlbmQgc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdPyB7IE9wZXJhdGlvblR5cGVEZWZpbml0aW9uKyB9XG4gICAqICAtIGV4dGVuZCBzY2hlbWEgRGlyZWN0aXZlc1tDb25zdF1cbiAgICogYGBgXG4gICAqL1xuXG4gIHBhcnNlU2NoZW1hRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjaGVtYScpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSB0aGlzLm9wdGlvbmFsTWFueShcbiAgICAgIFRva2VuS2luZC5CUkFDRV9MLFxuICAgICAgdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLFxuICAgICAgVG9rZW5LaW5kLkJSQUNFX1IsXG4gICAgKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiBvcGVyYXRpb25UeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuU0NIRU1BX0VYVEVOU0lPTixcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICBvcGVyYXRpb25UeXBlcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2NhbGFyVHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBleHRlbmQgc2NhbGFyIE5hbWUgRGlyZWN0aXZlc1tDb25zdF1cbiAgICovXG5cbiAgcGFyc2VTY2FsYXJUeXBlRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjYWxhcicpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuU0NBTEFSX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdFR5cGVFeHRlbnNpb24gOlxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvblxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzPyBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKiAgLSBleHRlbmQgdHlwZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzXG4gICAqL1xuXG4gIHBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0eXBlJyk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcblxuICAgIGlmIChcbiAgICAgIGludGVyZmFjZXMubGVuZ3RoID09PSAwICYmXG4gICAgICBkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgZmllbGRzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5PQkpFQ1RfVFlQRV9FWFRFTlNJT04sXG4gICAgICBuYW1lLFxuICAgICAgaW50ZXJmYWNlcyxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVyZmFjZVR5cGVFeHRlbnNpb24gOlxuICAgKiAgLSBleHRlbmQgaW50ZXJmYWNlIE5hbWUgSW1wbGVtZW50c0ludGVyZmFjZXM/IERpcmVjdGl2ZXNbQ29uc3RdPyBGaWVsZHNEZWZpbml0aW9uXG4gICAqICAtIGV4dGVuZCBpbnRlcmZhY2UgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF1cbiAgICogIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIEltcGxlbWVudHNJbnRlcmZhY2VzXG4gICAqL1xuXG4gIHBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbnRlcmZhY2UnKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICBjb25zdCBpbnRlcmZhY2VzID0gdGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCk7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKFxuICAgICAgaW50ZXJmYWNlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmXG4gICAgICBmaWVsZHMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkcyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5pb25UeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBVbmlvbk1lbWJlclR5cGVzXG4gICAqICAgLSBleHRlbmQgdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cblxuICBwYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCd1bmlvbicpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5VTklPTl9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWUsXG4gICAgICBkaXJlY3RpdmVzLFxuICAgICAgdHlwZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVudW1UeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBlbnVtIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IEVudW1WYWx1ZXNEZWZpbml0aW9uXG4gICAqICAgLSBleHRlbmQgZW51bSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuXG4gIHBhcnNlRW51bVR5cGVFeHRlbnNpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZW51bScpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgdmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZShzdGFydCwge1xuICAgICAga2luZDogS2luZC5FTlVNX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICB2YWx1ZXMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBleHRlbmQgaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gSW5wdXRGaWVsZHNEZWZpbml0aW9uXG4gICAqICAgLSBleHRlbmQgaW5wdXQgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cblxuICBwYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbnB1dCcpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGUoc3RhcnQsIHtcbiAgICAgIGtpbmQ6IEtpbmQuSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHMsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGBgYFxuICAgKiBEaXJlY3RpdmVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBkaXJlY3RpdmUgQCBOYW1lIEFyZ3VtZW50c0RlZmluaXRpb24/IGByZXBlYXRhYmxlYD8gb24gRGlyZWN0aXZlTG9jYXRpb25zXG4gICAqIGBgYFxuICAgKi9cblxuICBwYXJzZURpcmVjdGl2ZURlZmluaXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZGlyZWN0aXZlJyk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQVQpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhcnNlQXJndW1lbnREZWZzKCk7XG4gICAgY29uc3QgcmVwZWF0YWJsZSA9IHRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKCdyZXBlYXRhYmxlJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdvbicpO1xuICAgIGNvbnN0IGxvY2F0aW9ucyA9IHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5ub2RlKHN0YXJ0LCB7XG4gICAgICBraW5kOiBLaW5kLkRJUkVDVElWRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBuYW1lLFxuICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgcmVwZWF0YWJsZSxcbiAgICAgIGxvY2F0aW9ucyxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGlyZWN0aXZlTG9jYXRpb25zIDpcbiAgICogICAtIGB8YD8gRGlyZWN0aXZlTG9jYXRpb25cbiAgICogICAtIERpcmVjdGl2ZUxvY2F0aW9ucyB8IERpcmVjdGl2ZUxvY2F0aW9uXG4gICAqL1xuXG4gIHBhcnNlRGlyZWN0aXZlTG9jYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlbGltaXRlZE1hbnkoVG9rZW5LaW5kLlBJUEUsIHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbik7XG4gIH1cbiAgLypcbiAgICogRGlyZWN0aXZlTG9jYXRpb24gOlxuICAgKiAgIC0gRXhlY3V0YWJsZURpcmVjdGl2ZUxvY2F0aW9uXG4gICAqICAgLSBUeXBlU3lzdGVtRGlyZWN0aXZlTG9jYXRpb25cbiAgICpcbiAgICogRXhlY3V0YWJsZURpcmVjdGl2ZUxvY2F0aW9uIDogb25lIG9mXG4gICAqICAgYFFVRVJZYFxuICAgKiAgIGBNVVRBVElPTmBcbiAgICogICBgU1VCU0NSSVBUSU9OYFxuICAgKiAgIGBGSUVMRGBcbiAgICogICBgRlJBR01FTlRfREVGSU5JVElPTmBcbiAgICogICBgRlJBR01FTlRfU1BSRUFEYFxuICAgKiAgIGBJTkxJTkVfRlJBR01FTlRgXG4gICAqXG4gICAqIFR5cGVTeXN0ZW1EaXJlY3RpdmVMb2NhdGlvbiA6IG9uZSBvZlxuICAgKiAgIGBTQ0hFTUFgXG4gICAqICAgYFNDQUxBUmBcbiAgICogICBgT0JKRUNUYFxuICAgKiAgIGBGSUVMRF9ERUZJTklUSU9OYFxuICAgKiAgIGBBUkdVTUVOVF9ERUZJTklUSU9OYFxuICAgKiAgIGBJTlRFUkZBQ0VgXG4gICAqICAgYFVOSU9OYFxuICAgKiAgIGBFTlVNYFxuICAgKiAgIGBFTlVNX1ZBTFVFYFxuICAgKiAgIGBJTlBVVF9PQkpFQ1RgXG4gICAqICAgYElOUFVUX0ZJRUxEX0RFRklOSVRJT05gXG4gICAqL1xuXG4gIHBhcnNlRGlyZWN0aXZlTG9jYXRpb24oKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRGlyZWN0aXZlTG9jYXRpb24sIG5hbWUudmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoc3RhcnQpO1xuICB9IC8vIENvcmUgcGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9kZSB0aGF0LCBpZiBjb25maWd1cmVkIHRvIGRvIHNvLCBzZXRzIGEgXCJsb2NcIiBmaWVsZCBhcyBhXG4gICAqIGxvY2F0aW9uIG9iamVjdCwgdXNlZCB0byBpZGVudGlmeSB0aGUgcGxhY2UgaW4gdGhlIHNvdXJjZSB0aGF0IGNyZWF0ZWQgYVxuICAgKiBnaXZlbiBwYXJzZWQgb2JqZWN0LlxuICAgKi9cblxuICBub2RlKHN0YXJ0VG9rZW4sIG5vZGUpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5ub0xvY2F0aW9uICE9PSB0cnVlKSB7XG4gICAgICBub2RlLmxvYyA9IG5ldyBMb2NhdGlvbihcbiAgICAgICAgc3RhcnRUb2tlbixcbiAgICAgICAgdGhpcy5fbGV4ZXIubGFzdFRva2VuLFxuICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIGlzIG9mIGEgZ2l2ZW4ga2luZFxuICAgKi9cblxuICBwZWVrKGtpbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV4ZXIudG9rZW4ua2luZCA9PT0ga2luZDtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuIGtpbmQsIHJldHVybiB0aGF0IHRva2VuIGFmdGVyIGFkdmFuY2luZyB0aGUgbGV4ZXIuXG4gICAqIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICovXG5cbiAgZXhwZWN0VG9rZW4oa2luZCkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0ga2luZCkge1xuICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgYEV4cGVjdGVkICR7Z2V0VG9rZW5LaW5kRGVzYyhraW5kKX0sIGZvdW5kICR7Z2V0VG9rZW5EZXNjKHRva2VuKX0uYCxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW4ga2luZCwgcmV0dXJuIFwidHJ1ZVwiIGFmdGVyIGFkdmFuY2luZyB0aGUgbGV4ZXIuXG4gICAqIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCByZXR1cm4gXCJmYWxzZVwiLlxuICAgKi9cblxuICBleHBlY3RPcHRpb25hbFRva2VuKGtpbmQpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IGtpbmQpIHtcbiAgICAgIHRoaXMuYWR2YW5jZUxleGVyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIGEgZ2l2ZW4ga2V5d29yZCwgYWR2YW5jZSB0aGUgbGV4ZXIuXG4gICAqIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICovXG5cbiAgZXhwZWN0S2V5d29yZCh2YWx1ZSkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmFkdmFuY2VMZXhlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgdGhpcy5fbGV4ZXIuc291cmNlLFxuICAgICAgICB0b2tlbi5zdGFydCxcbiAgICAgICAgYEV4cGVjdGVkIFwiJHt2YWx1ZX1cIiwgZm91bmQgJHtnZXRUb2tlbkRlc2ModG9rZW4pfS5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIGEgZ2l2ZW4ga2V5d29yZCwgcmV0dXJuIFwidHJ1ZVwiIGFmdGVyIGFkdmFuY2luZyB0aGUgbGV4ZXIuXG4gICAqIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCByZXR1cm4gXCJmYWxzZVwiLlxuICAgKi9cblxuICBleHBlY3RPcHRpb25hbEtleXdvcmQodmFsdWUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FICYmIHRva2VuLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgdGhpcy5hZHZhbmNlTGV4ZXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBlcnJvciB3aGVuIGFuIHVuZXhwZWN0ZWQgbGV4ZWQgdG9rZW4gaXMgZW5jb3VudGVyZWQuXG4gICAqL1xuXG4gIHVuZXhwZWN0ZWQoYXRUb2tlbikge1xuICAgIGNvbnN0IHRva2VuID1cbiAgICAgIGF0VG9rZW4gIT09IG51bGwgJiYgYXRUb2tlbiAhPT0gdm9pZCAwID8gYXRUb2tlbiA6IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHJldHVybiBzeW50YXhFcnJvcihcbiAgICAgIHRoaXMuX2xleGVyLnNvdXJjZSxcbiAgICAgIHRva2VuLnN0YXJ0LFxuICAgICAgYFVuZXhwZWN0ZWQgJHtnZXRUb2tlbkRlc2ModG9rZW4pfS5gLFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwb3NzaWJseSBlbXB0eSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgKiBUaGlzIGxpc3QgYmVnaW5zIHdpdGggYSBsZXggdG9rZW4gb2Ygb3BlbktpbmQgYW5kIGVuZHMgd2l0aCBhIGxleCB0b2tlbiBvZiBjbG9zZUtpbmQuXG4gICAqIEFkdmFuY2VzIHRoZSBwYXJzZXIgdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIHRoZSBjbG9zaW5nIHRva2VuLlxuICAgKi9cblxuICBhbnkob3BlbktpbmQsIHBhcnNlRm4sIGNsb3NlS2luZCkge1xuICAgIHRoaXMuZXhwZWN0VG9rZW4ob3BlbktpbmQpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKSB7XG4gICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieSB0aGUgcGFyc2VGbi5cbiAgICogSXQgY2FuIGJlIGVtcHR5IG9ubHkgaWYgb3BlbiB0b2tlbiBpcyBtaXNzaW5nIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyByZXR1cm4gbm9uLWVtcHR5IGxpc3RcbiAgICogdGhhdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC5cbiAgICogQWR2YW5jZXMgdGhlIHBhcnNlciB0byB0aGUgbmV4dCBsZXggdG9rZW4gYWZ0ZXIgdGhlIGNsb3NpbmcgdG9rZW4uXG4gICAqL1xuXG4gIG9wdGlvbmFsTWFueShvcGVuS2luZCwgcGFyc2VGbiwgY2xvc2VLaW5kKSB7XG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihvcGVuS2luZCkpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgICAgfSB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKTtcblxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi1lbXB0eSBsaXN0IG9mIHBhcnNlIG5vZGVzLCBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJzZUZuLlxuICAgKiBUaGlzIGxpc3QgYmVnaW5zIHdpdGggYSBsZXggdG9rZW4gb2Ygb3BlbktpbmQgYW5kIGVuZHMgd2l0aCBhIGxleCB0b2tlbiBvZiBjbG9zZUtpbmQuXG4gICAqIEFkdmFuY2VzIHRoZSBwYXJzZXIgdG8gdGhlIG5leHQgbGV4IHRva2VuIGFmdGVyIHRoZSBjbG9zaW5nIHRva2VuLlxuICAgKi9cblxuICBtYW55KG9wZW5LaW5kLCBwYXJzZUZuLCBjbG9zZUtpbmQpIHtcbiAgICB0aGlzLmV4cGVjdFRva2VuKG9wZW5LaW5kKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgIH0gd2hpbGUgKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oY2xvc2VLaW5kKSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBub24tZW1wdHkgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieSB0aGUgcGFyc2VGbi5cbiAgICogVGhpcyBsaXN0IG1heSBiZWdpbiB3aXRoIGEgbGV4IHRva2VuIG9mIGRlbGltaXRlcktpbmQgZm9sbG93ZWQgYnkgaXRlbXMgc2VwYXJhdGVkIGJ5IGxleCB0b2tlbnMgb2YgdG9rZW5LaW5kLlxuICAgKiBBZHZhbmNlcyB0aGUgcGFyc2VyIHRvIHRoZSBuZXh0IGxleCB0b2tlbiBhZnRlciBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAqL1xuXG4gIGRlbGltaXRlZE1hbnkoZGVsaW1pdGVyS2luZCwgcGFyc2VGbikge1xuICAgIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihkZWxpbWl0ZXJLaW5kKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgIH0gd2hpbGUgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihkZWxpbWl0ZXJLaW5kKSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBhZHZhbmNlTGV4ZXIoKSB7XG4gICAgY29uc3QgeyBtYXhUb2tlbnMgfSA9IHRoaXMuX29wdGlvbnM7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgIGlmICh0b2tlbi5raW5kICE9PSBUb2tlbktpbmQuRU9GKSB7XG4gICAgICArK3RoaXMuX3Rva2VuQ291bnRlcjtcblxuICAgICAgaWYgKG1heFRva2VucyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3Rva2VuQ291bnRlciA+IG1heFRva2Vucykge1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcbiAgICAgICAgICB0aGlzLl9sZXhlci5zb3VyY2UsXG4gICAgICAgICAgdG9rZW4uc3RhcnQsXG4gICAgICAgICAgYERvY3VtZW50IGNvbnRhaW5zIG1vcmUgdGhhdCAke21heFRva2Vuc30gdG9rZW5zLiBQYXJzaW5nIGFib3J0ZWQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZGVzY3JpYmUgYSB0b2tlbiBhcyBhIHN0cmluZyBmb3IgZGVidWdnaW5nLlxuICovXG5cbmZ1bmN0aW9uIGdldFRva2VuRGVzYyh0b2tlbikge1xuICBjb25zdCB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICByZXR1cm4gZ2V0VG9rZW5LaW5kRGVzYyh0b2tlbi5raW5kKSArICh2YWx1ZSAhPSBudWxsID8gYCBcIiR7dmFsdWV9XCJgIDogJycpO1xufVxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBkZXNjcmliZSBhIHRva2VuIGtpbmQgYXMgYSBzdHJpbmcgZm9yIGRlYnVnZ2luZy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRUb2tlbktpbmREZXNjKGtpbmQpIHtcbiAgcmV0dXJuIGlzUHVuY3R1YXRvclRva2VuS2luZChraW5kKSA/IGBcIiR7a2luZH1cImAgOiBraW5kO1xufVxuIiwgIi8qKlxuICogUHJpbnRzIGEgc3RyaW5nIGFzIGEgR3JhcGhRTCBTdHJpbmdWYWx1ZSBsaXRlcmFsLiBSZXBsYWNlcyBjb250cm9sIGNoYXJhY3RlcnNcbiAqIGFuZCBleGNsdWRlZCBjaGFyYWN0ZXJzIChcIiBVKzAwMjIgYW5kIFxcXFwgVSswMDVDKSB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGBcIiR7c3RyLnJlcGxhY2UoZXNjYXBlZFJlZ0V4cCwgZXNjYXBlZFJlcGxhY2VyKX1cImA7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbmNvbnN0IGVzY2FwZWRSZWdFeHAgPSAvW1xceDAwLVxceDFmXFx4MjJcXHg1Y1xceDdmLVxceDlmXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVkUmVwbGFjZXIoc3RyKSB7XG4gIHJldHVybiBlc2NhcGVTZXF1ZW5jZXNbc3RyLmNoYXJDb2RlQXQoMCldO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuY29uc3QgZXNjYXBlU2VxdWVuY2VzID0gW1xuICAnXFxcXHUwMDAwJyxcbiAgJ1xcXFx1MDAwMScsXG4gICdcXFxcdTAwMDInLFxuICAnXFxcXHUwMDAzJyxcbiAgJ1xcXFx1MDAwNCcsXG4gICdcXFxcdTAwMDUnLFxuICAnXFxcXHUwMDA2JyxcbiAgJ1xcXFx1MDAwNycsXG4gICdcXFxcYicsXG4gICdcXFxcdCcsXG4gICdcXFxcbicsXG4gICdcXFxcdTAwMEInLFxuICAnXFxcXGYnLFxuICAnXFxcXHInLFxuICAnXFxcXHUwMDBFJyxcbiAgJ1xcXFx1MDAwRicsXG4gICdcXFxcdTAwMTAnLFxuICAnXFxcXHUwMDExJyxcbiAgJ1xcXFx1MDAxMicsXG4gICdcXFxcdTAwMTMnLFxuICAnXFxcXHUwMDE0JyxcbiAgJ1xcXFx1MDAxNScsXG4gICdcXFxcdTAwMTYnLFxuICAnXFxcXHUwMDE3JyxcbiAgJ1xcXFx1MDAxOCcsXG4gICdcXFxcdTAwMTknLFxuICAnXFxcXHUwMDFBJyxcbiAgJ1xcXFx1MDAxQicsXG4gICdcXFxcdTAwMUMnLFxuICAnXFxcXHUwMDFEJyxcbiAgJ1xcXFx1MDAxRScsXG4gICdcXFxcdTAwMUYnLFxuICAnJyxcbiAgJycsXG4gICdcXFxcXCInLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJywgLy8gMkZcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsIC8vIDNGXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyA0RlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnXFxcXFxcXFwnLFxuICAnJyxcbiAgJycsXG4gICcnLCAvLyA1RlxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJywgLy8gNkZcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJycsXG4gICcnLFxuICAnJyxcbiAgJ1xcXFx1MDA3RicsXG4gICdcXFxcdTAwODAnLFxuICAnXFxcXHUwMDgxJyxcbiAgJ1xcXFx1MDA4MicsXG4gICdcXFxcdTAwODMnLFxuICAnXFxcXHUwMDg0JyxcbiAgJ1xcXFx1MDA4NScsXG4gICdcXFxcdTAwODYnLFxuICAnXFxcXHUwMDg3JyxcbiAgJ1xcXFx1MDA4OCcsXG4gICdcXFxcdTAwODknLFxuICAnXFxcXHUwMDhBJyxcbiAgJ1xcXFx1MDA4QicsXG4gICdcXFxcdTAwOEMnLFxuICAnXFxcXHUwMDhEJyxcbiAgJ1xcXFx1MDA4RScsXG4gICdcXFxcdTAwOEYnLFxuICAnXFxcXHUwMDkwJyxcbiAgJ1xcXFx1MDA5MScsXG4gICdcXFxcdTAwOTInLFxuICAnXFxcXHUwMDkzJyxcbiAgJ1xcXFx1MDA5NCcsXG4gICdcXFxcdTAwOTUnLFxuICAnXFxcXHUwMDk2JyxcbiAgJ1xcXFx1MDA5NycsXG4gICdcXFxcdTAwOTgnLFxuICAnXFxcXHUwMDk5JyxcbiAgJ1xcXFx1MDA5QScsXG4gICdcXFxcdTAwOUInLFxuICAnXFxcXHUwMDlDJyxcbiAgJ1xcXFx1MDA5RCcsXG4gICdcXFxcdTAwOUUnLFxuICAnXFxcXHUwMDlGJyxcbl07XG4iLCAiaW1wb3J0IHsgZGV2QXNzZXJ0IH0gZnJvbSAnLi4vanN1dGlscy9kZXZBc3NlcnQubWpzJztcbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tICcuLi9qc3V0aWxzL2luc3BlY3QubWpzJztcbmltcG9ydCB7IGlzTm9kZSwgUXVlcnlEb2N1bWVudEtleXMgfSBmcm9tICcuL2FzdC5tanMnO1xuaW1wb3J0IHsgS2luZCB9IGZyb20gJy4va2luZHMubWpzJztcbi8qKlxuICogQSB2aXNpdG9yIGlzIHByb3ZpZGVkIHRvIHZpc2l0LCBpdCBjb250YWlucyB0aGUgY29sbGVjdGlvbiBvZlxuICogcmVsZXZhbnQgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHZpc2l0b3IncyB0cmF2ZXJzYWwuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEJSRUFLID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4vKipcbiAqIHZpc2l0KCkgd2lsbCB3YWxrIHRocm91Z2ggYW4gQVNUIHVzaW5nIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsLCBjYWxsaW5nXG4gKiB0aGUgdmlzaXRvcidzIGVudGVyIGZ1bmN0aW9uIGF0IGVhY2ggbm9kZSBpbiB0aGUgdHJhdmVyc2FsLCBhbmQgY2FsbGluZyB0aGVcbiAqIGxlYXZlIGZ1bmN0aW9uIGFmdGVyIHZpc2l0aW5nIHRoYXQgbm9kZSBhbmQgYWxsIG9mIGl0cyBjaGlsZCBub2Rlcy5cbiAqXG4gKiBCeSByZXR1cm5pbmcgZGlmZmVyZW50IHZhbHVlcyBmcm9tIHRoZSBlbnRlciBhbmQgbGVhdmUgZnVuY3Rpb25zLCB0aGVcbiAqIGJlaGF2aW9yIG9mIHRoZSB2aXNpdG9yIGNhbiBiZSBhbHRlcmVkLCBpbmNsdWRpbmcgc2tpcHBpbmcgb3ZlciBhIHN1Yi10cmVlIG9mXG4gKiB0aGUgQVNUIChieSByZXR1cm5pbmcgZmFsc2UpLCBlZGl0aW5nIHRoZSBBU1QgYnkgcmV0dXJuaW5nIGEgdmFsdWUgb3IgbnVsbFxuICogdG8gcmVtb3ZlIHRoZSB2YWx1ZSwgb3IgdG8gc3RvcCB0aGUgd2hvbGUgdHJhdmVyc2FsIGJ5IHJldHVybmluZyBCUkVBSy5cbiAqXG4gKiBXaGVuIHVzaW5nIHZpc2l0KCkgdG8gZWRpdCBhbiBBU1QsIHRoZSBvcmlnaW5hbCBBU1Qgd2lsbCBub3QgYmUgbW9kaWZpZWQsIGFuZFxuICogYSBuZXcgdmVyc2lvbiBvZiB0aGUgQVNUIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZCB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlXG4gKiB2aXNpdCBmdW5jdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZWRpdGVkQVNUID0gdmlzaXQoYXN0LCB7XG4gKiAgIGVudGVyKG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpIHtcbiAqICAgICAvLyBAcmV0dXJuXG4gKiAgICAgLy8gICB1bmRlZmluZWQ6IG5vIGFjdGlvblxuICogICAgIC8vICAgZmFsc2U6IHNraXAgdmlzaXRpbmcgdGhpcyBub2RlXG4gKiAgICAgLy8gICB2aXNpdG9yLkJSRUFLOiBzdG9wIHZpc2l0aW5nIGFsdG9nZXRoZXJcbiAqICAgICAvLyAgIG51bGw6IGRlbGV0ZSB0aGlzIG5vZGVcbiAqICAgICAvLyAgIGFueSB2YWx1ZTogcmVwbGFjZSB0aGlzIG5vZGUgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqICAgfSxcbiAqICAgbGVhdmUobm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycykge1xuICogICAgIC8vIEByZXR1cm5cbiAqICAgICAvLyAgIHVuZGVmaW5lZDogbm8gYWN0aW9uXG4gKiAgICAgLy8gICBmYWxzZTogbm8gYWN0aW9uXG4gKiAgICAgLy8gICB2aXNpdG9yLkJSRUFLOiBzdG9wIHZpc2l0aW5nIGFsdG9nZXRoZXJcbiAqICAgICAvLyAgIG51bGw6IGRlbGV0ZSB0aGlzIG5vZGVcbiAqICAgICAvLyAgIGFueSB2YWx1ZTogcmVwbGFjZSB0aGlzIG5vZGUgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5IHRvIHByb3ZpZGluZyBlbnRlcigpIGFuZCBsZWF2ZSgpIGZ1bmN0aW9ucywgYSB2aXNpdG9yIGNhblxuICogaW5zdGVhZCBwcm92aWRlIGZ1bmN0aW9ucyBuYW1lZCB0aGUgc2FtZSBhcyB0aGUga2luZHMgb2YgQVNUIG5vZGVzLCBvclxuICogZW50ZXIvbGVhdmUgdmlzaXRvcnMgYXQgYSBuYW1lZCBrZXksIGxlYWRpbmcgdG8gdGhyZWUgcGVybXV0YXRpb25zIG9mIHRoZVxuICogdmlzaXRvciBBUEk6XG4gKlxuICogMSkgTmFtZWQgdmlzaXRvcnMgdHJpZ2dlcmVkIHdoZW4gZW50ZXJpbmcgYSBub2RlIG9mIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiBgYGB0c1xuICogdmlzaXQoYXN0LCB7XG4gKiAgIEtpbmQobm9kZSkge1xuICogICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAyKSBOYW1lZCB2aXNpdG9ycyB0aGF0IHRyaWdnZXIgdXBvbiBlbnRlcmluZyBhbmQgbGVhdmluZyBhIG5vZGUgb2YgYSBzcGVjaWZpYyBraW5kLlxuICpcbiAqIGBgYHRzXG4gKiB2aXNpdChhc3QsIHtcbiAqICAgS2luZDoge1xuICogICAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgfVxuICogICAgIGxlYXZlKG5vZGUpIHtcbiAqICAgICAgIC8vIGxlYXZlIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogMykgR2VuZXJpYyB2aXNpdG9ycyB0aGF0IHRyaWdnZXIgdXBvbiBlbnRlcmluZyBhbmQgbGVhdmluZyBhbnkgbm9kZS5cbiAqXG4gKiBgYGB0c1xuICogdmlzaXQoYXN0LCB7XG4gKiAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAvLyBlbnRlciBhbnkgbm9kZVxuICogICB9LFxuICogICBsZWF2ZShub2RlKSB7XG4gKiAgICAgLy8gbGVhdmUgYW55IG5vZGVcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdChyb290LCB2aXNpdG9yLCB2aXNpdG9yS2V5cyA9IFF1ZXJ5RG9jdW1lbnRLZXlzKSB7XG4gIGNvbnN0IGVudGVyTGVhdmVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBraW5kIG9mIE9iamVjdC52YWx1ZXMoS2luZCkpIHtcbiAgICBlbnRlckxlYXZlTWFwLnNldChraW5kLCBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKSk7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYtaW5pdCAqL1xuXG4gIGxldCBzdGFjayA9IHVuZGVmaW5lZDtcbiAgbGV0IGluQXJyYXkgPSBBcnJheS5pc0FycmF5KHJvb3QpO1xuICBsZXQga2V5cyA9IFtyb290XTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCBlZGl0cyA9IFtdO1xuICBsZXQgbm9kZSA9IHJvb3Q7XG4gIGxldCBrZXkgPSB1bmRlZmluZWQ7XG4gIGxldCBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYtaW5pdCAqL1xuXG4gIGRvIHtcbiAgICBpbmRleCsrO1xuICAgIGNvbnN0IGlzTGVhdmluZyA9IGluZGV4ID09PSBrZXlzLmxlbmd0aDtcbiAgICBjb25zdCBpc0VkaXRlZCA9IGlzTGVhdmluZyAmJiBlZGl0cy5sZW5ndGggIT09IDA7XG5cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBrZXkgPSBhbmNlc3RvcnMubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGFuY2VzdG9ycy5wb3AoKTtcblxuICAgICAgaWYgKGlzRWRpdGVkKSB7XG4gICAgICAgIGlmIChpbkFycmF5KSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2xpY2UoKTtcbiAgICAgICAgICBsZXQgZWRpdE9mZnNldCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtlZGl0S2V5LCBlZGl0VmFsdWVdIG9mIGVkaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUtleSA9IGVkaXRLZXkgLSBlZGl0T2Zmc2V0O1xuXG4gICAgICAgICAgICBpZiAoZWRpdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5vZGUuc3BsaWNlKGFycmF5S2V5LCAxKTtcbiAgICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZVthcnJheUtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZSksXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIG5vZGVbZWRpdEtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gc3RhY2suaW5kZXg7XG4gICAgICBrZXlzID0gc3RhY2sua2V5cztcbiAgICAgIGVkaXRzID0gc3RhY2suZWRpdHM7XG4gICAgICBpbkFycmF5ID0gc3RhY2suaW5BcnJheTtcbiAgICAgIHN0YWNrID0gc3RhY2sucHJldjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAga2V5ID0gaW5BcnJheSA/IGluZGV4IDoga2V5c1tpbmRleF07XG4gICAgICBub2RlID0gcGFyZW50W2tleV07XG5cbiAgICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgdmFyIF9lbnRlckxlYXZlTWFwJGdldCwgX2VudGVyTGVhdmVNYXAkZ2V0MjtcblxuICAgICAgaXNOb2RlKG5vZGUpIHx8IGRldkFzc2VydChmYWxzZSwgYEludmFsaWQgQVNUIE5vZGU6ICR7aW5zcGVjdChub2RlKX0uYCk7XG4gICAgICBjb25zdCB2aXNpdEZuID0gaXNMZWF2aW5nXG4gICAgICAgID8gKF9lbnRlckxlYXZlTWFwJGdldCA9IGVudGVyTGVhdmVNYXAuZ2V0KG5vZGUua2luZCkpID09PSBudWxsIHx8XG4gICAgICAgICAgX2VudGVyTGVhdmVNYXAkZ2V0ID09PSB2b2lkIDBcbiAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgIDogX2VudGVyTGVhdmVNYXAkZ2V0LmxlYXZlXG4gICAgICAgIDogKF9lbnRlckxlYXZlTWFwJGdldDIgPSBlbnRlckxlYXZlTWFwLmdldChub2RlLmtpbmQpKSA9PT0gbnVsbCB8fFxuICAgICAgICAgIF9lbnRlckxlYXZlTWFwJGdldDIgPT09IHZvaWQgMFxuICAgICAgICA/IHZvaWQgMFxuICAgICAgICA6IF9lbnRlckxlYXZlTWFwJGdldDIuZW50ZXI7XG4gICAgICByZXN1bHQgPVxuICAgICAgICB2aXNpdEZuID09PSBudWxsIHx8IHZpc2l0Rm4gPT09IHZvaWQgMFxuICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgOiB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IEJSRUFLKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoIWlzTGVhdmluZykge1xuICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRpdHMucHVzaChba2V5LCByZXN1bHRdKTtcblxuICAgICAgICBpZiAoIWlzTGVhdmluZykge1xuICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBpc0VkaXRlZCkge1xuICAgICAgZWRpdHMucHVzaChba2V5LCBub2RlXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAgcGF0aC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9ub2RlJGtpbmQ7XG5cbiAgICAgIHN0YWNrID0ge1xuICAgICAgICBpbkFycmF5LFxuICAgICAgICBpbmRleCxcbiAgICAgICAga2V5cyxcbiAgICAgICAgZWRpdHMsXG4gICAgICAgIHByZXY6IHN0YWNrLFxuICAgICAgfTtcbiAgICAgIGluQXJyYXkgPSBBcnJheS5pc0FycmF5KG5vZGUpO1xuICAgICAga2V5cyA9IGluQXJyYXlcbiAgICAgICAgPyBub2RlXG4gICAgICAgIDogKF9ub2RlJGtpbmQgPSB2aXNpdG9yS2V5c1tub2RlLmtpbmRdKSAhPT0gbnVsbCAmJlxuICAgICAgICAgIF9ub2RlJGtpbmQgIT09IHZvaWQgMFxuICAgICAgICA/IF9ub2RlJGtpbmRcbiAgICAgICAgOiBbXTtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBlZGl0cyA9IFtdO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgfVxuICB9IHdoaWxlIChzdGFjayAhPT0gdW5kZWZpbmVkKTtcblxuICBpZiAoZWRpdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gTmV3IHJvb3RcbiAgICByZXR1cm4gZWRpdHNbZWRpdHMubGVuZ3RoIC0gMV1bMV07XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2aXNpdG9yIGluc3RhbmNlIHdoaWNoIGRlbGVnYXRlcyB0byBtYW55IHZpc2l0b3JzIHRvIHJ1biBpblxuICogcGFyYWxsZWwuIEVhY2ggdmlzaXRvciB3aWxsIGJlIHZpc2l0ZWQgZm9yIGVhY2ggbm9kZSBiZWZvcmUgbW92aW5nIG9uLlxuICpcbiAqIElmIGEgcHJpb3IgdmlzaXRvciBlZGl0cyBhIG5vZGUsIG5vIGZvbGxvd2luZyB2aXNpdG9ycyB3aWxsIHNlZSB0aGF0IG5vZGUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0SW5QYXJhbGxlbCh2aXNpdG9ycykge1xuICBjb25zdCBza2lwcGluZyA9IG5ldyBBcnJheSh2aXNpdG9ycy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIGNvbnN0IG1lcmdlZFZpc2l0b3IgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAoY29uc3Qga2luZCBvZiBPYmplY3QudmFsdWVzKEtpbmQpKSB7XG4gICAgbGV0IGhhc1Zpc2l0b3IgPSBmYWxzZTtcbiAgICBjb25zdCBlbnRlckxpc3QgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgbGVhdmVMaXN0ID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgeyBlbnRlciwgbGVhdmUgfSA9IGdldEVudGVyTGVhdmVGb3JLaW5kKHZpc2l0b3JzW2ldLCBraW5kKTtcbiAgICAgIGhhc1Zpc2l0b3IgfHwgKGhhc1Zpc2l0b3IgPSBlbnRlciAhPSBudWxsIHx8IGxlYXZlICE9IG51bGwpO1xuICAgICAgZW50ZXJMaXN0W2ldID0gZW50ZXI7XG4gICAgICBsZWF2ZUxpc3RbaV0gPSBsZWF2ZTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1Zpc2l0b3IpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlZEVudGVyTGVhdmUgPSB7XG4gICAgICBlbnRlciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhcmdzWzBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2tpcHBpbmdbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfZW50ZXJMaXN0JGk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9XG4gICAgICAgICAgICAgIChfZW50ZXJMaXN0JGkgPSBlbnRlckxpc3RbaV0pID09PSBudWxsIHx8IF9lbnRlckxpc3QkaSA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICA6IF9lbnRlckxpc3QkaS5hcHBseSh2aXNpdG9yc1tpXSwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbGVhdmUoLi4uYXJncykge1xuICAgICAgICBjb25zdCBub2RlID0gYXJnc1swXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNraXBwaW5nW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2xlYXZlTGlzdCRpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPVxuICAgICAgICAgICAgICAoX2xlYXZlTGlzdCRpID0gbGVhdmVMaXN0W2ldKSA9PT0gbnVsbCB8fCBfbGVhdmVMaXN0JGkgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBfbGVhdmVMaXN0JGkuYXBwbHkodmlzaXRvcnNbaV0sIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChza2lwcGluZ1tpXSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICAgIG1lcmdlZFZpc2l0b3Jba2luZF0gPSBtZXJnZWRFbnRlckxlYXZlO1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlZFZpc2l0b3I7XG59XG4vKipcbiAqIEdpdmVuIGEgdmlzaXRvciBpbnN0YW5jZSBhbmQgYSBub2RlIGtpbmQsIHJldHVybiBFbnRlckxlYXZlVmlzaXRvciBmb3IgdGhhdCBraW5kLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKSB7XG4gIGNvbnN0IGtpbmRWaXNpdG9yID0gdmlzaXRvcltraW5kXTtcblxuICBpZiAodHlwZW9mIGtpbmRWaXNpdG9yID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHsgS2luZDogeyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH0gfVxuICAgIHJldHVybiBraW5kVmlzaXRvcjtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2luZFZpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB7IEtpbmQoKSB7fSB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyOiBraW5kVmlzaXRvcixcbiAgICAgIGxlYXZlOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSAvLyB7IGVudGVyKCkge30sIGxlYXZlKCkge30gfVxuXG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHZpc2l0b3IuZW50ZXIsXG4gICAgbGVhdmU6IHZpc2l0b3IubGVhdmUsXG4gIH07XG59XG4vKipcbiAqIEdpdmVuIGEgdmlzaXRvciBpbnN0YW5jZSwgaWYgaXQgaXMgbGVhdmluZyBvciBub3QsIGFuZCBhIG5vZGUga2luZCwgcmV0dXJuXG4gKiB0aGUgZnVuY3Rpb24gdGhlIHZpc2l0b3IgcnVudGltZSBzaG91bGQgY2FsbC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBnZXRFbnRlckxlYXZlRm9yS2luZGAgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIHYxN1xuICovXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDggKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpc2l0Rm4odmlzaXRvciwga2luZCwgaXNMZWF2aW5nKSB7XG4gIGNvbnN0IHsgZW50ZXIsIGxlYXZlIH0gPSBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKTtcbiAgcmV0dXJuIGlzTGVhdmluZyA/IGxlYXZlIDogZW50ZXI7XG59XG4iLCAiaW1wb3J0IHsgcHJpbnRCbG9ja1N0cmluZyB9IGZyb20gJy4vYmxvY2tTdHJpbmcubWpzJztcbmltcG9ydCB7IHByaW50U3RyaW5nIH0gZnJvbSAnLi9wcmludFN0cmluZy5tanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuL3Zpc2l0b3IubWpzJztcbi8qKlxuICogQ29udmVydHMgYW4gQVNUIGludG8gYSBzdHJpbmcsIHVzaW5nIG9uZSBzZXQgb2YgcmVhc29uYWJsZVxuICogZm9ybWF0dGluZyBydWxlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiB2aXNpdChhc3QsIHByaW50RG9jQVNUUmVkdWNlcik7XG59XG5jb25zdCBNQVhfTElORV9MRU5HVEggPSA4MDtcbmNvbnN0IHByaW50RG9jQVNUUmVkdWNlciA9IHtcbiAgTmFtZToge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gbm9kZS52YWx1ZSxcbiAgfSxcbiAgVmFyaWFibGU6IHtcbiAgICBsZWF2ZTogKG5vZGUpID0+ICckJyArIG5vZGUubmFtZSxcbiAgfSxcbiAgLy8gRG9jdW1lbnRcbiAgRG9jdW1lbnQ6IHtcbiAgICBsZWF2ZTogKG5vZGUpID0+IGpvaW4obm9kZS5kZWZpbml0aW9ucywgJ1xcblxcbicpLFxuICB9LFxuICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgbGVhdmUobm9kZSkge1xuICAgICAgY29uc3QgdmFyRGVmcyA9IHdyYXAoJygnLCBqb2luKG5vZGUudmFyaWFibGVEZWZpbml0aW9ucywgJywgJyksICcpJyk7XG4gICAgICBjb25zdCBwcmVmaXggPSBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgbm9kZS5vcGVyYXRpb24sXG4gICAgICAgICAgam9pbihbbm9kZS5uYW1lLCB2YXJEZWZzXSksXG4gICAgICAgICAgam9pbihub2RlLmRpcmVjdGl2ZXMsICcgJyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICk7IC8vIEFub255bW91cyBxdWVyaWVzIHdpdGggbm8gZGlyZWN0aXZlcyBvciB2YXJpYWJsZSBkZWZpbml0aW9ucyBjYW4gdXNlXG4gICAgICAvLyB0aGUgcXVlcnkgc2hvcnQgZm9ybS5cblxuICAgICAgcmV0dXJuIChwcmVmaXggPT09ICdxdWVyeScgPyAnJyA6IHByZWZpeCArICcgJykgKyBub2RlLnNlbGVjdGlvblNldDtcbiAgICB9LFxuICB9LFxuICBWYXJpYWJsZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgdmFyaWFibGUsIHR5cGUsIGRlZmF1bHRWYWx1ZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgdmFyaWFibGUgK1xuICAgICAgJzogJyArXG4gICAgICB0eXBlICtcbiAgICAgIHdyYXAoJyA9ICcsIGRlZmF1bHRWYWx1ZSkgK1xuICAgICAgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSksXG4gIH0sXG4gIFNlbGVjdGlvblNldDoge1xuICAgIGxlYXZlOiAoeyBzZWxlY3Rpb25zIH0pID0+IGJsb2NrKHNlbGVjdGlvbnMpLFxuICB9LFxuICBGaWVsZDoge1xuICAgIGxlYXZlKHsgYWxpYXMsIG5hbWUsIGFyZ3VtZW50czogYXJncywgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHdyYXAoJycsIGFsaWFzLCAnOiAnKSArIG5hbWU7XG4gICAgICBsZXQgYXJnc0xpbmUgPSBwcmVmaXggKyB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKTtcblxuICAgICAgaWYgKGFyZ3NMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgICBhcmdzTGluZSA9IHByZWZpeCArIHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gam9pbihbYXJnc0xpbmUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgc2VsZWN0aW9uU2V0XSwgJyAnKTtcbiAgICB9LFxuICB9LFxuICBBcmd1bWVudDoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBuYW1lICsgJzogJyArIHZhbHVlLFxuICB9LFxuICAvLyBGcmFnbWVudHNcbiAgRnJhZ21lbnRTcHJlYWQ6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgJy4uLicgKyBuYW1lICsgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSksXG4gIH0sXG4gIElubGluZUZyYWdtZW50OiB7XG4gICAgbGVhdmU6ICh7IHR5cGVDb25kaXRpb24sIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICcuLi4nLFxuICAgICAgICAgIHdyYXAoJ29uICcsIHR5cGVDb25kaXRpb24pLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQsXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoXG4gICAgICB7IG5hbWUsIHR5cGVDb25kaXRpb24sIHZhcmlhYmxlRGVmaW5pdGlvbnMsIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCB9LCAvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZXhwZXJpbWVudGFsIGFuZCBtYXkgYmUgY2hhbmdlZFxuICAgICkgPT5cbiAgICAgIC8vIG9yIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIGBmcmFnbWVudCAke25hbWV9JHt3cmFwKCcoJywgam9pbih2YXJpYWJsZURlZmluaXRpb25zLCAnLCAnKSwgJyknKX0gYCArXG4gICAgICBgb24gJHt0eXBlQ29uZGl0aW9ufSAke3dyYXAoJycsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgJyAnKX1gICtcbiAgICAgIHNlbGVjdGlvblNldCxcbiAgfSxcbiAgLy8gVmFsdWVcbiAgSW50VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWUsXG4gIH0sXG4gIEZsb2F0VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWUsXG4gIH0sXG4gIFN0cmluZ1ZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlLCBibG9jazogaXNCbG9ja1N0cmluZyB9KSA9PlxuICAgICAgaXNCbG9ja1N0cmluZyA/IHByaW50QmxvY2tTdHJpbmcodmFsdWUpIDogcHJpbnRTdHJpbmcodmFsdWUpLFxuICB9LFxuICBCb29sZWFuVmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gKHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyksXG4gIH0sXG4gIE51bGxWYWx1ZToge1xuICAgIGxlYXZlOiAoKSA9PiAnbnVsbCcsXG4gIH0sXG4gIEVudW1WYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSxcbiAgfSxcbiAgTGlzdFZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlcyB9KSA9PiAnWycgKyBqb2luKHZhbHVlcywgJywgJykgKyAnXScsXG4gIH0sXG4gIE9iamVjdFZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IGZpZWxkcyB9KSA9PiAneycgKyBqb2luKGZpZWxkcywgJywgJykgKyAnfScsXG4gIH0sXG4gIE9iamVjdEZpZWxkOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIHZhbHVlIH0pID0+IG5hbWUgKyAnOiAnICsgdmFsdWUsXG4gIH0sXG4gIC8vIERpcmVjdGl2ZVxuICBEaXJlY3RpdmU6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0pID0+XG4gICAgICAnQCcgKyBuYW1lICsgd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJyksXG4gIH0sXG4gIC8vIFR5cGVcbiAgTmFtZWRUeXBlOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUgfSkgPT4gbmFtZSxcbiAgfSxcbiAgTGlzdFR5cGU6IHtcbiAgICBsZWF2ZTogKHsgdHlwZSB9KSA9PiAnWycgKyB0eXBlICsgJ10nLFxuICB9LFxuICBOb25OdWxsVHlwZToge1xuICAgIGxlYXZlOiAoeyB0eXBlIH0pID0+IHR5cGUgKyAnIScsXG4gIH0sXG4gIC8vIFR5cGUgU3lzdGVtIERlZmluaXRpb25zXG4gIFNjaGVtYURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIGRpcmVjdGl2ZXMsIG9wZXJhdGlvblR5cGVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oWydzY2hlbWEnLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKG9wZXJhdGlvblR5cGVzKV0sICcgJyksXG4gIH0sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IG9wZXJhdGlvbiwgdHlwZSB9KSA9PiBvcGVyYXRpb24gKyAnOiAnICsgdHlwZSxcbiAgfSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihbJ3NjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBGaWVsZERlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGFyZ3VtZW50czogYXJncywgdHlwZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBuYW1lICtcbiAgICAgIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKVxuICAgICAgICA/IHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpXG4gICAgICAgIDogd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJykpICtcbiAgICAgICc6ICcgK1xuICAgICAgdHlwZSArXG4gICAgICB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKSxcbiAgfSxcbiAgSW5wdXRWYWx1ZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIHR5cGUsIGRlZmF1bHRWYWx1ZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFxuICAgICAgICBbbmFtZSArICc6ICcgKyB0eXBlLCB3cmFwKCc9ICcsIGRlZmF1bHRWYWx1ZSksIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEludGVyZmFjZVR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT5cbiAgICAgIHdyYXAoJycsIGRlc2NyaXB0aW9uLCAnXFxuJykgK1xuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICdpbnRlcmZhY2UnLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksXG4gICAgICAgICAgam9pbihkaXJlY3RpdmVzLCAnICcpLFxuICAgICAgICAgIGJsb2NrKGZpZWxkcyksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIHR5cGVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oXG4gICAgICAgIFsndW5pb24nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHdyYXAoJz0gJywgam9pbih0eXBlcywgJyB8ICcpKV0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEVudW1UeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcywgdmFsdWVzIH0pID0+XG4gICAgICB3cmFwKCcnLCBkZXNjcmlwdGlvbiwgJ1xcbicpICtcbiAgICAgIGpvaW4oWydlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKSxcbiAgfSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArIGpvaW4oW25hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICBqb2luKFsnaW5wdXQnLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpLFxuICB9LFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MsIHJlcGVhdGFibGUsIGxvY2F0aW9ucyB9KSA9PlxuICAgICAgd3JhcCgnJywgZGVzY3JpcHRpb24sICdcXG4nKSArXG4gICAgICAnZGlyZWN0aXZlIEAnICtcbiAgICAgIG5hbWUgK1xuICAgICAgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpXG4gICAgICAgID8gd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJylcbiAgICAgICAgOiB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSkgK1xuICAgICAgKHJlcGVhdGFibGUgPyAnIHJlcGVhdGFibGUnIDogJycpICtcbiAgICAgICcgb24gJyArXG4gICAgICBqb2luKGxvY2F0aW9ucywgJyB8ICcpLFxuICB9LFxuICBTY2hlbWFFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgZGlyZWN0aXZlcywgb3BlcmF0aW9uVHlwZXMgfSkgPT5cbiAgICAgIGpvaW4oXG4gICAgICAgIFsnZXh0ZW5kIHNjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSxcbiAgICAgICAgJyAnLFxuICAgICAgKSxcbiAgfSxcbiAgU2NhbGFyVHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzIH0pID0+XG4gICAgICBqb2luKFsnZXh0ZW5kIHNjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyksXG4gIH0sXG4gIE9iamVjdFR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+XG4gICAgICBqb2luKFxuICAgICAgICBbXG4gICAgICAgICAgJ2V4dGVuZCB0eXBlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgam9pbihcbiAgICAgICAgW1xuICAgICAgICAgICdleHRlbmQgaW50ZXJmYWNlJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICBibG9jayhmaWVsZHMpLFxuICAgICAgICBdLFxuICAgICAgICAnICcsXG4gICAgICApLFxuICB9LFxuICBVbmlvblR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcywgdHlwZXMgfSkgPT5cbiAgICAgIGpvaW4oXG4gICAgICAgIFtcbiAgICAgICAgICAnZXh0ZW5kIHVuaW9uJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGpvaW4oZGlyZWN0aXZlcywgJyAnKSxcbiAgICAgICAgICB3cmFwKCc9ICcsIGpvaW4odHlwZXMsICcgfCAnKSksXG4gICAgICAgIF0sXG4gICAgICAgICcgJyxcbiAgICAgICksXG4gIH0sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIHZhbHVlcyB9KSA9PlxuICAgICAgam9pbihbJ2V4dGVuZCBlbnVtJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayh2YWx1ZXMpXSwgJyAnKSxcbiAgfSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PlxuICAgICAgam9pbihbJ2V4dGVuZCBpbnB1dCcsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyksXG4gIH0sXG59O1xuLyoqXG4gKiBHaXZlbiBtYXliZUFycmF5LCBwcmludCBhbiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgbnVsbCBvciBlbXB0eSwgb3RoZXJ3aXNlXG4gKiBwcmludCBhbGwgaXRlbXMgdG9nZXRoZXIgc2VwYXJhdGVkIGJ5IHNlcGFyYXRvciBpZiBwcm92aWRlZFxuICovXG5cbmZ1bmN0aW9uIGpvaW4obWF5YmVBcnJheSwgc2VwYXJhdG9yID0gJycpIHtcbiAgdmFyIF9tYXliZUFycmF5JGZpbHRlciRqbztcblxuICByZXR1cm4gKF9tYXliZUFycmF5JGZpbHRlciRqbyA9XG4gICAgbWF5YmVBcnJheSA9PT0gbnVsbCB8fCBtYXliZUFycmF5ID09PSB2b2lkIDBcbiAgICAgID8gdm9pZCAwXG4gICAgICA6IG1heWJlQXJyYXkuZmlsdGVyKCh4KSA9PiB4KS5qb2luKHNlcGFyYXRvcikpICE9PSBudWxsICYmXG4gICAgX21heWJlQXJyYXkkZmlsdGVyJGpvICE9PSB2b2lkIDBcbiAgICA/IF9tYXliZUFycmF5JGZpbHRlciRqb1xuICAgIDogJyc7XG59XG4vKipcbiAqIEdpdmVuIGFycmF5LCBwcmludCBlYWNoIGl0ZW0gb24gaXRzIG93biBsaW5lLCB3cmFwcGVkIGluIGFuIGluZGVudGVkIGB7IH1gIGJsb2NrLlxuICovXG5cbmZ1bmN0aW9uIGJsb2NrKGFycmF5KSB7XG4gIHJldHVybiB3cmFwKCd7XFxuJywgaW5kZW50KGpvaW4oYXJyYXksICdcXG4nKSksICdcXG59Jyk7XG59XG4vKipcbiAqIElmIG1heWJlU3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LCB0aGVuIHdyYXAgd2l0aCBzdGFydCBhbmQgZW5kLCBvdGhlcndpc2UgcHJpbnQgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nLCBlbmQgPSAnJykge1xuICByZXR1cm4gbWF5YmVTdHJpbmcgIT0gbnVsbCAmJiBtYXliZVN0cmluZyAhPT0gJydcbiAgICA/IHN0YXJ0ICsgbWF5YmVTdHJpbmcgKyBlbmRcbiAgICA6ICcnO1xufVxuXG5mdW5jdGlvbiBpbmRlbnQoc3RyKSB7XG4gIHJldHVybiB3cmFwKCcgICcsIHN0ci5yZXBsYWNlKC9cXG4vZywgJ1xcbiAgJykpO1xufVxuXG5mdW5jdGlvbiBoYXNNdWx0aWxpbmVJdGVtcyhtYXliZUFycmF5KSB7XG4gIHZhciBfbWF5YmVBcnJheSRzb21lO1xuXG4gIC8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMjAzXG5cbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIChfbWF5YmVBcnJheSRzb21lID1cbiAgICBtYXliZUFycmF5ID09PSBudWxsIHx8IG1heWJlQXJyYXkgPT09IHZvaWQgMFxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogbWF5YmVBcnJheS5zb21lKChzdHIpID0+IHN0ci5pbmNsdWRlcygnXFxuJykpKSAhPT0gbnVsbCAmJlxuICAgIF9tYXliZUFycmF5JHNvbWUgIT09IHZvaWQgMFxuICAgID8gX21heWJlQXJyYXkkc29tZVxuICAgIDogZmFsc2U7XG59XG4iLCAiZXhwb3J0IGNvbnN0IEFDQ0VQVF9IRUFERVIgPSBgQWNjZXB0YFxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRV9IRUFERVIgPSBgQ29udGVudC1UeXBlYFxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRV9KU09OID0gYGFwcGxpY2F0aW9uL2pzb25gXG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0dRTCA9IGBhcHBsaWNhdGlvbi9ncmFwaHFsLXJlc3BvbnNlK2pzb25gXG5leHBvcnQgY29uc3Qgc3RhdHVzQ29kZXMgPSB7XG4gIHN1Y2Nlc3M6IDIwMCxcbn1cbiIsICJpbXBvcnQgeyBLaW5kIH0gZnJvbSAnZ3JhcGhxbCdcbmltcG9ydCB7IENPTlRFTlRfVFlQRV9HUUwsIENPTlRFTlRfVFlQRV9KU09OIH0gZnJvbSAnLi4vLi4vbGliL2h0dHAuanMnXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vbGliL3ByZWx1ZGUuanMnXG4vKipcbiAqIFJlZmFjdG9yZWQgaW1wb3J0cyBmcm9tIGBncmFwaHFsYCB0byBiZSBtb3JlIHNwZWNpZmljLCB0aGlzIGhlbHBzIGltcG9ydCBvbmx5IHRoZSByZXF1aXJlZCBmaWxlcyAoMTAwS2lCKVxuICogaW5zdGVhZCBvZiB0aGUgZW50aXJlIHBhY2thZ2UgKGdyZWF0ZXIgdGhhbiA1MDBLaUIpIHdoZXJlIHRyZWUtc2hha2luZyBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzb25rdWhydC9ncmFwaHFsLXJlcXVlc3QvcHVsbC81NDNcbiAqL1xuaW1wb3J0IHR5cGUgeyBPcGVyYXRpb25EZWZpbml0aW9uTm9kZSB9IGZyb20gJ2dyYXBocWwnXG5cbi8qKlxuICogQ2xlYW4gYSBHcmFwaFFMIGRvY3VtZW50IHRvIHNlbmQgaXQgdmlhIGEgR0VUIHF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCBjbGVhblF1ZXJ5ID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHN0ci5yZXBsYWNlKC8oW1xccyxdfCNbXlxcblxccl0rKSsvZywgYCBgKS50cmltKClcblxuZXhwb3J0IGNvbnN0IGlzR3JhcGhRTENvbnRlbnRUeXBlID0gKGNvbnRlbnRUeXBlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29udGVudFR5cGVMb3dlciA9IGNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKClcblxuICByZXR1cm4gY29udGVudFR5cGVMb3dlci5pbmNsdWRlcyhDT05URU5UX1RZUEVfR1FMKSB8fCBjb250ZW50VHlwZUxvd2VyLmluY2x1ZGVzKENPTlRFTlRfVFlQRV9KU09OKVxufVxuXG5leHBvcnQgdHlwZSBHcmFwaFFMUmVxdWVzdFJlc3VsdCA9IEdyYXBoUUxSZXF1ZXN0UmVzdWx0QmF0Y2ggfCBHcmFwaFFMUmVxdWVzdFJlc3VsdFNpbmdsZVxuZXhwb3J0IHR5cGUgR3JhcGhRTFJlcXVlc3RSZXN1bHRCYXRjaCA9IHsgX3RhZzogJ0JhdGNoJzsgZXhlY3V0aW9uUmVzdWx0czogR3JhcGhRTEV4ZWN1dGlvblJlc3VsdEJhdGNoIH1cbmV4cG9ydCB0eXBlIEdyYXBoUUxSZXF1ZXN0UmVzdWx0U2luZ2xlID0geyBfdGFnOiAnU2luZ2xlJzsgZXhlY3V0aW9uUmVzdWx0OiBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0U2luZ2xlIH1cblxuZXhwb3J0IHR5cGUgR3JhcGhRTEV4ZWN1dGlvblJlc3VsdCA9IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGUgfCBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0QmF0Y2hcbmV4cG9ydCB0eXBlIEdyYXBoUUxFeGVjdXRpb25SZXN1bHRCYXRjaCA9IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGVbXVxuZXhwb3J0IHR5cGUgR3JhcGhRTEV4ZWN1dGlvblJlc3VsdFNpbmdsZSA9IHtcbiAgZGF0YTogb2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZFxuICBlcnJvcnM6IHVuZGVmaW5lZCB8IG9iamVjdCB8IG9iamVjdFtdXG4gIGV4dGVuc2lvbnM/OiBvYmplY3Rcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlR3JhcGhRTEV4ZWN1dGlvblJlc3VsdCA9IChyZXN1bHQ6IHVua25vd24pOiBFcnJvciB8IEdyYXBoUUxSZXF1ZXN0UmVzdWx0ID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdGFnOiBgQmF0Y2hgLFxuICAgICAgICBleGVjdXRpb25SZXN1bHRzOiByZXN1bHQubWFwKHBhcnNlRXhlY3V0aW9uUmVzdWx0KSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3RhZzogYFNpbmdsZWAsXG4gICAgICAgIGV4ZWN1dGlvblJlc3VsdDogcGFyc2VFeGVjdXRpb25SZXN1bHQocmVzdWx0KSxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4ZWN1dGlvbiByZXN1bHQ6IHJlc3VsdCBpcyBub3Qgb2JqZWN0IG9yIGFycmF5LiBcXG5Hb3Q6XFxuJHtTdHJpbmcocmVzdWx0KX1gKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlIGFzIEVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBFeGFtcGxlIHJlc3VsdDpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICBcImRhdGFcIjogbnVsbCxcbiAqICBcImVycm9yc1wiOiBbe1xuICogICAgXCJtZXNzYWdlXCI6IFwiY3VzdG9tIGVycm9yXCIsXG4gKiAgICBcImxvY2F0aW9uc1wiOiBbeyBcImxpbmVcIjogMiwgXCJjb2x1bW5cIjogMyB9XSxcbiAqICAgIFwicGF0aFwiOiBbXCJwbGF5ZXJOZXdcIl1cbiAqICB9XVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUV4ZWN1dGlvblJlc3VsdCA9IChyZXN1bHQ6IHVua25vd24pOiBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0U2luZ2xlID0+IHtcbiAgaWYgKHR5cGVvZiByZXN1bHQgIT09IGBvYmplY3RgIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleGVjdXRpb24gcmVzdWx0OiByZXN1bHQgaXMgbm90IG9iamVjdGApXG4gIH1cblxuICBsZXQgZXJyb3JzID0gdW5kZWZpbmVkXG4gIGxldCBkYXRhID0gdW5kZWZpbmVkXG4gIGxldCBleHRlbnNpb25zID0gdW5kZWZpbmVkXG5cbiAgaWYgKGBlcnJvcnNgIGluIHJlc3VsdCkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChyZXN1bHQuZXJyb3JzKSAmJiAhQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4ZWN1dGlvbiByZXN1bHQ6IGVycm9ycyBpcyBub3QgcGxhaW4gb2JqZWN0IE9SIGFycmF5YCkgLy8gcHJldHRpZXItaWdub3JlXG4gICAgfVxuICAgIGVycm9ycyA9IHJlc3VsdC5lcnJvcnNcbiAgfVxuXG4gIC8vIHRvZG8gYWRkIHRlc3QgY292ZXJhZ2UgZm9yIGNhc2Ugb2YgbnVsbC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzb25rdWhydC9ncmFwaHFsLXJlcXVlc3QvaXNzdWVzLzczOVxuICBpZiAoYGRhdGFgIGluIHJlc3VsdCkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChyZXN1bHQuZGF0YSkgJiYgcmVzdWx0LmRhdGEgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleGVjdXRpb24gcmVzdWx0OiBkYXRhIGlzIG5vdCBwbGFpbiBvYmplY3RgKSAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB9XG4gICAgZGF0YSA9IHJlc3VsdC5kYXRhXG4gIH1cblxuICBpZiAoYGV4dGVuc2lvbnNgIGluIHJlc3VsdCkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChyZXN1bHQuZXh0ZW5zaW9ucykpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleGVjdXRpb24gcmVzdWx0OiBleHRlbnNpb25zIGlzIG5vdCBwbGFpbiBvYmplY3RgKSAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBleHRlbnNpb25zID0gcmVzdWx0LmV4dGVuc2lvbnNcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBlcnJvcnMsXG4gICAgZXh0ZW5zaW9ucyxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0UmVzdWx0SGF2ZUVycm9ycyA9IChyZXN1bHQ6IEdyYXBoUUxSZXF1ZXN0UmVzdWx0KSA9PlxuICByZXN1bHQuX3RhZyA9PT0gYEJhdGNoYFxuICAgID8gcmVzdWx0LmV4ZWN1dGlvblJlc3VsdHMuc29tZShpc0V4ZWN1dGlvblJlc3VsdEhhdmVFcnJvcnMpXG4gICAgOiBpc0V4ZWN1dGlvblJlc3VsdEhhdmVFcnJvcnMocmVzdWx0LmV4ZWN1dGlvblJlc3VsdClcblxuZXhwb3J0IGNvbnN0IGlzRXhlY3V0aW9uUmVzdWx0SGF2ZUVycm9ycyA9IChyZXN1bHQ6IEdyYXBoUUxFeGVjdXRpb25SZXN1bHRTaW5nbGUpID0+XG4gIEFycmF5LmlzQXJyYXkocmVzdWx0LmVycm9ycykgPyByZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDAgOiBCb29sZWFuKHJlc3VsdC5lcnJvcnMpXG5cbmV4cG9ydCBjb25zdCBpc09wZXJhdGlvbkRlZmluaXRpb25Ob2RlID0gKGRlZmluaXRpb246IHVua25vd24pOiBkZWZpbml0aW9uIGlzIE9wZXJhdGlvbkRlZmluaXRpb25Ob2RlID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gYG9iamVjdGBcbiAgICAmJiBkZWZpbml0aW9uICE9PSBudWxsXG4gICAgJiYgYGtpbmRgIGluIGRlZmluaXRpb25cbiAgICAmJiBkZWZpbml0aW9uLmtpbmQgPT09IEtpbmQuT1BFUkFUSU9OX0RFRklOSVRJT05cbiAgKVxufVxuIiwgImltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi4vLi4vbGliL3ByZWx1ZGUuanMnXG5pbXBvcnQgeyBpc09wZXJhdGlvbkRlZmluaXRpb25Ob2RlIH0gZnJvbSAnLi4vbGliL2dyYXBocWwuanMnXG5pbXBvcnQgdHlwZSB7IFJlcXVlc3REb2N1bWVudCB9IGZyb20gJy4vdHlwZXMuanMnXG4vKipcbiAqIFJlZmFjdG9yZWQgaW1wb3J0cyBmcm9tIGBncmFwaHFsYCB0byBiZSBtb3JlIHNwZWNpZmljLCB0aGlzIGhlbHBzIGltcG9ydCBvbmx5IHRoZSByZXF1aXJlZCBmaWxlcyAoMTAwS2lCKVxuICogaW5zdGVhZCBvZiB0aGUgZW50aXJlIHBhY2thZ2UgKGdyZWF0ZXIgdGhhbiA1MDBLaUIpIHdoZXJlIHRyZWUtc2hha2luZyBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzb25rdWhydC9ncmFwaHFsLXJlcXVlc3QvcHVsbC81NDNcbiAqL1xuaW1wb3J0IHsgdHlwZSBEb2N1bWVudE5vZGUsIE9wZXJhdGlvblR5cGVOb2RlIH0gZnJvbSAnZ3JhcGhxbCdcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnZ3JhcGhxbCdcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnZ3JhcGhxbCdcblxuLyoqXG4gKiBoZWxwZXJzXG4gKi9cblxuY29uc3QgZXh0cmFjdE9wZXJhdGlvbk5hbWUgPSAoZG9jdW1lbnQ6IERvY3VtZW50Tm9kZSk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGxldCBvcGVyYXRpb25OYW1lID0gdW5kZWZpbmVkXG5cbiAgY29uc3QgZGVmcyA9IGRvY3VtZW50LmRlZmluaXRpb25zLmZpbHRlcihpc09wZXJhdGlvbkRlZmluaXRpb25Ob2RlKVxuXG4gIGlmIChkZWZzLmxlbmd0aCA9PT0gMSkge1xuICAgIG9wZXJhdGlvbk5hbWUgPSBkZWZzWzBdIS5uYW1lPy52YWx1ZVxuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbk5hbWVcbn1cblxuY29uc3QgZXh0cmFjdElzTXV0YXRpb24gPSAoZG9jdW1lbnQ6IERvY3VtZW50Tm9kZSk6IGJvb2xlYW4gPT4ge1xuICBsZXQgaXNNdXRhdGlvbiA9IGZhbHNlXG5cbiAgY29uc3QgZGVmcyA9IGRvY3VtZW50LmRlZmluaXRpb25zLmZpbHRlcihpc09wZXJhdGlvbkRlZmluaXRpb25Ob2RlKVxuXG4gIGlmIChkZWZzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlzTXV0YXRpb24gPSBkZWZzWzBdIS5vcGVyYXRpb24gPT09IE9wZXJhdGlvblR5cGVOb2RlLk1VVEFUSU9OXG4gIH1cblxuICByZXR1cm4gaXNNdXRhdGlvblxufVxuXG5leHBvcnQgY29uc3QgYW5hbHl6ZURvY3VtZW50ID0gKFxuICBkb2N1bWVudDogUmVxdWVzdERvY3VtZW50LFxuICBleGNsdWRlT3BlcmF0aW9uTmFtZT86IGJvb2xlYW4sXG4pOiB7IGV4cHJlc3Npb246IHN0cmluZzsgb3BlcmF0aW9uTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkOyBpc011dGF0aW9uOiBib29sZWFuIH0gPT4ge1xuICBjb25zdCBleHByZXNzaW9uID0gdHlwZW9mIGRvY3VtZW50ID09PSBgc3RyaW5nYCA/IGRvY3VtZW50IDogcHJpbnQoZG9jdW1lbnQpXG5cbiAgbGV0IGlzTXV0YXRpb24gPSBmYWxzZVxuICBsZXQgb3BlcmF0aW9uTmFtZSA9IHVuZGVmaW5lZFxuXG4gIGlmIChleGNsdWRlT3BlcmF0aW9uTmFtZSkge1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIGlzTXV0YXRpb24sIG9wZXJhdGlvbk5hbWUgfVxuICB9XG5cbiAgY29uc3QgZG9jTm9kZSA9IHRyeUNhdGNoKCgpID0+ICh0eXBlb2YgZG9jdW1lbnQgPT09IGBzdHJpbmdgID8gcGFyc2UoZG9jdW1lbnQpIDogZG9jdW1lbnQpKVxuICBpZiAoZG9jTm9kZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgaXNNdXRhdGlvbiwgb3BlcmF0aW9uTmFtZSB9XG4gIH1cblxuICBvcGVyYXRpb25OYW1lID0gZXh0cmFjdE9wZXJhdGlvbk5hbWUoZG9jTm9kZSlcbiAgaXNNdXRhdGlvbiA9IGV4dHJhY3RJc011dGF0aW9uKGRvY05vZGUpXG5cbiAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgb3BlcmF0aW9uTmFtZSwgaXNNdXRhdGlvbiB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBKc29uU2VyaWFsaXplciB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0SnNvblNlcmlhbGl6ZXI6IEpzb25TZXJpYWxpemVyID0gSlNPTlxuIiwgImltcG9ydCB7IEFDQ0VQVF9IRUFERVIsIENPTlRFTlRfVFlQRV9HUUwsIENPTlRFTlRfVFlQRV9IRUFERVIsIENPTlRFTlRfVFlQRV9KU09OIH0gZnJvbSAnLi4vLi4vbGliL2h0dHAuanMnXG5pbXBvcnQgeyBjYXNlc0V4aGF1c3RlZCwgdXBwZXJjYXNlLCB6aXAgfSBmcm9tICcuLi8uLi9saWIvcHJlbHVkZS5qcydcbmltcG9ydCB7IENsaWVudEVycm9yIH0gZnJvbSAnLi4vY2xhc3Nlcy9DbGllbnRFcnJvci5qcydcbmltcG9ydCB0eXBlIHsgR3JhcGhRTEV4ZWN1dGlvblJlc3VsdFNpbmdsZSB9IGZyb20gJy4uL2xpYi9ncmFwaHFsLmpzJ1xuaW1wb3J0IHtcbiAgY2xlYW5RdWVyeSxcbiAgaXNHcmFwaFFMQ29udGVudFR5cGUsXG4gIGlzUmVxdWVzdFJlc3VsdEhhdmVFcnJvcnMsXG4gIHBhcnNlR3JhcGhRTEV4ZWN1dGlvblJlc3VsdCxcbn0gZnJvbSAnLi4vbGliL2dyYXBocWwuanMnXG5pbXBvcnQgeyBkZWZhdWx0SnNvblNlcmlhbGl6ZXIgfSBmcm9tICcuL2RlZmF1bHRKc29uU2VyaWFsaXplci5qcydcbmltcG9ydCB0eXBlIHtcbiAgQmF0Y2hWYXJpYWJsZXMsXG4gIEZldGNoLFxuICBGZXRjaE9wdGlvbnMsXG4gIEdyYXBoUUxDbGllbnRSZXNwb25zZSxcbiAgSFRUUE1ldGhvZElucHV0LFxuICBKc29uU2VyaWFsaXplcixcbiAgUmVxdWVzdE1pZGRsZXdhcmUsXG4gIFZhcmlhYmxlcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuaW50ZXJmYWNlIElucHV0IHtcbiAgdXJsOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgZm9yIHF1ZXJpZXMuIE5vdGUgdGhhdCBtdXRhdGlvbnMgYXJlIEFMV0FZUyBzZW50IGFzIFBPU1QgcmVxdWVzdHMgKFtwZXIgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3NwZWMvR3JhcGhRTE92ZXJIVFRQLm1kP3JnaC1saW5rLWRhdGU9MjAyMi0wNi0wMlQwOSUzQTMwJTNBNTNaKSkuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYCdQT1NUJ2BcbiAgICovXG4gIG1ldGhvZD86IEhUVFBNZXRob2RJbnB1dFxuICBmZXRjaD86IEZldGNoXG4gIGZldGNoT3B0aW9uczogRmV0Y2hPcHRpb25zXG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdFxuICBtaWRkbGV3YXJlPzogUmVxdWVzdE1pZGRsZXdhcmVcbiAgcmVxdWVzdDpcbiAgICB8IHtcbiAgICAgIF90YWc6ICdTaW5nbGUnXG4gICAgICB2YXJpYWJsZXM/OiBWYXJpYWJsZXNcbiAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgIGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpc011dGF0aW9uOiBib29sZWFuXG4gICAgICAgIG9wZXJhdGlvbk5hbWU/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gICAgfCB7XG4gICAgICBfdGFnOiAnQmF0Y2gnXG4gICAgICBxdWVyeTogc3RyaW5nW11cbiAgICAgIG9wZXJhdGlvbk5hbWU/OiB1bmRlZmluZWRcbiAgICAgIGhhc011dGF0aW9uczogYm9vbGVhblxuICAgICAgdmFyaWFibGVzPzogQmF0Y2hWYXJpYWJsZXNcbiAgICB9XG59XG5cbi8vIEB0cy1leHBlY3QtZXJyb3IgdG9kb1xuZXhwb3J0IGNvbnN0IHJ1blJlcXVlc3QgPSBhc3luYyAoaW5wdXQ6IElucHV0KTogUHJvbWlzZTxDbGllbnRFcnJvciB8IEdyYXBoUUxDbGllbnRSZXNwb25zZTxhbnk+PiA9PiB7XG4gIC8vIHRvZG8gbWFrZSBhIENvbmZpZyB0eXBlXG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAuLi5pbnB1dCxcbiAgICBtZXRob2Q6IGlucHV0LnJlcXVlc3QuX3RhZyA9PT0gYFNpbmdsZWBcbiAgICAgID8gaW5wdXQucmVxdWVzdC5kb2N1bWVudC5pc011dGF0aW9uXG4gICAgICAgID8gYFBPU1RgXG4gICAgICAgIDogdXBwZXJjYXNlKGlucHV0Lm1ldGhvZCA/PyBgcG9zdGApXG4gICAgICA6IGlucHV0LnJlcXVlc3QuaGFzTXV0YXRpb25zXG4gICAgICA/IGBQT1NUYFxuICAgICAgOiB1cHBlcmNhc2UoaW5wdXQubWV0aG9kID8/IGBwb3N0YCksXG4gICAgZmV0Y2hPcHRpb25zOiB7XG4gICAgICAuLi5pbnB1dC5mZXRjaE9wdGlvbnMsXG4gICAgICBlcnJvclBvbGljeTogaW5wdXQuZmV0Y2hPcHRpb25zLmVycm9yUG9saWN5ID8/IGBub25lYCxcbiAgICB9LFxuICB9XG4gIGNvbnN0IGZldGNoZXIgPSBjcmVhdGVGZXRjaGVyKGNvbmZpZy5tZXRob2QpXG4gIGNvbnN0IGZldGNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaGVyKGNvbmZpZylcblxuICBpZiAoIWZldGNoUmVzcG9uc2Uub2spIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEVycm9yKFxuICAgICAgeyBzdGF0dXM6IGZldGNoUmVzcG9uc2Uuc3RhdHVzLCBoZWFkZXJzOiBmZXRjaFJlc3BvbnNlLmhlYWRlcnMgfSxcbiAgICAgIHtcbiAgICAgICAgcXVlcnk6IGlucHV0LnJlcXVlc3QuX3RhZyA9PT0gYFNpbmdsZWAgPyBpbnB1dC5yZXF1ZXN0LmRvY3VtZW50LmV4cHJlc3Npb24gOiBpbnB1dC5yZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICB2YXJpYWJsZXM6IGlucHV0LnJlcXVlc3QudmFyaWFibGVzLFxuICAgICAgfSxcbiAgICApXG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVJlc3VsdEZyb21SZXNwb25zZShcbiAgICBmZXRjaFJlc3BvbnNlLFxuICAgIGlucHV0LmZldGNoT3B0aW9ucy5qc29uU2VyaWFsaXplciA/PyBkZWZhdWx0SnNvblNlcmlhbGl6ZXIsXG4gIClcblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHRocm93IHJlc3VsdCAvLyB0b2RvIHNvbWV0aGluZyBiZXR0ZXJcblxuICBjb25zdCBjbGllbnRSZXNwb25zZUJhc2UgPSB7XG4gICAgc3RhdHVzOiBmZXRjaFJlc3BvbnNlLnN0YXR1cyxcbiAgICBoZWFkZXJzOiBmZXRjaFJlc3BvbnNlLmhlYWRlcnMsXG4gIH1cblxuICBpZiAoaXNSZXF1ZXN0UmVzdWx0SGF2ZUVycm9ycyhyZXN1bHQpICYmIGNvbmZpZy5mZXRjaE9wdGlvbnMuZXJyb3JQb2xpY3kgPT09IGBub25lYCkge1xuICAgIC8vIHRvZG8gdGhpcyBjbGllbnQgcmVzcG9uc2Ugb24gZXJyb3IgaXMgbm90IGNvbnNpc3RlbnQgd2l0aCB0aGUgZGF0YSB0eXBlIGZvciBzdWNjZXNzXG4gICAgY29uc3QgY2xpZW50UmVzcG9uc2UgPSByZXN1bHQuX3RhZyA9PT0gYEJhdGNoYFxuICAgICAgPyB7IC4uLnJlc3VsdC5leGVjdXRpb25SZXN1bHRzLCAuLi5jbGllbnRSZXNwb25zZUJhc2UgfVxuICAgICAgOiB7XG4gICAgICAgIC4uLnJlc3VsdC5leGVjdXRpb25SZXN1bHQsXG4gICAgICAgIC4uLmNsaWVudFJlc3BvbnNlQmFzZSxcbiAgICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRvZG9cbiAgICByZXR1cm4gbmV3IENsaWVudEVycm9yKGNsaWVudFJlc3BvbnNlLCB7XG4gICAgICBxdWVyeTogaW5wdXQucmVxdWVzdC5fdGFnID09PSBgU2luZ2xlYCA/IGlucHV0LnJlcXVlc3QuZG9jdW1lbnQuZXhwcmVzc2lvbiA6IGlucHV0LnJlcXVlc3QucXVlcnksXG4gICAgICB2YXJpYWJsZXM6IGlucHV0LnJlcXVlc3QudmFyaWFibGVzLFxuICAgIH0pXG4gIH1cbiAgc3dpdGNoIChyZXN1bHQuX3RhZykge1xuICAgIGNhc2UgYFNpbmdsZWA6XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRvZG9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNsaWVudFJlc3BvbnNlQmFzZSxcbiAgICAgICAgLi4uZXhlY3V0aW9uUmVzdWx0Q2xpZW50UmVzcG9uc2VGaWVsZHMoY29uZmlnKShyZXN1bHQuZXhlY3V0aW9uUmVzdWx0KSxcbiAgICAgIH1cbiAgICBjYXNlIGBCYXRjaGA6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jbGllbnRSZXNwb25zZUJhc2UsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5leGVjdXRpb25SZXN1bHRzLm1hcChleGVjdXRpb25SZXN1bHRDbGllbnRSZXNwb25zZUZpZWxkcyhjb25maWcpKSxcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY2FzZXNFeGhhdXN0ZWQocmVzdWx0KVxuICB9XG59XG5cbmNvbnN0IGV4ZWN1dGlvblJlc3VsdENsaWVudFJlc3BvbnNlRmllbGRzID0gKCRwYXJhbXM6IElucHV0KSA9PiAoZXhlY3V0aW9uUmVzdWx0OiBHcmFwaFFMRXhlY3V0aW9uUmVzdWx0U2luZ2xlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZXh0ZW5zaW9uczogZXhlY3V0aW9uUmVzdWx0LmV4dGVuc2lvbnMsXG4gICAgZGF0YTogZXhlY3V0aW9uUmVzdWx0LmRhdGEsXG4gICAgZXJyb3JzOiAkcGFyYW1zLmZldGNoT3B0aW9ucy5lcnJvclBvbGljeSA9PT0gYGFsbGAgPyBleGVjdXRpb25SZXN1bHQuZXJyb3JzIDogdW5kZWZpbmVkLFxuICB9XG59XG5cbmNvbnN0IHBhcnNlUmVzdWx0RnJvbVJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlOiBSZXNwb25zZSwganNvblNlcmlhbGl6ZXI6IEpzb25TZXJpYWxpemVyKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQ09OVEVOVF9UWVBFX0hFQURFUilcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICBpZiAoY29udGVudFR5cGUgJiYgaXNHcmFwaFFMQ29udGVudFR5cGUoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlR3JhcGhRTEV4ZWN1dGlvblJlc3VsdChqc29uU2VyaWFsaXplci5wYXJzZSh0ZXh0KSlcbiAgfSBlbHNlIHtcbiAgICAvLyB0b2RvIHdoYXQgaXMgdGhpcyBnb29kIGZvci4uLj8gU2VlbXMgdmVyeSByYW5kb20vdW5kZWZpbmVkXG4gICAgcmV0dXJuIHBhcnNlR3JhcGhRTEV4ZWN1dGlvblJlc3VsdCh0ZXh0KVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZUZldGNoZXIgPSAobWV0aG9kOiAnR0VUJyB8ICdQT1NUJykgPT4gYXN5bmMgKHBhcmFtczogSW5wdXQpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHBhcmFtcy5oZWFkZXJzKVxuICBsZXQgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMgfCBudWxsID0gbnVsbFxuICBsZXQgYm9keSA9IHVuZGVmaW5lZFxuXG4gIGlmICghaGVhZGVycy5oYXMoQUNDRVBUX0hFQURFUikpIHtcbiAgICBoZWFkZXJzLnNldChBQ0NFUFRfSEVBREVSLCBbQ09OVEVOVF9UWVBFX0dRTCwgQ09OVEVOVF9UWVBFX0pTT05dLmpvaW4oYCwgYCkpXG4gIH1cblxuICBpZiAobWV0aG9kID09PSBgUE9TVGApIHtcbiAgICBjb25zdCAkanNvblNlcmlhbGl6ZXIgPSBwYXJhbXMuZmV0Y2hPcHRpb25zLmpzb25TZXJpYWxpemVyID8/IGRlZmF1bHRKc29uU2VyaWFsaXplclxuICAgIGJvZHkgPSAkanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KGJ1aWxkQm9keShwYXJhbXMpKVxuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gYHN0cmluZ2AgJiYgIWhlYWRlcnMuaGFzKENPTlRFTlRfVFlQRV9IRUFERVIpKSB7XG4gICAgICBoZWFkZXJzLnNldChDT05URU5UX1RZUEVfSEVBREVSLCBDT05URU5UX1RZUEVfSlNPTilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VhcmNoUGFyYW1zID0gYnVpbGRRdWVyeVBhcmFtcyhwYXJhbXMpXG4gIH1cblxuICBjb25zdCBpbml0OiBSZXF1ZXN0SW5pdCA9IHsgbWV0aG9kLCBoZWFkZXJzLCBib2R5LCAuLi5wYXJhbXMuZmV0Y2hPcHRpb25zIH1cblxuICBsZXQgdXJsID0gbmV3IFVSTChwYXJhbXMudXJsKVxuICBsZXQgaW5pdFJlc29sdmVkID0gaW5pdFxuXG4gIGlmIChwYXJhbXMubWlkZGxld2FyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShcbiAgICAgIHBhcmFtcy5taWRkbGV3YXJlKHtcbiAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgdXJsOiBwYXJhbXMudXJsLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiBwYXJhbXMucmVxdWVzdC5fdGFnID09PSBgU2luZ2xlYCA/IHBhcmFtcy5yZXF1ZXN0LmRvY3VtZW50Lm9wZXJhdGlvbk5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgIHZhcmlhYmxlczogcGFyYW1zLnJlcXVlc3QudmFyaWFibGVzLFxuICAgICAgfSksXG4gICAgKVxuICAgIGNvbnN0IHsgdXJsOiB1cmxOZXcsIC4uLmluaXROZXcgfSA9IHJlc3VsdFxuICAgIHVybCA9IG5ldyBVUkwodXJsTmV3KVxuICAgIGluaXRSZXNvbHZlZCA9IGluaXROZXdcbiAgfVxuXG4gIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCAkZmV0Y2ggPSBwYXJhbXMuZmV0Y2ggPz8gZmV0Y2hcbiAgcmV0dXJuIGF3YWl0ICRmZXRjaCh1cmwsIGluaXRSZXNvbHZlZClcbn1cblxuY29uc3QgYnVpbGRCb2R5ID0gKHBhcmFtczogSW5wdXQpID0+IHtcbiAgc3dpdGNoIChwYXJhbXMucmVxdWVzdC5fdGFnKSB7XG4gICAgY2FzZSBgU2luZ2xlYDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5OiBwYXJhbXMucmVxdWVzdC5kb2N1bWVudC5leHByZXNzaW9uLFxuICAgICAgICB2YXJpYWJsZXM6IHBhcmFtcy5yZXF1ZXN0LnZhcmlhYmxlcyxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogcGFyYW1zLnJlcXVlc3QuZG9jdW1lbnQub3BlcmF0aW9uTmFtZSxcbiAgICAgIH1cbiAgICBjYXNlIGBCYXRjaGA6XG4gICAgICByZXR1cm4gemlwKHBhcmFtcy5yZXF1ZXN0LnF1ZXJ5LCBwYXJhbXMucmVxdWVzdC52YXJpYWJsZXMgPz8gW10pLm1hcCgoW3F1ZXJ5LCB2YXJpYWJsZXNdKSA9PiAoe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IGNhc2VzRXhoYXVzdGVkKHBhcmFtcy5yZXF1ZXN0KVxuICB9XG59XG5cbmNvbnN0IGJ1aWxkUXVlcnlQYXJhbXMgPSAocGFyYW1zOiBJbnB1dCk6IFVSTFNlYXJjaFBhcmFtcyA9PiB7XG4gIGNvbnN0ICRqc29uU2VyaWFsaXplciA9IHBhcmFtcy5mZXRjaE9wdGlvbnMuanNvblNlcmlhbGl6ZXIgPz8gZGVmYXVsdEpzb25TZXJpYWxpemVyXG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBzd2l0Y2ggKHBhcmFtcy5yZXF1ZXN0Ll90YWcpIHtcbiAgICBjYXNlIGBTaW5nbGVgOiB7XG4gICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGBxdWVyeWAsIGNsZWFuUXVlcnkocGFyYW1zLnJlcXVlc3QuZG9jdW1lbnQuZXhwcmVzc2lvbikpXG4gICAgICBpZiAocGFyYW1zLnJlcXVlc3QudmFyaWFibGVzKSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYHZhcmlhYmxlc2AsICRqc29uU2VyaWFsaXplci5zdHJpbmdpZnkocGFyYW1zLnJlcXVlc3QudmFyaWFibGVzKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMucmVxdWVzdC5kb2N1bWVudC5vcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYG9wZXJhdGlvbk5hbWVgLCBwYXJhbXMucmVxdWVzdC5kb2N1bWVudC5vcGVyYXRpb25OYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtc1xuICAgIH1cbiAgICBjYXNlIGBCYXRjaGA6IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlc1NlcmlhbGl6ZWQgPSBwYXJhbXMucmVxdWVzdC52YXJpYWJsZXM/Lm1hcCgodikgPT4gJGpzb25TZXJpYWxpemVyLnN0cmluZ2lmeSh2KSkgPz8gW11cbiAgICAgIGNvbnN0IHF1ZXJpZXNDbGVhbmVkID0gcGFyYW1zLnJlcXVlc3QucXVlcnkubWFwKGNsZWFuUXVlcnkpXG4gICAgICBjb25zdCBwYXlsb2FkID0gemlwKHF1ZXJpZXNDbGVhbmVkLCB2YXJpYWJsZXNTZXJpYWxpemVkKS5tYXAoKFtxdWVyeSwgdmFyaWFibGVzXSkgPT4gKHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHZhcmlhYmxlcyxcbiAgICAgIH0pKVxuICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgcXVlcnlgLCAkanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtc1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgY2FzZXNFeGhhdXN0ZWQocGFyYW1zLnJlcXVlc3QpXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFR5cGVkRG9jdW1lbnROb2RlIH0gZnJvbSAnQGdyYXBocWwtdHlwZWQtZG9jdW1lbnQtbm9kZS9jb3JlJ1xuaW1wb3J0IHsgY2FsbE9ySWRlbnRpdHksIEhlYWRlcnNJbml0VG9QbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL2xpYi9wcmVsdWRlLmpzJ1xuaW1wb3J0IHR5cGUgeyBCYXRjaFJlcXVlc3REb2N1bWVudCwgQmF0Y2hSZXF1ZXN0c09wdGlvbnMsIEJhdGNoUmVzdWx0IH0gZnJvbSAnLi4vZnVuY3Rpb25zL2JhdGNoUmVxdWVzdHMuanMnXG5pbXBvcnQgeyBwYXJzZUJhdGNoUmVxdWVzdEFyZ3MgfSBmcm9tICcuLi9mdW5jdGlvbnMvYmF0Y2hSZXF1ZXN0cy5qcydcbmltcG9ydCB7IHBhcnNlUmF3UmVxdWVzdEFyZ3MgfSBmcm9tICcuLi9mdW5jdGlvbnMvcmF3UmVxdWVzdC5qcydcbmltcG9ydCB7IHBhcnNlUmVxdWVzdEFyZ3MgfSBmcm9tICcuLi9mdW5jdGlvbnMvcmVxdWVzdC5qcydcbmltcG9ydCB7IGFuYWx5emVEb2N1bWVudCB9IGZyb20gJy4uL2hlbHBlcnMvYW5hbHl6ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgcnVuUmVxdWVzdCB9IGZyb20gJy4uL2hlbHBlcnMvcnVuUmVxdWVzdC5qcydcbmltcG9ydCB0eXBlIHsgUmVxdWVzdERvY3VtZW50LCBSZXF1ZXN0T3B0aW9ucywgVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzIH0gZnJvbSAnLi4vaGVscGVycy90eXBlcy5qcydcbmltcG9ydCB7XG4gIHR5cGUgR3JhcGhRTENsaWVudFJlc3BvbnNlLFxuICB0eXBlIFJhd1JlcXVlc3RPcHRpb25zLFxuICB0eXBlIFJlcXVlc3RDb25maWcsXG4gIHR5cGUgVmFyaWFibGVzLFxufSBmcm9tICcuLi9oZWxwZXJzL3R5cGVzLmpzJ1xuXG4vKipcbiAqIEdyYXBoUUwgQ2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhRTENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdXJsOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHJlcXVlc3RDb25maWc6IFJlcXVlc3RDb25maWcgPSB7fSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgR3JhcGhRTCBxdWVyeSB0byB0aGUgc2VydmVyLlxuICAgKi9cbiAgcmF3UmVxdWVzdDogUmF3UmVxdWVzdE1ldGhvZCA9IGFzeW5jIDxcbiAgICBULFxuICAgICRWYXJpYWJsZXMgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXMsXG4gID4oXG4gICAgLi4uYXJnczogUmF3UmVxdWVzdE1ldGhvZEFyZ3M8JFZhcmlhYmxlcz5cbiAgKTogUHJvbWlzZTxHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD4+ID0+IHtcbiAgICBjb25zdCBbcXVlcnlPck9wdGlvbnMsIHZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnNdID0gYXJnc1xuICAgIGNvbnN0IHJhd1JlcXVlc3RPcHRpb25zID0gcGFyc2VSYXdSZXF1ZXN0QXJnczwkVmFyaWFibGVzPihcbiAgICAgIHF1ZXJ5T3JPcHRpb25zLFxuICAgICAgdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnMsXG4gICAgKVxuICAgIGNvbnN0IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBmZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgICBtZXRob2QgPSBgUE9TVGAsXG4gICAgICByZXF1ZXN0TWlkZGxld2FyZSxcbiAgICAgIHJlc3BvbnNlTWlkZGxld2FyZSxcbiAgICAgIGV4Y2x1ZGVPcGVyYXRpb25OYW1lLFxuICAgICAgLi4uZmV0Y2hPcHRpb25zXG4gICAgfSA9IHRoaXMucmVxdWVzdENvbmZpZ1xuICAgIGNvbnN0IHsgdXJsIH0gPSB0aGlzXG4gICAgaWYgKHJhd1JlcXVlc3RPcHRpb25zLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZXRjaE9wdGlvbnMuc2lnbmFsID0gcmF3UmVxdWVzdE9wdGlvbnMuc2lnbmFsXG4gICAgfVxuXG4gICAgY29uc3QgZG9jdW1lbnQgPSBhbmFseXplRG9jdW1lbnQoXG4gICAgICByYXdSZXF1ZXN0T3B0aW9ucy5xdWVyeSxcbiAgICAgIGV4Y2x1ZGVPcGVyYXRpb25OYW1lLFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnVuUmVxdWVzdCh7XG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIF90YWc6IGBTaW5nbGVgLFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgdmFyaWFibGVzOiByYXdSZXF1ZXN0T3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QoY2FsbE9ySWRlbnRpdHkoaGVhZGVycykpLFxuICAgICAgICAuLi5IZWFkZXJzSW5pdFRvUGxhaW5PYmplY3QocmF3UmVxdWVzdE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpLFxuICAgICAgfSxcbiAgICAgIGZldGNoLFxuICAgICAgbWV0aG9kLFxuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgbWlkZGxld2FyZTogcmVxdWVzdE1pZGRsZXdhcmUsXG4gICAgfSlcblxuICAgIGlmIChyZXNwb25zZU1pZGRsZXdhcmUpIHtcbiAgICAgIGF3YWl0IHJlc3BvbnNlTWlkZGxld2FyZShyZXNwb25zZSwge1xuICAgICAgICBvcGVyYXRpb25OYW1lOiBkb2N1bWVudC5vcGVyYXRpb25OYW1lLFxuICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyByZXNwb25zZVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBHcmFwaFFMIGRvY3VtZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICAvLyBkcHJpbnQtaWdub3JlXG4gIGFzeW5jIHJlcXVlc3Q8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4oZG9jdW1lbnQ6IFJlcXVlc3REb2N1bWVudCB8IFR5cGVkRG9jdW1lbnROb2RlPFQsIFY+LCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+KTogUHJvbWlzZTxUPlxuICBhc3luYyByZXF1ZXN0PFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zPFYsIFQ+KTogUHJvbWlzZTxUPlxuICBhc3luYyByZXF1ZXN0PFQsIFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICAgIGRvY3VtZW50T3JPcHRpb25zOlxuICAgICAgfCBSZXF1ZXN0RG9jdW1lbnRcbiAgICAgIHwgVHlwZWREb2N1bWVudE5vZGU8VCwgVj5cbiAgICAgIHwgUmVxdWVzdE9wdGlvbnM8Vj4sXG4gICAgLi4udmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnM6IFZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzQXJnczxWPlxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBbdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVyc10gPSB2YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyc1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gcGFyc2VSZXF1ZXN0QXJncyhcbiAgICAgIGRvY3VtZW50T3JPcHRpb25zLFxuICAgICAgdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnMsXG4gICAgKVxuXG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICAgIG1ldGhvZCA9IGBQT1NUYCxcbiAgICAgIHJlcXVlc3RNaWRkbGV3YXJlLFxuICAgICAgcmVzcG9uc2VNaWRkbGV3YXJlLFxuICAgICAgZXhjbHVkZU9wZXJhdGlvbk5hbWUsXG4gICAgICAuLi5mZXRjaE9wdGlvbnNcbiAgICB9ID0gdGhpcy5yZXF1ZXN0Q29uZmlnXG4gICAgY29uc3QgeyB1cmwgfSA9IHRoaXNcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZldGNoT3B0aW9ucy5zaWduYWwgPSByZXF1ZXN0T3B0aW9ucy5zaWduYWxcbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXplZERvY3VtZW50ID0gYW5hbHl6ZURvY3VtZW50KFxuICAgICAgcmVxdWVzdE9wdGlvbnMuZG9jdW1lbnQsXG4gICAgICBleGNsdWRlT3BlcmF0aW9uTmFtZSxcbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJ1blJlcXVlc3Qoe1xuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBfdGFnOiBgU2luZ2xlYCxcbiAgICAgICAgZG9jdW1lbnQ6IGFuYWx5emVkRG9jdW1lbnQsXG4gICAgICAgIHZhcmlhYmxlczogcmVxdWVzdE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0KGNhbGxPcklkZW50aXR5KGhlYWRlcnMpKSxcbiAgICAgICAgLi4uSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0KHJlcXVlc3RPcHRpb25zLnJlcXVlc3RIZWFkZXJzKSxcbiAgICAgIH0sXG4gICAgICBmZXRjaCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgIG1pZGRsZXdhcmU6IHJlcXVlc3RNaWRkbGV3YXJlLFxuICAgIH0pXG5cbiAgICBpZiAocmVzcG9uc2VNaWRkbGV3YXJlKSB7XG4gICAgICBhd2FpdCByZXNwb25zZU1pZGRsZXdhcmUocmVzcG9uc2UsIHtcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogYW5hbHl6ZWREb2N1bWVudC5vcGVyYXRpb25OYW1lLFxuICAgICAgICB2YXJpYWJsZXM6IHJlcXVlc3RPcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3BvbnNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIEdyYXBoUUwgZG9jdW1lbnRzIGluIGJhdGNoIHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBhc3luYyBiYXRjaFJlcXVlc3RzPFxuICAgICRCYXRjaFJlc3VsdCBleHRlbmRzIEJhdGNoUmVzdWx0LFxuICAgICRWYXJpYWJsZXMgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXMsXG4gID4oXG4gICAgZG9jdW1lbnRzOiBCYXRjaFJlcXVlc3REb2N1bWVudDwkVmFyaWFibGVzPltdLFxuICAgIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXQsXG4gICk6IFByb21pc2U8JEJhdGNoUmVzdWx0PlxuICBhc3luYyBiYXRjaFJlcXVlc3RzPFxuICAgICRCYXRjaFJlc3VsdCBleHRlbmRzIEJhdGNoUmVzdWx0LFxuICAgICRWYXJpYWJsZXMgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXMsXG4gID4ob3B0aW9uczogQmF0Y2hSZXF1ZXN0c09wdGlvbnM8JFZhcmlhYmxlcz4pOiBQcm9taXNlPCRCYXRjaFJlc3VsdD5cbiAgYXN5bmMgYmF0Y2hSZXF1ZXN0czxcbiAgICAkQmF0Y2hSZXN1bHQgZXh0ZW5kcyBCYXRjaFJlc3VsdCxcbiAgICAkVmFyaWFibGVzIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzLFxuICA+KFxuICAgIGRvY3VtZW50c09yT3B0aW9uczpcbiAgICAgIHwgQmF0Y2hSZXF1ZXN0RG9jdW1lbnQ8JFZhcmlhYmxlcz5bXVxuICAgICAgfCBCYXRjaFJlcXVlc3RzT3B0aW9uczwkVmFyaWFibGVzPixcbiAgICByZXF1ZXN0SGVhZGVycz86IEhlYWRlcnNJbml0LFxuICApOiBQcm9taXNlPCRCYXRjaFJlc3VsdD4ge1xuICAgIGNvbnN0IGJhdGNoUmVxdWVzdE9wdGlvbnMgPSBwYXJzZUJhdGNoUmVxdWVzdEFyZ3M8JFZhcmlhYmxlcz4oXG4gICAgICBkb2N1bWVudHNPck9wdGlvbnMsXG4gICAgICByZXF1ZXN0SGVhZGVycyxcbiAgICApXG4gICAgY29uc3QgeyBoZWFkZXJzLCBleGNsdWRlT3BlcmF0aW9uTmFtZSwgLi4uZmV0Y2hPcHRpb25zIH0gPSB0aGlzLnJlcXVlc3RDb25maWdcblxuICAgIGlmIChiYXRjaFJlcXVlc3RPcHRpb25zLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZXRjaE9wdGlvbnMuc2lnbmFsID0gYmF0Y2hSZXF1ZXN0T3B0aW9ucy5zaWduYWxcbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXplZERvY3VtZW50cyA9IGJhdGNoUmVxdWVzdE9wdGlvbnMuZG9jdW1lbnRzLm1hcChcbiAgICAgICh7IGRvY3VtZW50IH0pID0+IGFuYWx5emVEb2N1bWVudChkb2N1bWVudCwgZXhjbHVkZU9wZXJhdGlvbk5hbWUpLFxuICAgIClcbiAgICBjb25zdCBleHByZXNzaW9ucyA9IGFuYWx5emVkRG9jdW1lbnRzLm1hcCgoeyBleHByZXNzaW9uIH0pID0+IGV4cHJlc3Npb24pXG4gICAgY29uc3QgaGFzTXV0YXRpb25zID0gYW5hbHl6ZWREb2N1bWVudHMuc29tZSgoeyBpc011dGF0aW9uIH0pID0+IGlzTXV0YXRpb24pXG4gICAgY29uc3QgdmFyaWFibGVzID0gYmF0Y2hSZXF1ZXN0T3B0aW9ucy5kb2N1bWVudHMubWFwKFxuICAgICAgKHsgdmFyaWFibGVzIH0pID0+IHZhcmlhYmxlcyxcbiAgICApXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJ1blJlcXVlc3Qoe1xuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgX3RhZzogYEJhdGNoYCxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBxdWVyeTogZXhwcmVzc2lvbnMsXG4gICAgICAgIGhhc011dGF0aW9ucyxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0KGNhbGxPcklkZW50aXR5KGhlYWRlcnMpKSxcbiAgICAgICAgLi4uSGVhZGVyc0luaXRUb1BsYWluT2JqZWN0KGJhdGNoUmVxdWVzdE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpLFxuICAgICAgfSxcbiAgICAgIGZldGNoOiB0aGlzLnJlcXVlc3RDb25maWcuZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICAgIG1ldGhvZDogdGhpcy5yZXF1ZXN0Q29uZmlnLm1ldGhvZCB8fCBgUE9TVGAsXG4gICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICBtaWRkbGV3YXJlOiB0aGlzLnJlcXVlc3RDb25maWcucmVxdWVzdE1pZGRsZXdhcmUsXG4gICAgfSlcblxuICAgIGlmICh0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RDb25maWcucmVzcG9uc2VNaWRkbGV3YXJlKHJlc3BvbnNlLCB7XG4gICAgICAgIG9wZXJhdGlvbk5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgcmVzcG9uc2VcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICB9XG5cbiAgc2V0SGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzSW5pdCk6IHRoaXMge1xuICAgIHRoaXMucmVxdWVzdENvbmZpZy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgaGVhZGVyIHRvIHRoZSBjbGllbnQuIEFsbCBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgaGF2ZSB0aGlzIGhlYWRlci5cbiAgICovXG4gIHNldEhlYWRlcihrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy5yZXF1ZXN0Q29uZmlnXG5cbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgLy8gdG9kbyB3aGF0IGlmIGhlYWRlcnMgaXMgaW4gbmVzdGVkIGFycmF5IGZvcm0uLi4gP1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0b2RvXG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb25maWcuaGVhZGVycyA9IHsgW2tleV06IHZhbHVlIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgY2xpZW50IGVuZHBvaW50LiBBbGwgc3Vic2VxdWVudCByZXF1ZXN0cyB3aWxsIHNlbmQgdG8gdGhpcyBlbmRwb2ludC5cbiAgICovXG4gIHNldEVuZHBvaW50KHZhbHVlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybCA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmF3UmVxdWVzdE1ldGhvZCB7XG4gIDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIHZhcmlhYmxlcz86IFYsXG4gICAgcmVxdWVzdEhlYWRlcnM/OiBIZWFkZXJzSW5pdCxcbiAgKTogUHJvbWlzZTxHcmFwaFFMQ2xpZW50UmVzcG9uc2U8VD4+XG4gIDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihvcHRpb25zOiBSYXdSZXF1ZXN0T3B0aW9uczxWPik6IFByb21pc2U8XG4gICAgR3JhcGhRTENsaWVudFJlc3BvbnNlPFQ+XG4gID5cbn1cblxudHlwZSBSYXdSZXF1ZXN0TWV0aG9kQXJnczxWIGV4dGVuZHMgVmFyaWFibGVzPiA9XG4gIHwgW3F1ZXJ5OiBzdHJpbmcsIHZhcmlhYmxlcz86IFYsIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXRdXG4gIHwgW1Jhd1JlcXVlc3RPcHRpb25zPFY+XVxuIiwgImltcG9ydCB0eXBlIHsgVHlwZWREb2N1bWVudE5vZGUgfSBmcm9tICdAZ3JhcGhxbC10eXBlZC1kb2N1bWVudC1ub2RlL2NvcmUnXG5pbXBvcnQgeyBHcmFwaFFMQ2xpZW50IH0gZnJvbSAnLi4vY2xhc3Nlcy9HcmFwaFFMQ2xpZW50LmpzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0RG9jdW1lbnQsIFJlcXVlc3RPcHRpb25zLCBWYXJpYWJsZXMsIFZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzQXJncyB9IGZyb20gJy4uL2hlbHBlcnMvdHlwZXMuanMnXG5cbi8qKlxuICogU2VuZCBhIEdyYXBoUUwgRG9jdW1lbnQgdG8gdGhlIEdyYXBoUUwgc2VydmVyIGZvciBleGVjdXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogLy8gWW91IGNhbiBwYXNzIGEgcmF3IHN0cmluZ1xuICpcbiAqIGF3YWl0IHJlcXVlc3QoJ2h0dHBzOi8vZm9vLmJhci9ncmFwaHFsJywgYFxuICogICB7XG4gKiAgICAgcXVlcnkge1xuICogICAgICAgdXNlcnNcbiAqICAgICB9XG4gKiAgIH1cbiAqIGApXG4gKlxuICogLy8gWW91IGNhbiBhbHNvIHBhc3MgYSBHcmFwaFFMIERvY3VtZW50Tm9kZS4gQ29udmVuaWVudCBpZiB5b3VcbiAqIC8vIGFyZSB1c2luZyBncmFwaHFsLXRhZyBwYWNrYWdlLlxuICpcbiAqIGltcG9ydCBncWwgZnJvbSAnZ3JhcGhxbC10YWcnXG4gKlxuICogYXdhaXQgcmVxdWVzdCgnaHR0cHM6Ly9mb28uYmFyL2dyYXBocWwnLCBncWxgLi4uYClcbiAqXG4gKiAvLyBJZiB5b3UgZG9uJ3QgYWN0dWFsbHkgY2FyZSBhYm91dCB1c2luZyBEb2N1bWVudE5vZGUgYnV0IGp1c3RcbiAqIC8vIHdhbnQgdGhlIHRvb2xpbmcgc3VwcG9ydCBmb3IgZ3FsIHRlbXBsYXRlIHRhZyBsaWtlIElERSBzeW50YXhcbiAqIC8vIGNvbG9yaW5nIGFuZCBwcmV0dGllciBhdXRvZm9ybWF0IHRoZW4gbm90ZSB5b3UgY2FuIHVzZSB0aGVcbiAqIC8vIHBhc3N0aHJvdWdoIGdxbCB0YWcgc2hpcHBlZCB3aXRoIGdyYXBocWwtcmVxdWVzdCB0byBzYXZlIGEgYml0XG4gKiAvLyBvZiBwZXJmb3JtYW5jZSBhbmQgbm90IGhhdmUgdG8gaW5zdGFsbCBhbm90aGVyIGRlcCBpbnRvIHlvdXIgcHJvamVjdC5cbiAqXG4gKiBpbXBvcnQgeyBncWwgfSBmcm9tICdncmFwaHFsLXJlcXVlc3QnXG4gKlxuICogYXdhaXQgcmVxdWVzdCgnaHR0cHM6Ly9mb28uYmFyL2dyYXBocWwnLCBncWxgLi4uYClcbiAqIGBgYFxuICovXG4vLyBSRU1BUktTOiBJbiBvcmRlciB0byBoYXZlIGF1dG9jb21wbGV0ZSBmb3Igb3B0aW9ucyB3b3JrIG1ha2UgaXQgdGhlIGZpcnN0IG92ZXJsb2FkLiBJZiBub3Rcbi8vIHRoZW4gYXV0b2NvbXBsZXRlIHdpbGwgaW5zdGVhZCBzaG93IHRoZSB2YXJpb3VzIG1ldGhvZHMgZm9yIGEgc3RyaW5nLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXG4vLyBkcHJpbnQtaWdub3JlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxULCBWIGV4dGVuZHMgVmFyaWFibGVzID0gVmFyaWFibGVzPihvcHRpb25zOiBSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFYsIFQ+KTogUHJvbWlzZTxUPlxuLy8gZHByaW50LWlnbm9yZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3Q8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4odXJsOiBzdHJpbmcsIGRvY3VtZW50OiBSZXF1ZXN0RG9jdW1lbnQgfCBUeXBlZERvY3VtZW50Tm9kZTxULCBWPiwgLi4udmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnM6IFZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzQXJnczxWPik6IFByb21pc2U8VD5cbi8vIGRwcmludC1pZ25vcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3Q8VCwgViBleHRlbmRzIFZhcmlhYmxlcyA9IFZhcmlhYmxlcz4odXJsT3JPcHRpb25zOiBzdHJpbmcgfCBSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFYsIFQ+LCBkb2N1bWVudD86IFJlcXVlc3REb2N1bWVudCB8IFR5cGVkRG9jdW1lbnROb2RlPFQsIFY+LCAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+KTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gcGFyc2VSZXF1ZXN0RXh0ZW5kZWRBcmdzPFY+KHVybE9yT3B0aW9ucywgZG9jdW1lbnQsIC4uLnZhcmlhYmxlc0FuZFJlcXVlc3RIZWFkZXJzKVxuICBjb25zdCBjbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudChyZXF1ZXN0T3B0aW9ucy51cmwpXG4gIHJldHVybiBjbGllbnQucmVxdWVzdDxULCBWPih7XG4gICAgLi4ucmVxdWVzdE9wdGlvbnMsXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJlcXVlc3RBcmdzID0gPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICBkb2N1bWVudE9yT3B0aW9uczogUmVxdWVzdERvY3VtZW50IHwgUmVxdWVzdE9wdGlvbnM8Vj4sXG4gIHZhcmlhYmxlcz86IFYsXG4gIHJlcXVlc3RIZWFkZXJzPzogSGVhZGVyc0luaXQsXG4pOiBSZXF1ZXN0T3B0aW9uczxWPiA9PiB7XG4gIHJldHVybiAoZG9jdW1lbnRPck9wdGlvbnMgYXMgUmVxdWVzdE9wdGlvbnM8Vj4pLmRvY3VtZW50XG4gICAgPyAoZG9jdW1lbnRPck9wdGlvbnMgYXMgUmVxdWVzdE9wdGlvbnM8Vj4pXG4gICAgOiAoe1xuICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50T3JPcHRpb25zIGFzIFJlcXVlc3REb2N1bWVudCxcbiAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgc2lnbmFsOiB1bmRlZmluZWQsXG4gICAgfSBhcyB1bmtub3duIGFzIFJlcXVlc3RPcHRpb25zPFY+KVxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXMsIFQgPSB1bmtub3duPiA9IHtcbiAgdXJsOiBzdHJpbmdcbn0gJiBSZXF1ZXN0T3B0aW9uczxWLCBUPlxuXG5leHBvcnQgY29uc3QgcGFyc2VSZXF1ZXN0RXh0ZW5kZWRBcmdzID0gPFYgZXh0ZW5kcyBWYXJpYWJsZXMgPSBWYXJpYWJsZXM+KFxuICB1cmxPck9wdGlvbnM6IHN0cmluZyB8IFJlcXVlc3RFeHRlbmRlZE9wdGlvbnM8Vj4sXG4gIGRvY3VtZW50PzogUmVxdWVzdERvY3VtZW50LFxuICAuLi52YXJpYWJsZXNBbmRSZXF1ZXN0SGVhZGVyczogVmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNBcmdzPFY+XG4pOiBSZXF1ZXN0RXh0ZW5kZWRPcHRpb25zPFY+ID0+IHtcbiAgY29uc3QgW3ZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnNdID0gdmFyaWFibGVzQW5kUmVxdWVzdEhlYWRlcnNcbiAgcmV0dXJuIHR5cGVvZiB1cmxPck9wdGlvbnMgPT09IGBzdHJpbmdgXG4gICAgPyAoe1xuICAgICAgdXJsOiB1cmxPck9wdGlvbnMsXG4gICAgICBkb2N1bWVudDogZG9jdW1lbnQgYXMgUmVxdWVzdERvY3VtZW50LFxuICAgICAgdmFyaWFibGVzLFxuICAgICAgcmVxdWVzdEhlYWRlcnMsXG4gICAgICBzaWduYWw6IHVuZGVmaW5lZCxcbiAgICB9IGFzIHVua25vd24gYXMgUmVxdWVzdEV4dGVuZGVkT3B0aW9uczxWPilcbiAgICA6IHVybE9yT3B0aW9uc1xufVxuIiwgIi8qKlxuICogQ29udmVuaWVuY2UgcGFzc3Rocm91Z2ggdGVtcGxhdGUgdGFnIHRvIGdldCB0aGUgYmVuZWZpdHMgb2YgdG9vbGluZyBmb3IgdGhlIGdxbCB0ZW1wbGF0ZSB0YWcuIFRoaXMgZG9lcyBub3QgYWN0dWFsbHkgcGFyc2UgdGhlIGlucHV0IGludG8gYSBHcmFwaFFMIERvY3VtZW50Tm9kZSBsaWtlIGdyYXBocWwtdGFnIHBhY2thZ2UgZG9lcy4gSXQganVzdCByZXR1cm5zIHRoZSBzdHJpbmcgd2l0aCBhbnkgdmFyaWFibGVzIGdpdmVuIGludGVycG9sYXRlZC4gQ2FuIHNhdmUgeW91IGEgYml0IG9mIHBlcmZvcm1hbmNlIGFuZCBoYXZpbmcgdG8gaW5zdGFsbCBhbm90aGVyIHBhY2thZ2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogaW1wb3J0IHsgZ3FsIH0gZnJvbSAnZ3JhcGhxbC1yZXF1ZXN0J1xuICpcbiAqIGF3YWl0IHJlcXVlc3QoJ2h0dHBzOi8vZm9vLmJhci9ncmFwaHFsJywgZ3FsYC4uLmApXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFNldmVyYWwgdG9vbHMgaW4gdGhlIE5vZGUgR3JhcGhRTCBlY29zeXN0ZW0gYXJlIGhhcmRjb2RlZCB0byBzcGVjaWFsbHkgdHJlYXQgYW55IHRlbXBsYXRlIHRhZyBuYW1lZCBcImdxbFwiLiBGb3IgZXhhbXBsZSBzZWUgdGhpcyBwcmV0dGllciBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2lzc3Vlcy80MzYwLiBVc2luZyB0aGlzIHRlbXBsYXRlIHRhZyBoYXMgbm8gcnVudGltZSBlZmZlY3QgYmV5b25kIHZhcmlhYmxlIGludGVycG9sYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBncWwgPSAoY2h1bmtzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4udmFyaWFibGVzOiB1bmtub3duW10pOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gY2h1bmtzLnJlZHVjZShcbiAgICAoYWNjLCBjaHVuaywgaW5kZXgpID0+IGAke2FjY30ke2NodW5rfSR7aW5kZXggaW4gdmFyaWFibGVzID8gU3RyaW5nKHZhcmlhYmxlc1tpbmRleF0pIDogYGB9YCxcbiAgICBgYCxcbiAgKVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSw4Q0FBQUEsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxNQUNFLE1BQVE7QUFBQSxNQUNSLFNBQVc7QUFBQSxNQUNYLGFBQWU7QUFBQSxNQUNmLE1BQVE7QUFBQSxNQUNSLE9BQVM7QUFBQSxNQUNULFNBQVc7QUFBQSxRQUNULEtBQUs7QUFBQSxVQUNILE9BQVM7QUFBQSxVQUNULFNBQVc7QUFBQSxVQUNYLFNBQVc7QUFBQSxRQUNiO0FBQUEsUUFDQSxZQUFZO0FBQUEsUUFDWixlQUFlO0FBQUEsUUFDZixxQkFBcUI7QUFBQSxRQUNyQix3QkFBd0I7QUFBQSxRQUN4QixxQkFBcUI7QUFBQSxRQUNyQix3QkFBd0I7QUFB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dEI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FB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
